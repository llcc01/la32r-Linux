From 16913c9d31754d436fb639c1595c4c512a026eeb Mon Sep 17 00:00:00 2001
From: shenwei <shenwei@loongson.cn>
Date: Fri, 15 Apr 2022 19:58:28 +0800
Subject: [PATCH 42/48] LoongArch: Add loongarch files for 32bit

Loongarch supports for 32-bit kernel

Signed-off-by: shenwei <shenwei@loongson.cn>
		Fanrui Meng <mengfanrui@loongson.cn>
---
 README                                        |   29 +-
 arch/loongarch/Kbuild.platforms               |    1 +
 arch/loongarch/Kconfig                        |   73 +-
 arch/loongarch/Kconfig.debug                  |   23 +
 arch/loongarch/Makefile                       |   41 +-
 arch/loongarch/boot/dts/Makefile              |    4 +
 arch/loongarch/boot/dts/loongson/Makefile     |    3 +
 .../boot/dts/loongson/loongson32_ls.dts       |  147 ++
 arch/loongarch/configs/loongson3_defconfig    |    2 +-
 arch/loongarch/include/asm/addrspace.h        |   28 +-
 arch/loongarch/include/asm/asm.h              |   23 +
 arch/loongarch/include/asm/asmmacro-32.h      |   44 +
 arch/loongarch/include/asm/asmmacro.h         |   21 +-
 arch/loongarch/include/asm/atomic.h           |   76 +-
 arch/loongarch/include/asm/barrier.h          |   10 +
 arch/loongarch/include/asm/bitops.h           |  201 +-
 arch/loongarch/include/asm/bootinfo.h         |   26 +-
 arch/loongarch/include/asm/cmpxchg.h          |   95 +-
 arch/loongarch/include/asm/cpu-features.h     |    2 -
 arch/loongarch/include/asm/elf.h              |    3 +-
 arch/loongarch/include/asm/futex.h            |   39 +-
 arch/loongarch/include/asm/hardirq.h          |    5 +-
 arch/loongarch/include/asm/inst.h             |  176 --
 arch/loongarch/include/asm/io.h               |    9 +-
 arch/loongarch/include/asm/irqflags.h         |   18 +-
 arch/loongarch/include/asm/local.h            |   44 +
 arch/loongarch/include/asm/loongarchregs.h    |  238 +-
 .../include/asm/mach-loongson32/boot_param.h  |   92 +
 .../include/asm/mach-loongson32/irq.h         |   80 +
 .../include/asm/mach-loongson32/loongson.h    |  165 ++
 .../include/asm/mach-loongson32/topology.h    |   26 +
 arch/loongarch/include/asm/percpu.h           |    3 +-
 arch/loongarch/include/asm/pgtable-32.h       |  153 ++
 arch/loongarch/include/asm/pgtable-bits.h     |   46 +-
 arch/loongarch/include/asm/pgtable.h          |    6 +
 arch/loongarch/include/asm/stackframe.h       |    2 +-
 arch/loongarch/include/asm/syscall.h          |    6 +
 arch/loongarch/include/asm/time.h             |    9 +
 arch/loongarch/include/asm/uaccess.h          |   24 +-
 arch/loongarch/include/asm/unistd.h           |    6 +
 .../loongarch/include/asm/vdso/gettimeofday.h |   18 +
 arch/loongarch/include/uapi/asm/unistd.h      |    6 +
 arch/loongarch/kernel/Makefile                |   11 +-
 arch/loongarch/kernel/acpi.c                  |   88 -
 arch/loongarch/kernel/cpu-probe.c             |   11 -
 arch/loongarch/kernel/cpu-probe32.c           |  198 ++
 arch/loongarch/kernel/early_printk.c          |   37 +
 arch/loongarch/kernel/genex.S                 |   73 +-
 arch/loongarch/kernel/head.S                  |  101 +-
 arch/loongarch/kernel/irq.c                   |    2 +
 arch/loongarch/kernel/proc.c                  |   69 -
 arch/loongarch/kernel/ptrace.c                |   11 +-
 arch/loongarch/kernel/scall32.S               |  126 +
 arch/loongarch/kernel/scall64.S               |   66 +-
 arch/loongarch/kernel/setup.c                 |   20 +-
 arch/loongarch/kernel/switch.S                |   14 +-
 arch/loongarch/kernel/syscall.c               |   19 +-
 arch/loongarch/kernel/time.c                  |   59 +-
 arch/loongarch/kernel/topology.c              |    5 -
 arch/loongarch/kernel/traps.c                 |   13 +-
 arch/loongarch/kernel/unaligned.c             |   27 +-
 arch/loongarch/lib/Makefile                   |    4 +-
 arch/loongarch/lib/bswapdi.c                  |   17 +
 arch/loongarch/lib/bswapsi.c                  |   13 +
 arch/loongarch/lib/clear_user.S               |    4 +-
 arch/loongarch/lib/copy_user.S                |    6 +-
 arch/loongarch/lib/memcpy.S                   |    8 +-
 arch/loongarch/lib/memmove.S                  |   11 +-
 arch/loongarch/lib/memset.S                   |    5 +-
 arch/loongarch/lib/strncpy_user.S             |    6 +-
 arch/loongarch/lib/strnlen_user.S             |    4 +-
 arch/loongarch/lib/unaligned.S                |   97 +
 arch/loongarch/loongson32/Kconfig             |   66 +
 arch/loongarch/loongson32/Makefile            |   11 +
 arch/loongarch/loongson32/Platform            |   18 +
 arch/loongarch/loongson32/early_printk.c      |   71 +
 arch/loongarch/loongson32/env.c               |  151 ++
 arch/loongarch/loongson32/irq.c               |   96 +
 arch/loongarch/loongson32/mem.c               |  105 +
 arch/loongarch/loongson32/prom.c              |  125 +
 arch/loongarch/loongson32/reset.c             |   54 +
 arch/loongarch/loongson32/serial.c            |   68 +
 arch/loongarch/loongson32/setup.c             |  360 +++
 arch/loongarch/loongson32/smp.c               |   20 +
 arch/loongarch/loongson32/uart_base.c         |   29 +
 arch/loongarch/mm/Makefile                    |    6 +-
 arch/loongarch/mm/cache.c                     |   84 +-
 arch/loongarch/mm/fault.c                     |   15 +-
 arch/loongarch/mm/init.c                      |   13 +-
 arch/loongarch/mm/ioremap.c                   |    4 +-
 arch/loongarch/mm/page.S                      |   88 +-
 arch/loongarch/mm/pgtable-32.c                |   45 +
 arch/loongarch/mm/pgtable.c                   |    2 +-
 arch/loongarch/mm/tlb.c                       |   36 +-
 arch/loongarch/mm/tlbex-32.S                  |  307 +++
 arch/loongarch/pci/pci.c                      |    1 +
 arch/loongarch/vdso/vdso.lds.S                |    6 +
 config.back                                   | 2152 +++++++++++++++++
 drivers/of/Kconfig                            |    1 +
 drivers/tty/serial/8250/8250_core.c           |    2 +-
 la_build.sh                                   |   10 +
 101 files changed, 6220 insertions(+), 874 deletions(-)
 create mode 100644 arch/loongarch/boot/dts/Makefile
 create mode 100644 arch/loongarch/boot/dts/loongson/Makefile
 create mode 100644 arch/loongarch/boot/dts/loongson/loongson32_ls.dts
 create mode 100644 arch/loongarch/include/asm/asmmacro-32.h
 create mode 100644 arch/loongarch/include/asm/mach-loongson32/boot_param.h
 create mode 100644 arch/loongarch/include/asm/mach-loongson32/irq.h
 create mode 100644 arch/loongarch/include/asm/mach-loongson32/loongson.h
 create mode 100644 arch/loongarch/include/asm/mach-loongson32/topology.h
 create mode 100644 arch/loongarch/include/asm/pgtable-32.h
 create mode 100644 arch/loongarch/kernel/cpu-probe32.c
 create mode 100644 arch/loongarch/kernel/early_printk.c
 create mode 100644 arch/loongarch/kernel/scall32.S
 create mode 100644 arch/loongarch/lib/bswapdi.c
 create mode 100644 arch/loongarch/lib/bswapsi.c
 create mode 100644 arch/loongarch/lib/unaligned.S
 create mode 100644 arch/loongarch/loongson32/Kconfig
 create mode 100644 arch/loongarch/loongson32/Makefile
 create mode 100644 arch/loongarch/loongson32/Platform
 create mode 100644 arch/loongarch/loongson32/early_printk.c
 create mode 100644 arch/loongarch/loongson32/env.c
 create mode 100644 arch/loongarch/loongson32/irq.c
 create mode 100644 arch/loongarch/loongson32/mem.c
 create mode 100644 arch/loongarch/loongson32/prom.c
 create mode 100644 arch/loongarch/loongson32/reset.c
 create mode 100644 arch/loongarch/loongson32/serial.c
 create mode 100644 arch/loongarch/loongson32/setup.c
 create mode 100644 arch/loongarch/loongson32/smp.c
 create mode 100644 arch/loongarch/loongson32/uart_base.c
 create mode 100644 arch/loongarch/mm/pgtable-32.c
 create mode 100644 arch/loongarch/mm/tlbex-32.S
 create mode 100644 config.back
 create mode 100755 la_build.sh

diff --git a/README b/README
index 669ac7c32292..64f46aeaf0c3 100644
--- a/README
+++ b/README
@@ -1,18 +1,21 @@
-Linux kernel
-============
+内核编译
+    1.进入源码目录
+	cd linux-5.14-loongarch32
 
-There are several guides for kernel developers and users. These guides can
-be rendered in a number of formats, like HTML and PDF. Please read
-Documentation/admin-guide/README.rst first.
+    1.配置la_build.sh下loongarch32工具链位置
+	vim la_build.sh
+	修改CROSS_COMPILE参数，例：CROSS_COMPILE=~/work/toolchain/install/bin/loongarch32-linux-gnu-
 
-In order to build the documentation, use ``make htmldocs`` or
-``make pdfdocs``.  The formatted documentation can also be read online at:
+    2.创建生成目录
+	mkdir la_build
 
-    https://www.kernel.org/doc/html/latest/
+    4.复制配置文件config文件到la_build目录下
+	cp config.back ./la_build/.config
 
-There are various text files in the Documentation/ subdirectory,
-several of them using the Restructured Text markup notation.
+    5.编译好的busybox放在了initrd_pck32目录下
+	修改la_build/.config文件中的CONFIG_INITRAMFS_SOURCE参数
+	例：CONFIG_INITRAMFS_SOURCE="~/linux-5.14-loongarch32/initrd_pck32"
 
-Please read the Documentation/process/changes.rst file, as it contains the
-requirements for building and running the kernel, and information about
-the problems which may result by upgrading your kernel.
+    5. 执行 ./la_build.sh开始编译。默认打开了debug_info
+
+    6.生成的vmlinux内核位于la_build目录下
diff --git a/arch/loongarch/Kbuild.platforms b/arch/loongarch/Kbuild.platforms
index ad390d5c00f2..12a5cfbcc13b 100644
--- a/arch/loongarch/Kbuild.platforms
+++ b/arch/loongarch/Kbuild.platforms
@@ -1,6 +1,7 @@
 # All platforms listed in alphabetic order
 
 platforms += loongson64
+platforms += loongson32
 
 # include the platform specific files
 include $(patsubst %, $(srctree)/arch/loongarch/%/Platform, $(platforms))
diff --git a/arch/loongarch/Kconfig b/arch/loongarch/Kconfig
index 8a5e5db9aa6e..15e5a93b7589 100644
--- a/arch/loongarch/Kconfig
+++ b/arch/loongarch/Kconfig
@@ -37,7 +37,7 @@ config LOONGARCH
 	select ARCH_INLINE_SPIN_UNLOCK_IRQRESTORE if !PREEMPTION
 	select ARCH_SUPPORTS_ACPI
 	select ARCH_SUPPORTS_HUGETLBFS
-	select ARCH_SUPPORTS_NUMA_BALANCING
+	#select ARCH_SUPPORTS_NUMA_BALANCING
 	select ARCH_USE_BUILTIN_BSWAP
 	select ARCH_USE_CMPXCHG_LOCKREF if 64BIT
 	select ARCH_USE_QUEUED_RWLOCKS
@@ -66,7 +66,7 @@ config LOONGARCH
 	select HAVE_ARCH_MMAP_RND_BITS if MMU
 	select HAVE_ARCH_SECCOMP_FILTER
 	select HAVE_ARCH_TRACEHOOK
-	select HAVE_ARCH_TRANSPARENT_HUGEPAGE
+	select HAVE_ARCH_TRANSPARENT_HUGEPAGE if CPU_SUPPORTS_HUGEPAGES && 64BIT
 	select HAVE_ASM_MODVERSIONS
 	select HAVE_CONTEXT_TRACKING
 	select HAVE_COPY_THREAD_TLS
@@ -102,7 +102,7 @@ menu "Machine selection"
 
 choice
 	prompt "System type"
-	default MACH_LOONGSON64
+	default MACH_LOONGSON32
 
 config MACH_LOONGSON64
 	bool "Loongson 64-bit family of machines"
@@ -125,10 +125,30 @@ config MACH_LOONGSON64
 	  machines are based on new Loongson-3 processors (Old Loongson is MIPS
 	  compatible, while new Loongson is based on LoongArch ISA).
 
+config MACH_LOONGSON32
+	bool "Loongson 32-bit family of machines"
+	select IRQ_LOONGARCH_CPU
+	select NR_CPUS_DEFAULT_1
+#	select SYS_SUPPORTS_HIGHMEM
+	select SYS_HAS_CPU_LOONGSON32
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select ZONE_DMA32
+#	select PCI
+#	select HAVE_PCI
+	help
+	  This enables the support of Loongson 32-bit family of machines. These
+	  machines are based on new Loongson-3 processors.
 endchoice
 
+source "arch/loongarch/loongson32/Kconfig"
+
 endmenu
 
+if 32BIT
+config SYS_HAS_EARLY_PRINTK
+        bool
+endif
+
 config GENERIC_HWEIGHT
 	bool
 	default y
@@ -144,6 +164,7 @@ config SCHED_OMIT_FRAME_POINTER
 config SYS_SUPPORTS_HOTPLUG_CPU
 	bool
 
+
 config GENERIC_CSUM
 	def_bool y
 
@@ -152,10 +173,9 @@ config L1_CACHE_SHIFT
 	default "6"
 
 menu "CPU selection"
-
 choice
 	prompt "CPU type"
-	default CPU_LOONGSON64
+	default CPU_LOONGSON32
 
 config CPU_LOONGSON64
 	bool "Loongson 64-bit CPU"
@@ -169,19 +189,34 @@ config CPU_LOONGSON64
 	  The Loongson 64-bit processor implements the LoongArch64 (the 64-bit
 	  version of LoongArch) instruction set.
 
-endchoice
+config CPU_LOONGSON32
+	bool "Loongson 32-bit CPU"
+	depends on SYS_HAS_CPU_LOONGSON32
+	#select ARCH_HAS_PHYS_TO_DMA
+	select CPU_SUPPORTS_32BIT_KERNEL
+	#select SWIOTLB
+	select ARCH_SUPPORTS_ATOMIC_RMW
+	help
+	  The Loongson 32-bit processor implements the LoongArch32 (the 32-bit
+	  version of LoongArch) instruction set.
 
+endchoice
 config SYS_HAS_CPU_LOONGSON64
 	bool
 
-endmenu
+config SYS_HAS_CPU_LOONGSON32
+	bool
 
+endmenu
 config SYS_SUPPORTS_32BIT_KERNEL
 	bool
+
 config SYS_SUPPORTS_64BIT_KERNEL
 	bool
+
 config CPU_SUPPORTS_32BIT_KERNEL
 	bool
+
 config CPU_SUPPORTS_64BIT_KERNEL
 	bool
 
@@ -208,11 +243,10 @@ config 64BIT
 	  Select this option if you want to build a 64-bit kernel.
 
 endchoice
-
 choice
 	prompt "Kernel page size"
-	default PAGE_SIZE_16KB
-
+	default PAGE_SIZE_16KB if MACH_LOONGSON64
+	default PAGE_SIZE_4KB if MACH_LOONGSON32
 config PAGE_SIZE_4KB
 	bool "4kB"
 	help
@@ -446,11 +480,25 @@ config SECCOMP
 	  enabled via /proc/<pid>/seccomp, it cannot be disabled
 	  and the task is only allowed to execute a few safe syscalls
 	  defined by each seccomp mode.
-
 	  If unsure, say Y. Only embedded should say N here.
+#if 32bit
+config BUILTIN_DTB
+        bool "Enable builtin dtb in kernel"
+        depends on MACH_LOONGSON32
+        default y
+        help
+          Enable builtin dtb in kernel, If the firmware does not provide
+          an available DTB, this will be used.
+
+config BUILTIN_DTB_NAME
+        string "Built in DTB"
+        depends on BUILTIN_DTB
+        default "loongson32_ls"
+        help
+          Set the name of the DTB to embed in the vmlinux binary
+#if 32bit end
 
 endmenu
-
 config ARCH_ENABLE_MEMORY_HOTPLUG
 	def_bool y
 	depends on LOONGARCH
@@ -475,6 +523,7 @@ config PGTABLE_LEVELS
 	int
 	default 4 if PAGE_SIZE_4KB && VA_BITS_48
 	default 2 if PAGE_SIZE_64KB && VA_BITS_40
+	default 2 if PAGE_SIZE_4KB
 	default 3
 
 config MMU
diff --git a/arch/loongarch/Kconfig.debug b/arch/loongarch/Kconfig.debug
index e69de29bb2d1..927a2584ba9a 100644
--- a/arch/loongarch/Kconfig.debug
+++ b/arch/loongarch/Kconfig.debug
@@ -0,0 +1,23 @@
+config EARLY_PRINTK
+        bool "Early printk" if EXPERT
+        depends on SYS_HAS_EARLY_PRINTK
+        default y
+        help
+          This option enables special console drivers which allow the kernel
+          to print messages very early in the bootup process.
+
+          This is useful for kernel debugging when your machine crashes very
+          early before the console code is initialized. For normal operation,
+          it is not recommended because it looks ugly on some machines and
+          doesn't cooperate with an X server. You should normally say N here,
+          unless you want to debug such a crash.
+
+config EARLY_PRINTK_8250
+        bool
+        depends on EARLY_PRINTK && USE_GENERIC_EARLY_PRINTK_8250
+        default y
+        help
+          "8250/16550 and compatible serial early printk driver"
+          If you say Y here, it will be possible to use a 8250/16550 serial
+          port as the boot console.
+
diff --git a/arch/loongarch/Makefile b/arch/loongarch/Makefile
index b36a0e8e6585..af02419b7bcc 100644
--- a/arch/loongarch/Makefile
+++ b/arch/loongarch/Makefile
@@ -2,17 +2,24 @@
 #
 # Author: Huacai Chen <chenhuacai@loongson.cn>
 # Copyright (C) 2020-2021 Loongson Technology Corporation Limited
-
+#
 KBUILD_DEFCONFIG := loongson3_defconfig
-
+#ifdef CONFIG_32BIT
+KBUILD_DTBS      := dtbs
+#endif
 #
 # Select the object file format to substitute into the linker script.
 #
+32bit-tool-archpref     = loongarch32
 64bit-tool-archpref	= loongarch64
 32bit-bfd		= elf32-loongarch
 64bit-bfd		= elf64-loongarch
 32bit-emul		= elf32loongarch
 64bit-emul		= elf64loongarch
+ifdef CONFIG_32BIT
+tool-archpref           =$(32bit-tool-archpref)
+UTS_MACHINE             := loongarch32
+endif
 
 ifdef CONFIG_64BIT
 tool-archpref		= $(64bit-tool-archpref)
@@ -24,8 +31,14 @@ ifneq ($(SUBARCH),$(ARCH))
     CROSS_COMPILE := $(call cc-cross-prefix, $(tool-archpref)-linux-  $(tool-archpref)-linux-gnu-  $(tool-archpref)-unknown-linux-gnu-)
   endif
 endif
-
 cflags-y += $(call cc-option, -mno-check-zero-division)
+ifdef CONFIG_32BIT
+ld-emul                 = $(32bit-emul)
+vmlinux-32              = vmlinux.32
+
+cflags-y                += -mabi=ilp32
+endif
+
 
 ifdef CONFIG_64BIT
 ld-emul			= $(64bit-emul)
@@ -47,9 +60,17 @@ KBUILD_AFLAGS_KERNEL		+= -Wa,-mla-global-with-pcrel
 KBUILD_CFLAGS_KERNEL		+= -Wa,-mla-global-with-pcrel
 KBUILD_AFLAGS_MODULE		+= -Wa,-mla-global-with-abs
 KBUILD_CFLAGS_MODULE		+= -fno-plt -Wa,-mla-global-with-abs,-mla-local-with-abs
-
+#ifdef CONFIG_32BIT
+KBUILD_CFLAGS_MODULE            += -fno-optimize-sibling-calls
+ifneq ($(call as-option,-Wa$(comma)-msoft-float,),)
+        cflags-y                += -DGAS_HAS_SET_HARDFLOAT -Wa,-msoft-float
+endif
+toolchain-virt                          := $(call cc-option-yn,$(loongarch-cflags) -mvirt)
+cflags-$(toolchain-virt)                += -DTOOLCHAIN_SUPPORTS_VIRT
+toolchain-crc                           := $(call cc-option-yn,$(loongarch-cflags) -Wa$(comma)-mcrc)
+cflags-$(toolchain-crc)                 += -DTOOLCHAIN_SUPPORTS_CRC
+#endif
 cflags-y += -ffreestanding
-
 # Some distribution-specific toolchains might pass the -fstack-check
 # option during the build, which adds a simple stack-probe at the beginning
 # of every function.  This stack probe is to ensure that there is enough
@@ -73,8 +94,10 @@ drivers-$(CONFIG_PCI)		+= arch/loongarch/pci/
 KBUILD_AFLAGS	+= $(cflags-y)
 KBUILD_CFLAGS	+= $(cflags-y)
 KBUILD_CPPFLAGS += -DVMLINUX_LOAD_ADDRESS=$(load-y)
-
 bootvars-y	= VMLINUX_LOAD_ADDRESS=$(load-y) PLATFORM="$(platform-y)"
+ifdef CONFIG_32BIT
+bootvars-y      += ADDR_BITS=32
+endif
 
 ifdef CONFIG_64BIT
 bootvars-y	+= ADDR_BITS=64
@@ -106,15 +129,15 @@ vdso_install:
 
 # boot image targets (arch/loongarch/boot/)
 boot-y := vmlinux.bin
-
-all:	$(all-y)
+all:	$(all-y) $(KBUILD_DTBS)
 
 # boot
 $(boot-y): vmlinux FORCE
 	$(Q)$(MAKE) $(build)=arch/loongarch/boot VMLINUX=vmlinux \
 		$(bootvars-y) arch/loongarch/boot/$@
-
 CLEAN_FILES += vmlinux
+# device-trees
+core-$(CONFIG_BUILTIN_DTB) += arch/loongarch/boot/dts/
 
 install:
 	$(Q)install -D -m 755 vmlinux $(INSTALL_PATH)/vmlinux-$(KERNELRELEASE)
diff --git a/arch/loongarch/boot/dts/Makefile b/arch/loongarch/boot/dts/Makefile
new file mode 100644
index 000000000000..94c45818e4c9
--- /dev/null
+++ b/arch/loongarch/boot/dts/Makefile
@@ -0,0 +1,4 @@
+# SPDX-License-Identifier: GPL-2.0
+subdir-y	+= loongson
+
+obj-$(CONFIG_BUILTIN_DTB)	:= $(addsuffix /, $(subdir-y))
diff --git a/arch/loongarch/boot/dts/loongson/Makefile b/arch/loongarch/boot/dts/loongson/Makefile
new file mode 100644
index 000000000000..1de9817ab459
--- /dev/null
+++ b/arch/loongarch/boot/dts/loongson/Makefile
@@ -0,0 +1,3 @@
+# SPDX-License-Identifier: GPL-2.0
+dtb-$(CONFIG_32BIT) += loongson32_ls.dtb
+obj-y				+= $(patsubst %.dtb, %.dtb.o, $(dtb-y))
diff --git a/arch/loongarch/boot/dts/loongson/loongson32_ls.dts b/arch/loongarch/boot/dts/loongson/loongson32_ls.dts
new file mode 100644
index 000000000000..d7369679179a
--- /dev/null
+++ b/arch/loongarch/boot/dts/loongson/loongson32_ls.dts
@@ -0,0 +1,147 @@
+/dts-v1/;
+/{
+        model = "loongson,generic";
+        compatible = "loongson,loongson3";
+        #address-cells = <1>;
+        #size-cells = <1>;
+
+        aliases {
+                //ethernet0 = &gmac0;
+                //ethernet1 = &gmac1;
+                serial0 = &cpu_uart0;
+        };
+
+        chosen {
+                stdout-path = "serial0:115200n8";
+                bootargs = "earlycon";
+        };
+
+
+	extioiic: interrupt-controller@0x1fe11600 {
+                compatible = "loongson,extioi-interrupt-controller";
+                interrupt-controller;
+                #interrupt-cells = <1>;
+                interrupt-parent = <&cpuic>;
+                interrupts = <3>;
+                interrupt-names = "cascade";
+                vec_count=<128>;
+                misc_func=<0x100>;
+                eio_en_off=<27>;
+        };
+
+
+
+    memory {
+                name = "memory";
+                device_type = "memory";
+                reg =  <0x00000000  0x08000000>;
+        };
+
+	cpuic: interrupt-controller {
+       		compatible = "loongson,cpu-interrupt-controller";
+            	interrupt-controller;
+		#interrupt-cells = <1>;
+	};
+
+	soc {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges = <0x10000000 0x10000000 0x10000000 >;
+
+
+	    cpu_uart0: serial@0x1fe001e0 {
+                        compatible = "ns16550a";
+                        reg = < 0x1fe001e0  0x10>;
+                        clock-frequency = <33000000>;
+                        interrupt-parent = <&cpuic>;
+                        interrupts = <2>;
+                        no-loopback-test;
+                };
+
+//     //   gmac0: ethernet@0x1ff00000 {
+//        gmac0: dmfe@0x1ff00000{
+//                        compatible = "dmfe";
+//                        reg = <0x1ff00000 0x10000>;
+//                        interrupt-parent = <&cpuic>;
+//                        interrupts = <3>;
+//                        interrupt-names = "macirq";
+//                        mac-address = [ 64 48 48 48 48 60 ];/* [>mac 64:48:48:48:48:60 <]*/
+//                        phy-mode = "rgmii";
+//                        bus_id = <0x0>;
+//                        phy_addr = <0xffffffff>;
+//                        dma-mask = <0xffffffff 0xffffffff>;
+//                };
+//
+//
+//#if 0
+//
+//            ahci@0x1fe30000{
+//                compatible = "snps,spear-ahci";
+//                reg = <0x1fe30000 0x10000>;
+//                interrupt-parent = <&cpuic>;
+//                interrupts = <4>;
+//                dma-mask = <0x0 0xffffffff>;
+//            };
+//#endif
+//
+//        nand@0x1fe78000{
+//             #address-cells = <1>;
+//             #size-cells = <1>;
+//             compatible = "ls1a-nand";
+//             reg = <0x1fe78000 0x4000
+//                 0x1fd01160 0x0>;
+//             interrupt-parent = <&cpuic>;
+//             interrupts = <4>;
+//             interrupt-names = "nand_irq";
+//#if 0
+//             dmas = <&dma0 1>;
+//             dma-names = "nand_rw";
+//             dma-mask = <0xffffffff 0xffffffff>;
+// #endif
+//             number-of-parts = <0x2>;
+//
+//             partition@0 {
+//                 label = "kernel_partition";
+//                 reg = <0x0000000 0x01400000>;
+//             };
+//
+//             partition@0x01400000 {
+//                 label = "os_partition";
+//                 reg = <0x01400000 0x0>;
+//             };
+//         };
+
+
+
+                        //clock-frequency = <100000000>;
+//
+	    //        gmac0: ethernet@0x1f020000 {
+//             compatible = "snps,dwmac-3.70a";
+//             reg = <0x1f020000 0x10000>;
+//             interrupt-parent = <&cpuic>;
+//             interrupts = <3>;
+//             interrupt-names = "macirq";
+//             mac-address = [ 64 48 48 48 48 60 ];/* [>mac 64:48:48:48:48:60 <]*/
+//             phy-mode = "rgmii";
+//             bus_id = <0x0>;
+//             phy_addr = <0xffffffff>;
+//             dma-mask = <0xffffffff 0xffffffff>;
+//         };
+
+
+//                gmac1: ethernet@0x1f030000 {
+//                        compatible = "snps,dwmac-3.70a";
+//                        reg = <0 0x1f030000 0 0x10000>;
+//                        interrupt-parent = <&extioiic>;
+//                        interrupts = <119>;
+//                        interrupt-names = "macirq";
+//                        mac-address = [ 64 48 48 48 48 61 ];/* [>mac 64:48:48:48:48:61 <]*/
+//                        phy-mode = "rgmii";
+//                        bus_id = <0x1>;
+//                        phy_addr = <0xffffffff>;
+//                        dma-mask = <0xffffffff 0xffffffff>;
+//		};
+    };
+};
+
diff --git a/arch/loongarch/configs/loongson3_defconfig b/arch/loongarch/configs/loongson3_defconfig
index cd01aa48ac1a..af8bd06c78e8 100644
--- a/arch/loongarch/configs/loongson3_defconfig
+++ b/arch/loongarch/configs/loongson3_defconfig
@@ -4,7 +4,7 @@ CONFIG_SYSVIPC=y
 CONFIG_LOONGARCH=y
 CONFIG_MACH_LOONGSON64=y
 CONFIG_CPU_LOONGSON64=y
-CONFIG_64BIT=y
+CONFIG_32BIT=y
 CONFIG_DMI=y
 CONFIG_POSIX_MQUEUE=y
 CONFIG_NO_HZ=y
diff --git a/arch/loongarch/include/asm/addrspace.h b/arch/loongarch/include/asm/addrspace.h
index bebff6ee1aec..0c7f77d9a8ab 100644
--- a/arch/loongarch/include/asm/addrspace.h
+++ b/arch/loongarch/include/asm/addrspace.h
@@ -6,7 +6,6 @@
 #define _ASM_ADDRSPACE_H
 
 #include <linux/const.h>
-
 #include <asm/loongarchregs.h>
 
 /*
@@ -31,7 +30,14 @@ extern unsigned long vm_map_base;
 #define UNCAC_BASE		CSR_DMW0_BASE
 #endif
 
+#ifdef CONFIG_32BIT
+#define DMW_PABITS	28
+#endif
+
+#ifdef CONFIG_64BIT
 #define DMW_PABITS	48
+#endif
+
 #define TO_PHYS_MASK	((1ULL << DMW_PABITS) - 1)
 
 /*
@@ -79,32 +85,38 @@ extern unsigned long vm_map_base;
  *  32/64-bit LoongArch address spaces
  */
 #ifdef __ASSEMBLY__
+#ifdef CONFIG_32BIT
 #define _ACAST32_
+#endif
+#ifdef CONFIG_64BIT
 #define _ACAST64_
+#endif
+
 #else
+#ifdef CONFIG_32BIT
 #define _ACAST32_		(_ATYPE_)(_ATYPE32_)	/* widen if necessary */
+#endif
+#ifdef CONFIG_64BIT
 #define _ACAST64_		(_ATYPE64_)		/* do _not_ narrow */
 #endif
+#endif
 
 #ifdef CONFIG_32BIT
-
+#define MAP_BASE                _AC(0xc0000000, UL)
 #define UVRANGE			0x00000000
 #define KPRANGE0		0x80000000
 #define KPRANGE1		0xa0000000
 #define KVRANGE			0xc0000000
-
-#else
-
+#endif
+#ifdef CONFIG_64BIT
 #define XUVRANGE		_CONST64_(0x0000000000000000)
 #define XSPRANGE		_CONST64_(0x4000000000000000)
 #define XKPRANGE		_CONST64_(0x8000000000000000)
 #define XKVRANGE		_CONST64_(0xc000000000000000)
-
 #endif
 
 /*
  * Returns the physical address of a KPRANGEx / XKPRANGE address
  */
-#define PHYSADDR(a)		((_ACAST64_(a)) & TO_PHYS_MASK)
-
+#define PHYSADDR(a)		((_ACAST32_(a)) & TO_PHYS_MASK)
 #endif /* _ASM_ADDRSPACE_H */
diff --git a/arch/loongarch/include/asm/asm.h b/arch/loongarch/include/asm/asm.h
index 767c1acf1369..27a103254ac4 100644
--- a/arch/loongarch/include/asm/asm.h
+++ b/arch/loongarch/include/asm/asm.h
@@ -57,6 +57,11 @@
 /*
  * Stack alignment
  */
+#if (_LOONGARCH_SIM == _LOONGARCH_SIM_ABILP32)
+#define ALSZ    7
+#define ALMASK  ~7
+#endif
+
 #if (_LOONGARCH_SIM == _LOONGARCH_SIM_ABILP64)
 #define ALSZ	15
 #define ALMASK	~15
@@ -79,6 +84,15 @@
  * Use the following macros in assemblercode to load/store registers,
  * pointers etc.
  */
+#if (_LOONGARCH_SIM == _LOONGARCH_SIM_ABILP32)
+#define REG_S           st.w
+#define REG_L           ld.w
+#define REG_SUBU        sub.w
+#define REG_ADDU        add.w
+#define REG_PTR_S       st.w
+#define REG_PTR_L       ld.w
+#endif
+
 #if (_LOONGARCH_SIM == _LOONGARCH_SIM_ABILP64)
 #define REG_S		st.d
 #define REG_L		ld.d
@@ -208,5 +222,14 @@
 #define PTRSIZE		8
 #define PTRLOG		3
 #endif
+#ifdef CONFIG_32BIT
+#define LONG_LPTR       ld.w
+#define LONG_SPTR       st.w
+#endif
+
+#ifdef CONFIG_64BIT
+#define LONG_LPTR       ldptr.d
+#define LONG_SPTR       stptr.d
+#endif
 
 #endif /* __ASM_ASM_H */
diff --git a/arch/loongarch/include/asm/asmmacro-32.h b/arch/loongarch/include/asm/asmmacro-32.h
new file mode 100644
index 000000000000..8b0b79c01a1f
--- /dev/null
+++ b/arch/loongarch/include/asm/asmmacro-32.h
@@ -0,0 +1,44 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * asmmacro.h: Assembler macros to make things easier to read.
+ *
+ * Copyright (C) 2020-2021 Loongson Technology Corporation Limited
+ */
+#ifndef _ASM_ASMMACRO_32_H
+#define _ASM_ASMMACRO_32_H
+
+#include <asm/asm-offsets.h>
+#include <asm/regdef.h>
+#include <asm/fpregdef.h>
+#include <asm/loongarchregs.h>
+
+	.macro	cpu_save_nonscratch thread
+	st.w	s0, \thread, THREAD_REG23
+	st.w	s1, \thread, THREAD_REG24
+	st.w	s2, \thread, THREAD_REG25
+	st.w	s3, \thread, THREAD_REG26
+	st.w	s4, \thread, THREAD_REG27
+	st.w	s5, \thread, THREAD_REG28
+	st.w	s6, \thread, THREAD_REG29
+	st.w	s7, \thread, THREAD_REG30
+	st.w	s8, \thread, THREAD_REG31
+	st.w	sp, \thread, THREAD_REG03
+	st.w	fp, \thread, THREAD_REG22
+	.endm
+
+	.macro	cpu_restore_nonscratch thread
+	ld.w	s0, \thread, THREAD_REG23
+	ld.w	s1, \thread, THREAD_REG24
+	ld.w	s2, \thread, THREAD_REG25
+	ld.w	s3, \thread, THREAD_REG26
+	ld.w	s4, \thread, THREAD_REG27
+	ld.w	s5, \thread, THREAD_REG28
+	ld.w	s6, \thread, THREAD_REG29
+	ld.w	s7, \thread, THREAD_REG30
+	ld.w	s8, \thread, THREAD_REG31
+	ld.w	sp, \thread, THREAD_REG03
+	ld.w	fp, \thread, THREAD_REG22
+	ld.w	ra, \thread, THREAD_REG01
+	.endm
+
+#endif /* _ASM_ASMMACRO_32_H */
diff --git a/arch/loongarch/include/asm/asmmacro.h b/arch/loongarch/include/asm/asmmacro.h
index 3b436dd04056..696efdcfe921 100644
--- a/arch/loongarch/include/asm/asmmacro.h
+++ b/arch/loongarch/include/asm/asmmacro.h
@@ -10,6 +10,7 @@
 #ifdef CONFIG_32BIT
 #include <asm/asmmacro-32.h>
 #endif
+
 #ifdef CONFIG_64BIT
 #include <asm/asmmacro-64.h>
 #endif
@@ -259,11 +260,17 @@
 	fld.d	$f30, \tmp, THREAD_FPR30 - THREAD_FPR0
 	fld.d	$f31, \tmp, THREAD_FPR31 - THREAD_FPR0
 	.endm
-
 .macro move dst src
-	slli.d	\dst, \src, 0
+#ifdef CONFIG_64BIT
+	slli.d  \dst, \src, 0
+#endif
+
+#ifdef CONFIG_32BIT
+	slli.w \dst, \src, 0
+#endif
 .endm
 
+
 .macro jr dst
 	jirl	zero, \dst, 0
 .endm
@@ -287,6 +294,16 @@
 .macro bgez r0 label
 	bge \r0, zero, \label
 .endm
+#ifdef CONFIG_32BIT
+.macro beqz r0 label
+        beq \r0, zero , \label
+.endm
+
+.macro bnez r0 label
+        bne \r0, zero , \label
+.endm
+#endif
+
 
 #define v0 $r4
 #define v1 $r5
diff --git a/arch/loongarch/include/asm/atomic.h b/arch/loongarch/include/asm/atomic.h
index afb5256e5d11..f2b737b15edb 100644
--- a/arch/loongarch/include/asm/atomic.h
+++ b/arch/loongarch/include/asm/atomic.h
@@ -32,7 +32,7 @@
  * Atomically sets the value of @v to @i.
  */
 #define arch_atomic_set(v, i)	WRITE_ONCE((v)->counter, (i))
-
+#ifdef CONFIG_64BIT
 #define ATOMIC_OP(op, I, asm_op)					\
 static inline void arch_atomic_##op(int i, atomic_t *v)			\
 {									\
@@ -70,14 +70,81 @@ static inline int arch_atomic_fetch_##op##_relaxed(int i, atomic_t *v)	\
 									\
 	return result;							\
 }
+#endif
+
+#ifdef CONFIG_32BIT   /* CONFIG_32BIT */
+#define ATOMIC_OP(op, I, asm_op)                                        \
+static __inline__ void arch_atomic_##op(int i, atomic_t * v)                 \
+{                                                                       \
+        int temp ;                                              \
+        loongson_llsc_mb();                                     \
+        __asm__ __volatile__(                                   \
+        "1:     ll.w        %0, %1      #atomic_" #op "  \n"    \
+        "       " #asm_op " %0, %0, %2                   \n"    \
+        "       sc.w        %0, %1                       \n"    \
+        "       beq         %0, $r0, 1b                  \n"    \
+        :"=&r" (temp) , "+ZB"(v->counter)     \
+        :"r" (I)                                               \
+        );                                                      \
+}
+
+#define ATOMIC_OP_RETURN(op, I, asm_op)                                    \
+static __inline__ int arch_atomic_##op##_return_relaxed(int i, atomic_t * v)       \
+{                                                                             \
+        int result;                                                           \
+        int temp;                                                             \
+                                                                              \
+        loongson_llsc_mb();                                                   \
+        __asm__ __volatile__(                                                 \
+                "1:     ll.w    %1, %2          # atomic_" #op "_return \n"   \
+                "       " #asm_op " %0, %1, %3                          \n"   \
+                "       sc.w    %0, %2                                  \n"   \
+                "       beq    %0, $r0 ,1b                             \n"   \
+                "       " #asm_op " %0, %1, %3                          \n"   \
+                : "=&r" (result), "=&r" (temp),                               \
+                  "+ZB"(v->counter)                        \
+                : "r" (I));                                                  \
+        return result;                                                        \
+}
+
+#define ATOMIC_FETCH_OP(op,I, asm_op)                                     \
+static __inline__ int arch_atomic_fetch_##op##_relaxed(int i, atomic_t * v)        \
+{                                                                             \
+        int result;                                                           \
+        int temp;                                                     \
+                                                                      \
+        loongson_llsc_mb();                                           \
+        __asm__ __volatile__(                                         \
+        "1:     ll.w    %1, %2          # atomic_fetch_" #op "  \n"   \
+        "       " #asm_op " %0, %1, %3                          \n"   \
+        "       sc.w    %0, %2                                  \n"   \
+        "       beq     %0, $r0 ,1b                             \n"   \
+        "       add.w     %0, %1  ,$r0                            \n"   \
+        : "=&r" (result), "=&r" (temp),                               \
+        "+ZB" (v->counter)                          \
+        : "r" (I));                                                  \
+                                                                      \
+        return result;                                                \
+}
+#endif
 
+#ifdef CONFIG_64BIT
 #define ATOMIC_OPS(op, I, asm_op, c_op)					\
 	ATOMIC_OP(op, I, asm_op)					\
 	ATOMIC_OP_RETURN(op, I, asm_op, c_op)				\
 	ATOMIC_FETCH_OP(op, I, asm_op)
-
 ATOMIC_OPS(add, i, add, +)
 ATOMIC_OPS(sub, -i, add, +)
+#endif
+
+#ifdef CONFIG_32BIT
+#define ATOMIC_OPS(op,I ,asm_op, c_op)                                          \
+        ATOMIC_OP(op, I, asm_op)                                           \
+        ATOMIC_OP_RETURN(op, I , asm_op)                                    \
+        ATOMIC_FETCH_OP(op, I, asm_op)
+ATOMIC_OPS(add, i , add.w ,+=)
+ATOMIC_OPS(sub, -i , add.w ,+=)
+#endif
 
 #define arch_atomic_add_return_relaxed	arch_atomic_add_return_relaxed
 #define arch_atomic_sub_return_relaxed	arch_atomic_sub_return_relaxed
@@ -155,11 +222,8 @@ static inline int arch_atomic_sub_if_positive(int i, atomic_t *v)
  * @v: pointer of type atomic_t
  */
 #define arch_atomic_dec_if_positive(v)	arch_atomic_sub_if_positive(1, v)
-
 #ifdef CONFIG_64BIT
-
 #define ATOMIC64_INIT(i)    { (i) }
-
 /*
  * arch_atomic64_read - read atomic variable
  * @v: pointer of type atomic64_t
@@ -296,7 +360,5 @@ static inline long arch_atomic64_sub_if_positive(long i, atomic64_t *v)
  * @v: pointer of type atomic64_t
  */
 #define arch_atomic64_dec_if_positive(v)	arch_atomic64_sub_if_positive(1, v)
-
 #endif /* CONFIG_64BIT */
-
 #endif /* _ASM_ATOMIC_H */
diff --git a/arch/loongarch/include/asm/barrier.h b/arch/loongarch/include/asm/barrier.h
index 028f8a668c17..488d4a7a16d1 100644
--- a/arch/loongarch/include/asm/barrier.h
+++ b/arch/loongarch/include/asm/barrier.h
@@ -33,6 +33,16 @@
 #define __smp_mb__before_atomic()	barrier()
 #define __smp_mb__after_atomic()	__smp_mb()
 
+
+#ifdef CONFIG_CPU_LOONGSON3_WORKAROUNDS /* Loongson-3's LLSC workaround */
+#define loongson_llsc_mb()      __asm__ __volatile__(__WEAK_LLSC_MB : : :"memory")
+#else
+#define loongson_llsc_mb()      do { } while (0)
+#endif
+
+
+
+
 /**
  * array_index_mask_nospec() - generate a ~0 mask when index < size, 0 otherwise
  * @index: array element index
diff --git a/arch/loongarch/include/asm/bitops.h b/arch/loongarch/include/asm/bitops.h
index 7ab5664c3337..036e8fb8ab4e 100644
--- a/arch/loongarch/include/asm/bitops.h
+++ b/arch/loongarch/include/asm/bitops.h
@@ -23,6 +23,7 @@
 #define __AMAND_SYNC	"amand_db.w	"
 #define __AMOR_SYNC	"amor_db.w	"
 #define __AMXOR_SYNC	"amxor_db.w	"
+
 #elif _LOONGARCH_SZLONG == 64
 #define __LL		"ll.d	"
 #define __SC		"sc.d	"
@@ -42,18 +43,32 @@
  * Note that @nr may be almost arbitrarily large; this function is not
  * restricted to acting on a single-word quantity.
  */
+
 static inline void set_bit(unsigned long nr, volatile unsigned long *addr)
 {
+#ifdef CONFIG_32BIT
+	unsigned long temp;
+#endif
 	int bit = nr % BITS_PER_LONG;
 	volatile unsigned long *m = &addr[BIT_WORD(nr)];
 
+#ifdef CONFIG_64BIT
 	__asm__ __volatile__(
 	"   " __AMOR_SYNC "$zero, %1, %0        \n"
 	: "+ZB" (*m)
 	: "r" (1UL << bit)
 	: "memory");
+#else
+	loongson_llsc_mb();
+	__asm__ __volatile__(
+	"1:     " __LL "%0, %1                  \n"
+	"       or      %0, %0, %2                      \n"
+	"       " __SC  "%0, %1                 \n"
+	"       beq     %0, $r0, 1b             \n"
+	: "=&r" (temp), "=" GCC_OFF_SMALL_ASM() (*m)
+	: "r" (1UL << bit));
+#endif
 }
-
 /*
  * clear_bit - Clears a bit in memory
  * @nr: Bit to clear
@@ -66,14 +81,28 @@ static inline void set_bit(unsigned long nr, volatile unsigned long *addr)
  */
 static inline void clear_bit(unsigned long nr, volatile unsigned long *addr)
 {
+#ifdef CONFIG_32BIT
+	unsigned long temp;
+#endif
 	int bit = nr % BITS_PER_LONG;
 	volatile unsigned long *m = &addr[BIT_WORD(nr)];
 
+#ifdef CONFIG_64BIT
 	__asm__ __volatile__(
 	"   " __AMAND_SYNC "$zero, %1, %0       \n"
 	: "+ZB" (*m)
 	: "r" (~(1UL << bit))
 	: "memory");
+#else
+        loongson_llsc_mb();
+        __asm__ __volatile__(
+        "1:     " __LL "%0, %1                  \n"
+        "       and     %0, %0, %2                      \n"
+        "       " __SC  "%0, %1                 \n"
+        "       beq     %0, $r0, 1b             \n"
+        : "=&r" (temp), "=" GCC_OFF_SMALL_ASM() (*m)
+        : "r" (~(1UL << bit)));
+#endif
 }
 
 /*
@@ -100,16 +129,29 @@ static inline void clear_bit_unlock(unsigned long nr, volatile unsigned long *ad
  */
 static inline void change_bit(unsigned long nr, volatile unsigned long *addr)
 {
+#ifdef CONFIG_32BIT
+        unsigned long temp;
+#endif
 	int bit = nr % BITS_PER_LONG;
 	volatile unsigned long *m = &addr[BIT_WORD(nr)];
 
+#ifdef CONFIG_64BIT
 	__asm__ __volatile__(
 	"   " __AMXOR_SYNC "$zero, %1, %0       \n"
 	: "+ZB" (*m)
 	: "r" (1UL << bit)
 	: "memory");
+#else
+	loongson_llsc_mb();
+	__asm__ __volatile__(
+	"1:     "__LL "%0, %1           \n"
+	"       xor     %0, %0, %2      \n"
+	"       "__SC "%0, %1           \n"
+	"       beq     %0, $r0, 1b     \n"
+	: "=&r" (temp), "+" GCC_OFF_SMALL_ASM() (*m)
+	: "r" (1UL << bit));
+#endif
 }
-
 /*
  * test_and_set_bit - Set a bit and return its old value
  * @nr: Bit to set
@@ -121,10 +163,14 @@ static inline void change_bit(unsigned long nr, volatile unsigned long *addr)
 static inline int test_and_set_bit(unsigned long nr,
 	volatile unsigned long *addr)
 {
+#ifdef CONFIG_32BIT
+	unsigned long temp;
+#endif
 	int bit = nr % BITS_PER_LONG;
 	unsigned long res;
 	volatile unsigned long *m = &addr[BIT_WORD(nr)];
 
+#ifdef CONFIG_64BIT
 	__asm__ __volatile__(
 	"   " __AMOR_SYNC "%1, %2, %0       \n"
 	: "+ZB" (*m), "=&r" (res)
@@ -132,10 +178,20 @@ static inline int test_and_set_bit(unsigned long nr,
 	: "memory");
 
 	res = res & (1UL << bit);
+#else
+__asm__ __volatile__(
+	"1:     "__LL  "%0, %1          \n"
+	"       or      %2, %0, %3      \n"
+	"       "__SC   "%2, %1         \n"
+	"       beq     %2, $r0, 1b     \n"
+	: "=&r" (temp), "+" GCC_OFF_SMALL_ASM() (*m), "=&r" (res)
+	: "r" (1UL << bit)
+	: "memory");
+	res = temp & (1UL << bit);
+#endif
 
 	return res != 0;
 }
-
 /*
  * test_and_set_bit_lock - Set a bit and return its old value
  * @nr: Bit to set
@@ -147,10 +203,14 @@ static inline int test_and_set_bit(unsigned long nr,
 static inline int test_and_set_bit_lock(unsigned long nr,
 	volatile unsigned long *addr)
 {
+#ifdef CONFIG_32BIT
+	unsigned long temp;
+#endif
 	int bit = nr % BITS_PER_LONG;
 	unsigned long res;
 	volatile unsigned long *m = &addr[BIT_WORD(nr)];
 
+#ifdef CONFIG_64BIT
 	__asm__ __volatile__(
 	"   " __AMOR_SYNC "%1, %2, %0       \n"
 	: "+ZB" (*m), "=&r" (res)
@@ -158,7 +218,18 @@ static inline int test_and_set_bit_lock(unsigned long nr,
 	: "memory");
 
 	res = res & (1UL << bit);
-
+#else
+        __asm__ __volatile__(
+        "1:     " __LL "%0, %1                          \n"
+        "       or      %2, %0, %3                      \n"
+        "       " __SC  "%2, %1                         \n"
+        "       beq %2, $r0, 1b                         \n"
+        : "=&r" (temp), "+" GCC_OFF_SMALL_ASM() (*m), "=&r" (res)
+        : "r" (1UL << bit)
+        : "memory");
+
+        res = temp & (1UL << bit);
+#endif
 	return res != 0;
 }
 /*
@@ -176,17 +247,26 @@ static inline int test_and_clear_bit(unsigned long nr,
 	unsigned long res, temp;
 	volatile unsigned long *m = &addr[BIT_WORD(nr)];
 
+#ifdef CONFIG_64BIT
 	__asm__ __volatile__(
 	"   " __AMAND_SYNC "%1, %2, %0      \n"
 	: "+ZB" (*m), "=&r" (temp)
 	: "r" (~(1UL << bit))
 	: "memory");
-
-	res = temp & (1UL << bit);
-
+#else
+        __asm__ __volatile__(
+        "1:     " __LL  "%0, %1 # test_and_clear_bit    \n"
+        "       or      %2, %0, %3                      \n"
+        "       xor     %2, %2, %3                      \n"
+        "       " __SC  "%2, %1                         \n"
+        "       beq     %2, $r0, 1b                     \n"
+        : "=&r" (temp), "+" GCC_OFF_SMALL_ASM() (*m), "=&r" (res)
+        : "r" (1UL << bit)
+        : "memory");
+#endif
+        res = temp & (1UL << bit);
 	return res != 0;
 }
-
 /*
  * test_and_change_bit - Change a bit and return its old value
  * @nr: Bit to change
@@ -198,18 +278,30 @@ static inline int test_and_clear_bit(unsigned long nr,
 static inline int test_and_change_bit(unsigned long nr,
 	volatile unsigned long *addr)
 {
+#ifdef CONFIG_32BIT
+        unsigned long temp;
+#endif
 	int bit = nr % BITS_PER_LONG;
 	unsigned long res;
 	volatile unsigned long *m = &addr[BIT_WORD(nr)];
 
+#ifdef CONFIG_64BIT
 	__asm__ __volatile__(
 	"   " __AMXOR_SYNC "%1, %2, %0      \n"
 	: "+ZB" (*m), "=&r" (res)
 	: "r" (1UL << bit)
 	: "memory");
-
 	res = res & (1UL << bit);
-
+#else
+        __asm__ __volatile__(
+        "1:     " __LL  "%0, %1 # test_and_change_bit   \n"
+        "       xor     %2, %0, %3                      \n"
+        "       " __SC  "\t%2, %1                       \n"
+        "       beq     %2, $r0, 1b"
+        : "=&r" (temp), "+" GCC_OFF_SMALL_ASM() (*m), "=&r" (res)
+        : "r" (1UL << bit)
+        : "memory");
+#endif
 	return res != 0;
 }
 
@@ -229,15 +321,102 @@ static inline void __clear_bit_unlock(unsigned long nr, volatile unsigned long *
 	clear_bit(nr, addr);
 }
 
+#ifdef CONFIG_64BIT
 #include <asm-generic/bitops/builtin-ffs.h>
 #include <asm-generic/bitops/builtin-fls.h>
 #include <asm-generic/bitops/builtin-__ffs.h>
 #include <asm-generic/bitops/builtin-__fls.h>
+#endif
+
+#ifdef CONFIG_32BIT
+static inline int fls(int x)
+{
+        int r;
+
+        r = 32;
+        if (!x)
+                return 0;
+        if (!(x & 0xffff0000u)) {
+                x <<= 16;
+                r -= 16;
+        }
+        if (!(x & 0xff000000u)) {
+                x <<= 8;
+                r -= 8;
+        }
+        if (!(x & 0xf0000000u)) {
+                x <<= 4;
+                r -= 4;
+        }
+        if (!(x & 0xc0000000u)) {
+                x <<= 2;
+                r -= 2;
+        }
+        if (!(x & 0x80000000u)) {
+                x <<= 1;
+                r -= 1;
+        }
+        return r;
+}
+
+static inline int ffs(int word)
+{
+        if (!word)
+                return 0;
+
+        return fls(word & -word);
+}
+
+static inline unsigned long __fls(unsigned long word)
+{
+        int num;
+
+        if (BITS_PER_LONG == 64 && !__builtin_constant_p(word)) {
+                __asm__(
+                "       clz.d   %0, %1                          \n"
+                : "=r" (num)
+                : "r" (word));
+
+                return 63 - num;
+        }
+
+        num = BITS_PER_LONG - 1;
+#if BITS_PER_LONG == 64
+        if (!(word & (~0ul << 32))) {
+                num -= 32;
+                word <<= 32;
+        }
+#endif
+        if (!(word & (~0ul << (BITS_PER_LONG-16)))) {
+                num -= 16;
+                word <<= 16;
+        }
+        if (!(word & (~0ul << (BITS_PER_LONG-8)))) {
+                num -= 8;
+                word <<= 8;
+        }
+        if (!(word & (~0ul << (BITS_PER_LONG-4)))) {
+                num -= 4;
+                word <<= 4;
+        }
+        if (!(word & (~0ul << (BITS_PER_LONG-2)))) {
+                num -= 2;
+                word <<= 2;
+        }
+        if (!(word & (~0ul << (BITS_PER_LONG-1))))
+                num -= 1;
+        return num;
+}
+
+static inline unsigned long __ffs(unsigned long word)
+{
+        return __fls(word & -word);
+}
+#endif
 
 #include <asm-generic/bitops/ffz.h>
 #include <asm-generic/bitops/fls64.h>
 #include <asm-generic/bitops/find.h>
-
 #ifdef __KERNEL__
 
 #include <asm-generic/bitops/sched.h>
diff --git a/arch/loongarch/include/asm/bootinfo.h b/arch/loongarch/include/asm/bootinfo.h
index e358ea0e823c..dc358167cff1 100644
--- a/arch/loongarch/include/asm/bootinfo.h
+++ b/arch/loongarch/include/asm/bootinfo.h
@@ -9,14 +9,36 @@
 #include <asm/setup.h>
 
 const char *get_system_type(void);
+#define BOOT_MEM_MAP_MAX    64
+#define BOOT_MEM_RAM        1
+#define BOOT_MEM_ROM_DATA   2
+#define BOOT_MEM_RESERVED   3
+#define BOOT_MEM_INIT_RAM   4
+
+
+struct boot_mem_map {
+        int nr_map;
+        struct boot_mem_map_entry {
+                phys_addr_t addr;       /* start of memory segment */
+                phys_addr_t size;       /* size of memory segment */
+                long type;              /* type of memory segment */
+        } map[64];
+};
+
+extern struct boot_mem_map boot_mem_map;
+
+
 
 extern void early_memblock_init(void);
 extern void detect_memory_region(phys_addr_t start, phys_addr_t sz_min,  phys_addr_t sz_max);
-
 extern void early_init(void);
 extern void platform_init(void);
-extern void plat_swiotlb_setup(void);
 
+#ifdef CONFIG_SWIOTLB
+extern void plat_swiotlb_setup(void);
+#else
+static inline void plat_swiotlb_setup(void) {}
+#endif
 extern void free_init_pages(const char *what, unsigned long begin, unsigned long end);
 
 /*
diff --git a/arch/loongarch/include/asm/cmpxchg.h b/arch/loongarch/include/asm/cmpxchg.h
index cfd2e4f1e904..7fd30d6812c9 100644
--- a/arch/loongarch/include/asm/cmpxchg.h
+++ b/arch/loongarch/include/asm/cmpxchg.h
@@ -24,19 +24,38 @@ extern unsigned long __cmpxchg_called_with_bad_pointer(void)
 extern unsigned long __xchg_called_with_bad_pointer(void)
 	__compiletime_error("Bad argument size for xchg");
 
-#define __xchg_asm(amswap_db, m, val)		\
-({						\
-		__typeof(val) __ret;		\
-						\
-		__asm__ __volatile__ (		\
-		" "amswap_db" %1, %z2, %0 \n"	\
-		: "+ZB" (*m), "=&r" (__ret)	\
-		: "Jr" (val)			\
-		: "memory");			\
-						\
-		__ret;				\
+#ifdef CONFIG_64BIT
+#define __xchg_asm(amswap_db, m, val)	\
+({					\
+	__typeof(val) __ret;		\
+					\
+	__asm__ __volatile__ (		\
+	" "amswap_db" %1, %z2, %0 \n"	\
+	: "+ZB" (*m), "=&r" (__ret)	\
+	: "Jr" (val)			\
+	: "memory");			\
+					\
+	__ret;				\
 })
+#endif
 
+#ifdef CONFIG_32BIT
+#define __xchg_asm(ld, st, m, val)				\
+({								\
+	__typeof(val) __ret;					\
+                                                                \
+        __asm__ __volatile__(                                   \
+        "1:     " ld "  %0, %2          # __xchg_asm    \n"     \
+        "       or      $t2, $r0, %z3                   \n"     \
+        "       " st "  $t2, %1                         \n"     \
+        "       beq     $t2, $r0, 1b                    \n"     \
+        : "=&r" (__ret), "=" GCC_OFF_SMALL_ASM() (*m)           \
+        : GCC_OFF_SMALL_ASM() (*m), "Jr" (val)                  \
+        : "t2","memory");                                       \
+								\
+	__ret;							\
+})
+#endif
 extern unsigned long __xchg_small(volatile void *ptr, unsigned long val,
 				  unsigned int size);
 
@@ -47,22 +66,23 @@ static inline unsigned long __xchg(volatile void *ptr, unsigned long x,
 	case 1:
 	case 2:
 		return __xchg_small(ptr, x, size);
-
 	case 4:
+#ifdef CONFIG_64BIT
 		return __xchg_asm("amswap_db.w", (volatile u32 *)ptr, (u32)x);
-
+#endif
+#ifdef CONFIG_32BIT
+                return __xchg_asm("ll.w", "sc.w", (volatile u32 *)ptr, x);
+#endif
 	case 8:
-		if (!IS_ENABLED(CONFIG_64BIT))
-			return __xchg_called_with_bad_pointer();
-
-		return __xchg_asm("amswap_db.d", (volatile u64 *)ptr, (u64)x);
-
+#ifdef CONFIG_64BIT
+		return __xchg_asm("amswap_db.w", (volatile u32 *)ptr, (u32)x);
+#endif
 	default:
 		return __xchg_called_with_bad_pointer();
 	}
 }
 
-#define arch_xchg(ptr, x)							\
+#define arch_xchg(ptr, x)						\
 ({									\
 	__typeof__(*(ptr)) __res;					\
 									\
@@ -101,36 +121,37 @@ static inline unsigned long __cmpxchg(volatile void *ptr, unsigned long old,
 	case 1:
 	case 2:
 		return __cmpxchg_small(ptr, old, new, size);
-
 	case 4:
-		return __cmpxchg_asm("ll.w", "sc.w", (volatile u32 *)ptr,
-				     (u32)old, new);
-
+#ifdef CONFIG_64BIT
+                return __cmpxchg_asm("ll.w", "sc.w", (volatile u32 *)ptr,
+                                     (u32)old, new);
+#endif
+#ifdef CONFIG_32BIT
+                return __cmpxchg_asm("ll.w", "sc.w", (volatile u32 *)ptr,
+                                        (u32)old, new);
+#endif
 	case 8:
-		/* lld/scd are only available for LoongArch64 */
-		if (!IS_ENABLED(CONFIG_64BIT))
-			return __cmpxchg_called_with_bad_pointer();
-
+#if defined(CONFIG_64BIT)
 		return __cmpxchg_asm("ll.d", "sc.d", (volatile u64 *)ptr,
 				     (u64)old, new);
-
+#endif
 	default:
 		return __cmpxchg_called_with_bad_pointer();
 	}
 }
 
-#define arch_cmpxchg_local(ptr, old, new)					\
+#define arch_cmpxchg_local(ptr, old, new)				\
 	((__typeof__(*(ptr)))						\
 		__cmpxchg((ptr),					\
 			  (unsigned long)(__typeof__(*(ptr)))(old),	\
 			  (unsigned long)(__typeof__(*(ptr)))(new),	\
 			  sizeof(*(ptr))))
 
-#define arch_cmpxchg(ptr, old, new)						\
+#define arch_cmpxchg(ptr, old, new)					\
 ({									\
 	__typeof__(*(ptr)) __res;					\
 									\
-	__res = arch_cmpxchg_local((ptr), (old), (new));			\
+	__res = arch_cmpxchg_local((ptr), (old), (new));		\
 									\
 	__res;								\
 })
@@ -139,18 +160,20 @@ static inline unsigned long __cmpxchg(volatile void *ptr, unsigned long old,
 #define arch_cmpxchg64_local(ptr, o, n)					\
   ({									\
 	BUILD_BUG_ON(sizeof(*(ptr)) != 8);				\
-	arch_cmpxchg_local((ptr), (o), (n));					\
+	arch_cmpxchg_local((ptr), (o), (n));				\
   })
-
-#define arch_cmpxchg64(ptr, o, n)						\
+#define arch_cmpxchg64(ptr, o, n)					\
   ({									\
 	BUILD_BUG_ON(sizeof(*(ptr)) != 8);				\
 	arch_cmpxchg((ptr), (o), (n));					\
   })
-#else
+#endif
+
+#ifdef CONFIG_32BIT
 #include <asm-generic/cmpxchg-local.h>
 #define arch_cmpxchg64_local(ptr, o, n) __generic_cmpxchg64_local((ptr), (o), (n))
+#ifndef CONFIG_SMP
 #define arch_cmpxchg64(ptr, o, n) arch_cmpxchg64_local((ptr), (o), (n))
 #endif
-
+#endif
 #endif /* __ASM_CMPXCHG_H */
diff --git a/arch/loongarch/include/asm/cpu-features.h b/arch/loongarch/include/asm/cpu-features.h
index 2d307f30e3c5..9c2ca51e60ba 100644
--- a/arch/loongarch/include/asm/cpu-features.h
+++ b/arch/loongarch/include/asm/cpu-features.h
@@ -19,9 +19,7 @@
 #define cpu_dcache_line_size()		cpu_data[0].dcache.linesz
 #define cpu_vcache_line_size()		cpu_data[0].vcache.linesz
 #define cpu_scache_line_size()		cpu_data[0].scache.linesz
-
 #ifdef CONFIG_32BIT
-# define cpu_has_64bits			(cpu_data[0].isa_level & LOONGARCH_CPU_ISA_64BIT)
 # define cpu_vabits			31
 # define cpu_pabits			31
 #endif
diff --git a/arch/loongarch/include/asm/elf.h b/arch/loongarch/include/asm/elf.h
index 9f8c2ab1a206..88e9c8f25cc5 100644
--- a/arch/loongarch/include/asm/elf.h
+++ b/arch/loongarch/include/asm/elf.h
@@ -108,9 +108,8 @@ typedef elf_greg_t elf_gregset_t[ELF_NGREG];
 
 typedef double elf_fpreg_t;
 typedef elf_fpreg_t elf_fpregset_t[ELF_NFPREG];
-
 void loongarch_dump_regs64(u64 *uregs, const struct pt_regs *regs);
-
+void loongarch_dump_regs32(u32 *uregs, const struct pt_regs *regs);
 #ifdef CONFIG_32BIT
 /*
  * This is used to ensure we don't load something for the wrong architecture.
diff --git a/arch/loongarch/include/asm/futex.h b/arch/loongarch/include/asm/futex.h
index 22ddd3f7114b..ad3cb638ae7f 100644
--- a/arch/loongarch/include/asm/futex.h
+++ b/arch/loongarch/include/asm/futex.h
@@ -69,6 +69,7 @@ arch_futex_atomic_op_inuser(int op, int oparg, int *oval, u32 __user *uaddr)
 	return ret;
 }
 
+#ifdef CONFIG_64BIT
 static inline int
 futex_atomic_cmpxchg_inatomic(u32 *uval, u32 __user *uaddr, u32 oldval, u32 newval)
 {
@@ -101,8 +102,44 @@ futex_atomic_cmpxchg_inatomic(u32 *uval, u32 __user *uaddr, u32 oldval, u32 newv
 	: "memory", "t0");
 
 	*uval = val;
-
 	return ret;
 }
+#endif
+
+#ifdef CONFIG_32BIT
+static inline int
+futex_atomic_cmpxchg_inatomic(u32 *uval, u32 __user *uaddr, u32 oldval, u32 newval)
+{
+	int ret = 0;
+	u32 val = 0;
+
+	if (!access_ok(uaddr, sizeof(u32)))
+		return -EFAULT;
+
+	__asm__ __volatile__(
+	"# futex_atomic_cmpxchg_inatomic			\n"
+	"1:	ll.w	%1, %3					\n"
+	"	bne	%1, %z4, 3f				\n"
+	"	or	$t0, %z5, $zero				\n"
+	"2:	sc.w	$t0, %2					\n"
+	"	beq	$zero, $t0, 1b				\n"
+	"3:							\n"
+	__WEAK_LLSC_MB
+	"	.section .fixup,\"ax\"				\n"
+	"4:	li.w	 %0, %6					\n"
+	"	b	3b					\n"
+	"	.previous					\n"
+	"	.section __ex_table,\"a\"			\n"
+	"	"__UA_ADDR "\t1b, 4b				\n"
+	"	"__UA_ADDR "\t2b, 4b				\n"
+	"	.previous					\n"
+	: "+r" (ret), "=&r" (val), "=" GCC_OFF_SMALL_ASM() (*uaddr)
+	: GCC_OFF_SMALL_ASM() (*uaddr), "Jr" (oldval), "Jr" (newval),
+	  "i" (-EFAULT)
+	: "memory", "t0");
 
+	*uval = val;
+	return ret;
+}
+#endif
 #endif /* _ASM_FUTEX_H */
diff --git a/arch/loongarch/include/asm/hardirq.h b/arch/loongarch/include/asm/hardirq.h
index d50298147a02..a8b136701742 100644
--- a/arch/loongarch/include/asm/hardirq.h
+++ b/arch/loongarch/include/asm/hardirq.h
@@ -18,9 +18,8 @@ typedef struct {
 	unsigned int ipi_irqs[NR_IPI];
 	unsigned int __softirq_pending;
 } ____cacheline_aligned irq_cpustat_t;
-
 DECLARE_PER_CPU_ALIGNED(irq_cpustat_t, irq_stat);
-
+#ifdef CONFIG_64BIT
 #define __ARCH_IRQ_STAT
-
+#endif
 #endif /* _ASM_HARDIRQ_H */
diff --git a/arch/loongarch/include/asm/inst.h b/arch/loongarch/include/asm/inst.h
index c8e6ff3508c3..3f29bf8782e1 100644
--- a/arch/loongarch/include/asm/inst.h
+++ b/arch/loongarch/include/asm/inst.h
@@ -70,180 +70,4 @@ typedef unsigned int loongarch_instruction;
 
 /* Recode table from 16-bit register notation to 32-bit GPR. Do NOT export!!! */
 extern const int reg16to32[];
-
-#define STR(x)	__STR(x)
-#define __STR(x)  #x
-
-#define _LoadHW(addr, value, res)  \
-do {                                               \
-	__asm__ __volatile__ (                      \
-		"1:\tld.b\t%0, %2, 1\n"             \
-		"2:\tld.bu\t$r19, %2, 0\n\t"        \
-		"slli.w\t%0, %0, 0x8\n\t"           \
-		"or\t%0, %0, $r19\n\t"              \
-		"li.w\t%1, 0\n"                     \
-		"3:\n\t"                            \
-		".section\t.fixup,\"ax\"\n\t"       \
-		"4:\tli.w\t%1, %3\n\t"              \
-		"b\t3b\n\t"                         \
-		".previous\n\t"                     \
-		".section\t__ex_table,\"a\"\n\t"    \
-		STR(PTR)"\t1b, 4b\n\t"              \
-		STR(PTR)"\t2b, 4b\n\t"              \
-		".previous"                         \
-		: "=&r" (value), "=r" (res)         \
-		: "r" (addr), "i" (-EFAULT)         \
-		: "$r19");                          \
-} while (0)
-
-#define _LoadW(addr, value, res)   \
-do {                                               \
-	__asm__ __volatile__ (                      \
-		"1:\tldl.w\t%0, %2, 3\n"            \
-		"2:\tldr.w\t%0, %2, 0\n\t"          \
-		"li.w\t%1, 0\n"                     \
-		"3:\n\t"                            \
-		".section\t.fixup,\"ax\"\n\t"       \
-		"4:\tli.w\t%1, %3\n\t"              \
-		"b\t3b\n\t"                         \
-		".previous\n\t"                     \
-		".section\t__ex_table,\"a\"\n\t"    \
-		STR(PTR)"\t1b, 4b\n\t"              \
-		STR(PTR)"\t2b, 4b\n\t"              \
-		".previous"                         \
-		: "=&r" (value), "=r" (res)         \
-		: "r" (addr), "i" (-EFAULT));       \
-} while (0)
-
-#define _LoadHWU(addr, value, res) \
-do {                                               \
-	__asm__ __volatile__ (                      \
-		"1:\tld.bu\t%0, %2, 1\n"            \
-		"2:\tld.bu\t$r19, %2, 0\n\t"        \
-		"slli.w\t%0, %0, 0x8\n\t"           \
-		"or\t%0, %0, $r19\n\t"              \
-		"li.w\t%1, 0\n"                     \
-		"3:\n\t"                            \
-		".section\t.fixup,\"ax\"\n\t"       \
-		"4:\tli.w\t%1, %3\n\t"              \
-		"b\t3b\n\t"                         \
-		".previous\n\t"                     \
-		".section\t__ex_table,\"a\"\n\t"    \
-		STR(PTR)"\t1b, 4b\n\t"              \
-		STR(PTR)"\t2b, 4b\n\t"              \
-		".previous"                         \
-		: "=&r" (value), "=r" (res)         \
-		: "r" (addr), "i" (-EFAULT)         \
-		: "$r19");                          \
-} while (0)
-
-#define _LoadWU(addr, value, res)  \
-do {                                               \
-	__asm__ __volatile__ (                      \
-		"1:\tldl.w\t%0, %2, 3\n"            \
-		"2:\tldr.w\t%0, %2, 0\n\t"          \
-		"slli.d\t%0, %0, 32\n\t"            \
-		"srli.d\t%0, %0, 32\n\t"            \
-		"li.w\t%1, 0\n"                     \
-		"3:\n\t"                            \
-		"\t.section\t.fixup,\"ax\"\n\t"     \
-		"4:\tli.w\t%1, %3\n\t"              \
-		"b\t3b\n\t"                         \
-		".previous\n\t"                     \
-		".section\t__ex_table,\"a\"\n\t"    \
-		STR(PTR)"\t1b, 4b\n\t"              \
-		STR(PTR)"\t2b, 4b\n\t"              \
-		".previous"                         \
-		: "=&r" (value), "=r" (res)         \
-		: "r" (addr), "i" (-EFAULT));       \
-} while (0)
-
-#define _LoadDW(addr, value, res)  \
-do {                                               \
-	__asm__ __volatile__ (                      \
-		"1:\tldl.d\t%0, %2, 7\n"            \
-		"2:\tldr.d\t%0, %2, 0\n\t"          \
-		"li.w\t%1, 0\n"                     \
-		"3:\n\t"                            \
-		"\t.section\t.fixup,\"ax\"\n\t"     \
-		"4:\tli.w\t%1, %3\n\t"              \
-		"b\t3b\n\t"                         \
-		".previous\n\t"                     \
-		".section\t__ex_table,\"a\"\n\t"    \
-		STR(PTR)"\t1b, 4b\n\t"              \
-		STR(PTR)"\t2b, 4b\n\t"              \
-		".previous"                         \
-		: "=&r" (value), "=r" (res)         \
-		: "r" (addr), "i" (-EFAULT));       \
-} while (0)
-
-#define _StoreHW(addr, value, res) \
-do {                                               \
-	__asm__ __volatile__ (                      \
-		"1:\tst.b\t%1, %2, 0\n"             \
-		"srli.w\t$r19,%1, 0x8\n"            \
-		"2:\tst.b\t$r19, %2, 1\n"           \
-		"li.w\t%0, 0\n"                     \
-		"3:\n\t"                            \
-		".section\t.fixup,\"ax\"\n\t"       \
-		"4:\tli.w\t%0, %3\n\t"              \
-		"b\t3b\n\t"                         \
-		".previous\n\t"                     \
-		".section\t__ex_table,\"a\"\n\t"    \
-		STR(PTR)"\t1b, 4b\n\t"              \
-		STR(PTR)"\t2b, 4b\n\t"              \
-		".previous"                         \
-		: "=r" (res)                        \
-		: "r" (value), "r" (addr), "i" (-EFAULT)  \
-		: "$r19");                          \
-} while (0)
-
-#define _StoreW(addr, value, res)  \
-do {                                               \
-	__asm__ __volatile__ (                      \
-		"1:\tstl.w\t%1, %2, 3\n"            \
-		"2:\tstr.w\t%1, %2, 0\n\t"          \
-		"li.w\t%0, 0\n"                     \
-		"3:\n\t"                            \
-		".section\t.fixup,\"ax\"\n\t"       \
-		"4:\tli.w\t%0, %3\n\t"              \
-		"b\t3b\n\t"                         \
-		".previous\n\t"                     \
-		".section\t__ex_table,\"a\"\n\t"    \
-		STR(PTR)"\t1b, 4b\n\t"              \
-		STR(PTR)"\t2b, 4b\n\t"              \
-		".previous"                         \
-		: "=r" (res)                                \
-		: "r" (value), "r" (addr), "i" (-EFAULT));  \
-} while (0)
-
-#define _StoreDW(addr, value, res) \
-do {                                               \
-	__asm__ __volatile__ (                      \
-		"1:\tstl.d\t%1, %2, 7\n"            \
-		"2:\tstr.d\t%1, %2, 0\n\t"          \
-		"li.w\t%0, 0\n"                     \
-		"3:\n\t"                            \
-		".section\t.fixup,\"ax\"\n\t"       \
-		"4:\tli.w\t%0, %3\n\t"              \
-		"b\t3b\n\t"                         \
-		".previous\n\t"                     \
-		".section\t__ex_table,\"a\"\n\t"    \
-		STR(PTR)"\t1b, 4b\n\t"              \
-		STR(PTR)"\t2b, 4b\n\t"              \
-		".previous"                         \
-		: "=r" (res)                                \
-		: "r" (value), "r" (addr), "i" (-EFAULT));  \
-} while (0)
-
-#define LoadHWU(addr, value, res)	_LoadHWU(addr, value, res)
-#define LoadWU(addr, value, res)	_LoadWU(addr, value, res)
-#define LoadHW(addr, value, res)	_LoadHW(addr, value, res)
-#define LoadW(addr, value, res)		_LoadW(addr, value, res)
-#define LoadDW(addr, value, res)	_LoadDW(addr, value, res)
-
-#define StoreHW(addr, value, res)	_StoreHW(addr, value, res)
-#define StoreW(addr, value, res)	_StoreW(addr, value, res)
-#define StoreDW(addr, value, res)	_StoreDW(addr, value, res)
-
 #endif /* _ASM_INST_H */
diff --git a/arch/loongarch/include/asm/io.h b/arch/loongarch/include/asm/io.h
index 3dfe24050b40..13b2135ac444 100644
--- a/arch/loongarch/include/asm/io.h
+++ b/arch/loongarch/include/asm/io.h
@@ -52,10 +52,12 @@ static inline void set_io_port_base(unsigned long base)
  * Change "struct page" to physical address.
  */
 #define page_to_phys(page)	((dma_addr_t)page_to_pfn(page) << PAGE_SHIFT)
-
+#ifdef CONFIG_64BIT
 extern void __init __iomem *early_ioremap(u64 phys_addr, unsigned long size);
+#else
+extern void __init __iomem *early_ioremap(u32 phys_addr, unsigned long size);
+#endif
 extern void __init early_iounmap(void __iomem *addr, unsigned long size);
-
 #define early_memremap early_ioremap
 #define early_memunmap early_iounmap
 
@@ -128,13 +130,14 @@ static inline void iounmap(const volatile void __iomem *addr)
 /*
  * String version of I/O memory access operations.
  */
+#ifdef CONFIG_64BIT
 extern void __memset_io(volatile void __iomem *dst, int c, size_t count);
 extern void __memcpy_toio(volatile void __iomem *to, const void *from, size_t count);
 extern void __memcpy_fromio(void *to, const volatile void __iomem *from, size_t count);
 #define memset_io(c, v, l)     __memset_io((c), (v), (l))
 #define memcpy_fromio(a, c, l) __memcpy_fromio((a), (c), (l))
 #define memcpy_toio(c, a, l)   __memcpy_toio((c), (a), (l))
-
+#endif
 #define PCI_IOBASE ((void __iomem *)PIO_OFFSET)
 
 #include <asm-generic/io.h>
diff --git a/arch/loongarch/include/asm/irqflags.h b/arch/loongarch/include/asm/irqflags.h
index 7364fb66f217..c9ba501931d0 100644
--- a/arch/loongarch/include/asm/irqflags.h
+++ b/arch/loongarch/include/asm/irqflags.h
@@ -46,7 +46,23 @@ static inline int arch_irqs_disabled(void)
 {
 	return arch_irqs_disabled_flags(arch_local_save_flags());
 }
-
 #endif /* #ifndef __ASSEMBLY__ */
+#ifdef CONFIG_TRACE_IRQFLAGS
+# define TRACE_IRQS_ON                                                  \
+        CLI;    /* make sure trace_hardirqs_on() is called in kernel level */ \
+        jal     trace_hardirqs_on
+# define TRACE_IRQS_ON_RELOAD                                           \
+        TRACE_IRQS_ON;                                                  \
+        TRACE_IRQS_RELOAD_REGS
+# define TRACE_IRQS_OFF                                                 \
+        bl     trace_hardirqs_off
+#else
+# define TRACE_IRQS_ON
+# define TRACE_IRQS_ON_RELOAD
+# define TRACE_IRQS_OFF
+#endif
+
+
+
 
 #endif /* _ASM_IRQFLAGS_H */
diff --git a/arch/loongarch/include/asm/local.h b/arch/loongarch/include/asm/local.h
index 1d6faaf04c08..0d2934e8889a 100644
--- a/arch/loongarch/include/asm/local.h
+++ b/arch/loongarch/include/asm/local.h
@@ -25,6 +25,8 @@ typedef struct {
 #define local_inc(l)	atomic_long_inc(&(l)->a)
 #define local_dec(l)	atomic_long_dec(&(l)->a)
 
+#if defined(CONFIG_64BIT)
+
 /*
  * Same as above, but return the result value
  */
@@ -56,6 +58,48 @@ static inline long local_sub_return(long i, local_t *l)
 
 	return result;
 }
+#elif defined(CONFIG_32BIT)
+
+/*
+ * Same as above, but return the result value
+ */
+static __inline__ long local_add_return(long i, local_t * l)
+{
+        unsigned long temp;
+        unsigned long result;
+
+        __asm__ __volatile__(
+        "1:"    __LL    "%1, %2         # local_add_return      \n"
+        "       add.w   %0, %1, %3                              \n"
+                __SC    "%0, %2                                 \n"
+        "       beq     %0, $r0, 1b                             \n"
+        "       add.w   %0, %1, %3                              \n"
+        : "=&r" (result), "=&r" (temp), "=m" (l->a.counter)
+        : "r" (i), "m" (l->a.counter)
+        : "memory");
+
+        return result;
+}
+
+static __inline__ long local_sub_return(long i, local_t * l)
+{
+        unsigned long result;
+        unsigned long temp;
+
+        __asm__ __volatile__(
+        "1:"    __LL    "%1, %2         # local_sub_return      \n"
+        "       sub.w   %0, %1, %3                              \n"
+                __SC    "%0, %2                                 \n"
+        "       beq     %0, $r0, 1b                             \n"
+        "       sub.w   %0, %1, %3                              \n"
+        : "=&r" (result), "=&r" (temp), "=m" (l->a.counter)
+        : "r" (i), "m" (l->a.counter)
+        : "memory");
+
+        return result;
+}
+#endif
+
 
 #define local_cmpxchg(l, o, n) \
 	((long)cmpxchg_local(&((l)->a.counter), (o), (n)))
diff --git a/arch/loongarch/include/asm/loongarchregs.h b/arch/loongarch/include/asm/loongarchregs.h
index 23982c49a320..efa8919f17e9 100644
--- a/arch/loongarch/include/asm/loongarchregs.h
+++ b/arch/loongarch/include/asm/loongarchregs.h
@@ -48,19 +48,97 @@ __asm__(".macro	parse_r var r\n\t"
 	_IFC_REG(20) _IFC_REG(21) _IFC_REG(22) _IFC_REG(23)
 	_IFC_REG(24) _IFC_REG(25) _IFC_REG(26) _IFC_REG(27)
 	_IFC_REG(28) _IFC_REG(29) _IFC_REG(30) _IFC_REG(31)
+	".ifc	\\r, $a0 \n\t"
+	"\\var	= 4	\n\t"
+	".endif\n\t"
+	".ifc	\\r, $a1 \n\t"
+	"\\var	= 5	\n\t"
+	".endif\n\t"
+	".ifc	\\r, $a2 \n\t"
+	"\\var	= 6	\n\t"
+	".endif\n\t"
+	".ifc	\\r, $a3 \n\t"
+	"\\var	= 7	\n\t"
+	".endif\n\t"
+	".ifc	\\r, $a4 \n\t"
+	"\\var	= 8	\n\t"
+	".endif\n\t"
+	".ifc	\\r, $a5 \n\t"
+	"\\var	= 9	\n\t"
+	".endif\n\t"
+	".ifc	\\r, $a6 \n\t"
+	"\\var	= 10	\n\t"
+	".endif\n\t"
+	".ifc	\\r, $a7 \n\t"
+	"\\var	= 11	\n\t"
+	".endif\n\t"
+	".ifc	\\r, $t0 \n\t"
+	"\\var	= 12	\n\t"
+	".endif\n\t"
+	".ifc	\\r, $t1 \n\t"
+	"\\var	= 13	\n\t"
+	".endif\n\t"
+	".ifc	\\r, $t2 \n\t"
+	"\\var	= 14	\n\t"
+	".endif\n\t"
+	".ifc	\\r, $t3 \n\t"
+	"\\var	= 15	\n\t"
+	".endif\n\t"
+	".ifc	\\r, $t4 \n\t"
+	"\\var	= 16	\n\t"
+	".endif\n\t"
+	".ifc	\\r, $t5 \n\t"
+	"\\var	= 17	\n\t"
+	".endif\n\t"
+	".ifc	\\r, $t6 \n\t"
+	"\\var	= 18	\n\t"
+	".endif\n\t"
+	".ifc	\\r, $t7 \n\t"
+	"\\var	= 19	\n\t"
+	".endif\n\t"
+	".ifc	\\r, $t8 \n\t"
+	"\\var	= 20	\n\t"
+	".endif\n\t"
+	".ifc	\\r, $s0 \n\t"
+	"\\var	= 23	\n\t"
+	".endif\n\t"
+	".ifc	\\r, $s1 \n\t"
+	"\\var	= 24	\n\t"
+	".endif\n\t"
+	".ifc	\\r, $s2 \n\t"
+	"\\var	= 25	\n\t"
+	".endif\n\t"
+	".ifc	\\r, $s3 \n\t"
+	"\\var	= 26	\n\t"
+	".endif\n\t"
+	".ifc	\\r, $s4 \n\t"
+	"\\var	= 27	\n\t"
+	".endif\n\t"
+	".ifc	\\r, $s5 \n\t"
+	"\\var	= 28	\n\t"
+	".endif\n\t"
+	".ifc	\\r, $s6 \n\t"
+	"\\var	= 29	\n\t"
+	".endif\n\t"
+	".ifc	\\r, $s7 \n\t"
+	"\\var	= 30	\n\t"
+	".endif\n\t"
+	".ifc	\\r, $s8 \n\t"
+	"\\var	= 31	\n\t"
+	".endif\n\t"
 	".iflt	\\var\n\t"
 	".error	\"Unable to parse register name \\r\"\n\t"
 	".endif\n\t"
 	".endm");
 
 #undef _IFC_REG
-
+#ifdef CONFIG_64BIT
 /* CPUCFG */
 static inline u32 read_cpucfg(u32 reg)
 {
 	return __cpucfg(reg);
 }
-
+#endif
 #endif /* !__ASSEMBLY__ */
 
 /* LoongArch Registers */
@@ -223,6 +301,7 @@ static inline u32 read_cpucfg(u32 reg)
 
 #ifndef __ASSEMBLY__
 
+#if defined(CONFIG_64BIT)
 /* CSR */
 static inline u32 csr_readl(u32 reg)
 {
@@ -253,6 +332,39 @@ static inline u64 csr_xchgq(u64 val, u64 mask, u32 reg)
 {
 	return __dcsrxchg(val, mask, reg);
 }
+#endif
+
+#ifdef CONFIG_32BIT
+static inline u32 csr_readl(u32 reg)
+{
+	return __csrrd(reg);
+}
+
+static inline u64 csr_readq(u32 reg)
+{
+	return __csrrd(reg);
+}
+
+static inline void csr_writel(u32 val, u32 reg)
+{
+	__csrwr(val, reg);
+}
+
+static inline void csr_writeq(u64 val, u32 reg)
+{
+	__csrwr(val, reg);
+}
+
+static inline u32 csr_xchgl(u32 val, u32 mask, u32 reg)
+{
+	return __csrxchg(val, mask, reg);
+}
+
+static inline u64 csr_xchgq(u64 val, u64 mask, u32 reg)
+{
+	return __csrxchg(val, mask, reg);
+}
+#endif
 
 /* IOCSR */
 static inline u32 iocsr_readl(u32 reg)
@@ -262,7 +374,7 @@ static inline u32 iocsr_readl(u32 reg)
 
 static inline u64 iocsr_readq(u32 reg)
 {
-	return __iocsrrd_d(reg);
+	return __iocsrrd_w(reg);
 }
 
 static inline void iocsr_writel(u32 val, u32 reg)
@@ -272,7 +384,7 @@ static inline void iocsr_writel(u32 val, u32 reg)
 
 static inline void iocsr_writeq(u64 val, u32 reg)
 {
-	__iocsrwr_d(val, reg);
+	__iocsrwr_w(val, reg);
 }
 
 #endif /* !__ASSEMBLY__ */
@@ -949,6 +1061,7 @@ static inline void iocsr_writeq(u64 val, u32 reg)
 #define LOONGARCH_CSR_DMWIN3		0x183	/* 64 direct map win3: MEM */
 
 /* Direct Map window 0/1 */
+#ifdef CONFIG_64BIT
 #define CSR_DMW0_PLV0		_CONST64_(1 << 0)
 #define CSR_DMW0_VSEG		_CONST64_(0x8000)
 #define CSR_DMW0_BASE		(CSR_DMW0_VSEG << DMW_PABITS)
@@ -960,6 +1073,19 @@ static inline void iocsr_writeq(u64 val, u32 reg)
 #define CSR_DMW1_BASE		(CSR_DMW1_VSEG << DMW_PABITS)
 #define CSR_DMW1_INIT		(CSR_DMW1_BASE | CSR_DMW1_MAT | CSR_DMW1_PLV0)
 
+#else
+#define CSR_DMW0_PLV0		_ULCAST_(1 << 0)
+#define CSR_DMW0_VSEG		_ULCAST_(0x8)
+#define CSR_DMW0_BASE		(CSR_DMW0_VSEG << DMW_PABITS)
+#define CSR_DMW0_INIT		(CSR_DMW0_BASE | CSR_DMW0_PLV0)
+
+#define CSR_DMW1_PLV0		_ULCAST_(1 << 0)
+#define CSR_DMW1_MAT		_ULCAST_(1 << 4)
+#define CSR_DMW1_VSEG		_ULCAST_(0xa)
+#define CSR_DMW1_BASE		(CSR_DMW1_VSEG << DMW_PABITS)
+#define CSR_DMW1_INIT		(CSR_DMW1_BASE | CSR_DMW1_MAT | CSR_DMW1_PLV0)
+#endif
+
 /* Performance Counter registers */
 #define LOONGARCH_CSR_PERFCTRL0		0x200	/* 32 perf event 0 config */
 #define LOONGARCH_CSR_PERFCNTR0		0x201	/* 64 perf event 0 count value */
@@ -1174,7 +1300,7 @@ static inline void iocsr_writeq(u64 val, u32 reg)
 #define IOCSR_EXTIOI_VECTOR_NUM			256
 
 #ifndef __ASSEMBLY__
-
+#ifdef CONFIG_64BIT
 static inline u64 drdtime(void)
 {
 	int rID = 0;
@@ -1187,6 +1313,26 @@ static inline u64 drdtime(void)
 		);
 	return val;
 }
+#endif
+
+#ifdef CONFIG_32BIT
+static inline u64 drdtime(void)
+{
+        u32 val_l = 0;
+        u32 val_h = 0;
+        u64 ullTimeVal = 0;
+
+        __asm__ __volatile__(
+                "rdcntvl.w %0 \n\t"
+                "rdcntvh.w %1 \n\t"
+                :"=r"(val_l),"=r"(val_h)
+                :
+                );
+        ullTimeVal = (val_h & -1ULL) << 32 | val_l;
+
+        return ullTimeVal;
+}
+#endif
 
 static inline unsigned int get_csr_cpuid(void)
 {
@@ -1202,7 +1348,7 @@ static inline void csr_any_send(unsigned int addr, unsigned int data,
 	val |= (node << IOCSR_ANY_SEND_NODE_SHIFT);
 	val |= (data_mask << IOCSR_ANY_SEND_MASK_SHIFT);
 	val |= ((uint64_t)data << IOCSR_ANY_SEND_BUF_SHIFT);
-	__iocsrwr_d(val, LOONGARCH_IOCSR_ANY_SEND);
+	__iocsrwr_w(val, LOONGARCH_IOCSR_ANY_SEND);
 }
 
 static inline unsigned int read_csr_excode(void)
@@ -1227,12 +1373,7 @@ static inline void write_csr_pagesize(unsigned int size)
 
 #define read_csr_asid()			__csrrd(LOONGARCH_CSR_ASID)
 #define write_csr_asid(val)		__csrwr(val, LOONGARCH_CSR_ASID)
-#define read_csr_entryhi()		__dcsrrd(LOONGARCH_CSR_TLBEHI)
-#define write_csr_entryhi(val)		__dcsrwr(val, LOONGARCH_CSR_TLBEHI)
-#define read_csr_entrylo0()		__dcsrrd(LOONGARCH_CSR_TLBELO0)
-#define write_csr_entrylo0(val)		__dcsrwr(val, LOONGARCH_CSR_TLBELO0)
-#define read_csr_entrylo1()		__dcsrrd(LOONGARCH_CSR_TLBELO1)
-#define write_csr_entrylo1(val)		__dcsrwr(val, LOONGARCH_CSR_TLBELO1)
+
 #define read_csr_ecfg()			__csrrd(LOONGARCH_CSR_ECFG)
 #define write_csr_ecfg(val)		__csrwr(val, LOONGARCH_CSR_ECFG)
 #define read_csr_estat()		__csrrd(LOONGARCH_CSR_ESTAT)
@@ -1242,13 +1383,20 @@ static inline void write_csr_pagesize(unsigned int size)
 #define read_csr_euen()			__csrrd(LOONGARCH_CSR_EUEN)
 #define write_csr_euen(val)		__csrwr(val, LOONGARCH_CSR_EUEN)
 #define read_csr_cpuid()		__csrrd(LOONGARCH_CSR_CPUID)
-#define read_csr_prcfg1()		__dcsrrd(LOONGARCH_CSR_PRCFG1)
-#define write_csr_prcfg1(val)		__dcsrwr(val, LOONGARCH_CSR_PRCFG1)
-#define read_csr_prcfg2()		__dcsrrd(LOONGARCH_CSR_PRCFG2)
-#define write_csr_prcfg2(val)		__dcsrwr(val, LOONGARCH_CSR_PRCFG2)
-#define read_csr_prcfg3()		__dcsrrd(LOONGARCH_CSR_PRCFG3)
-#define write_csr_prcfg3(val)		__dcsrwr(val, LOONGARCH_CSR_PRCFG3)
-#define read_csr_stlbpgsize()		__dcsrrd(LOONGARCH_CSR_STLBPGSIZE)
+
+#if defined(CONFIG_64BIT)
+#define read_csr_prcfg1()               __dcsrrd(LOONGARCH_CSR_PRCFG1)
+#define write_csr_prcfg1(val)           __dcsrwr(val, LOONGARCH_CSR_PRCFG1)
+#define read_csr_prcfg2()               __dcsrrd(LOONGARCH_CSR_PRCFG2)
+#define write_csr_prcfg2(val)           __dcsrwr(val, LOONGARCH_CSR_PRCFG2)
+#define read_csr_prcfg3()               __dcsrrd(LOONGARCH_CSR_PRCFG3)
+#define write_csr_prcfg3(val)           __dcsrwr(val, LOONGARCH_CSR_PRCFG3)
+#define read_csr_stlbpgsize()           __dcsrrd(LOONGARCH_CSR_STLBPGSIZE)
+#define read_csr_entrylo0()		__dcsrrd(LOONGARCH_CSR_TLBELO0)
+#define read_csr_entrylo1()		__dcsrrd(LOONGARCH_CSR_TLBELO1)
+#define write_csr_entryhi(val)		__dcsrwr(val, LOONGARCH_CSR_TLBEHI)
+#define write_csr_entrylo0(val)         __dcsrwr(val, LOONGARCH_CSR_TLBELO0)
+#define write_csr_entrylo1(val)         __dcsrwr(val, LOONGARCH_CSR_TLBELO1)
 #define write_csr_stlbpgsize(val)	__dcsrwr(val, LOONGARCH_CSR_STLBPGSIZE)
 #define read_csr_rvacfg()		__dcsrrd(LOONGARCH_CSR_RVACFG)
 #define write_csr_rvacfg(val)		__dcsrwr(val, LOONGARCH_CSR_RVACFG)
@@ -1274,6 +1422,46 @@ static inline void write_csr_pagesize(unsigned int size)
 #define write_csr_perfctrl3(val)	__dcsrwr(val, LOONGARCH_CSR_PERFCTRL3)
 #define write_csr_perfcntr3(val)	__dcsrwr(val, LOONGARCH_CSR_PERFCNTR3)
 
+#elif defined(CONFIG_32BIT)
+#define read_csr_prcfg1()               __csrrd(LOONGARCH_CSR_PRCFG1)
+#define write_csr_prcfg1(val)           __csrwr(val, LOONGARCH_CSR_PRCFG1)
+#define read_csr_prcfg2()               __csrrd(LOONGARCH_CSR_PRCFG2)
+#define write_csr_prcfg2(val)           __csrwr(val, LOONGARCH_CSR_PRCFG2)
+#define read_csr_prcfg3()               __csrrd(LOONGARCH_CSR_PRCFG3)
+#define write_csr_prcfg3(val)           __csrwr(val, LOONGARCH_CSR_PRCFG3)
+#define read_csr_stlbpgsize()           __csrrd(LOONGARCH_CSR_STLBPGSIZE)
+#define read_csr_entrylo0()		__csrrd(LOONGARCH_CSR_TLBELO0)
+#define read_csr_entrylo1()		__csrrd(LOONGARCH_CSR_TLBELO1)
+#define read_csr_entryhi()		__csrrd(LOONGARCH_CSR_TLBEHI)
+#define write_csr_entryhi(val)		__csrwr(val, LOONGARCH_CSR_TLBEHI)
+#define write_csr_entrylo0(val)         __csrwr(val, LOONGARCH_CSR_TLBELO0)
+#define write_csr_entrylo1(val)         __csrwr(val, LOONGARCH_CSR_TLBELO1)
+#define write_csr_stlbpgsize(val)	__csrwr(val, LOONGARCH_CSR_STLBPGSIZE)
+#define read_csr_rvacfg()		__csrrd(LOONGARCH_CSR_RVACFG)
+#define write_csr_rvacfg(val)		__csrwr(val, LOONGARCH_CSR_RVACFG)
+#define write_csr_tintclear(val)	__csrwr(val, LOONGARCH_CSR_TINTCLR)
+#define read_csr_impctl1()		__csrrd(LOONGARCH_CSR_IMPCTL1)
+#define write_csr_impctl1(val)		__csrwr(val, LOONGARCH_CSR_IMPCTL1)
+#define write_csr_impctl2(val)		__csrwr(val, LOONGARCH_CSR_IMPCTL2)
+
+#define read_csr_perfctrl0()		__csrrd(LOONGARCH_CSR_PERFCTRL0)
+#define read_csr_perfcntr0()		__csrrd(LOONGARCH_CSR_PERFCNTR0)
+#define read_csr_perfctrl1()		__csrrd(LOONGARCH_CSR_PERFCTRL1)
+#define read_csr_perfcntr1()		__csrrd(LOONGARCH_CSR_PERFCNTR1)
+#define read_csr_perfctrl2()		__csrrd(LOONGARCH_CSR_PERFCTRL2)
+#define read_csr_perfcntr2()		__csrrd(LOONGARCH_CSR_PERFCNTR2)
+#define read_csr_perfctrl3()		__csrrd(LOONGARCH_CSR_PERFCTRL3)
+#define read_csr_perfcntr3()		__csrrd(LOONGARCH_CSR_PERFCNTR3)
+#define write_csr_perfctrl0(val)	__csrwr(val, LOONGARCH_CSR_PERFCTRL0)
+#define write_csr_perfcntr0(val)	__csrwr(val, LOONGARCH_CSR_PERFCNTR0)
+#define write_csr_perfctrl1(val)	__csrwr(val, LOONGARCH_CSR_PERFCTRL1)
+#define write_csr_perfcntr1(val)	__csrwr(val, LOONGARCH_CSR_PERFCNTR1)
+#define write_csr_perfctrl2(val)	__csrwr(val, LOONGARCH_CSR_PERFCTRL2)
+#define write_csr_perfcntr2(val)	__csrwr(val, LOONGARCH_CSR_PERFCNTR2)
+#define write_csr_perfctrl3(val)	__csrwr(val, LOONGARCH_CSR_PERFCTRL3)
+#define write_csr_perfcntr3(val)	__csrwr(val, LOONGARCH_CSR_PERFCNTR3)
+#endif
+
 /*
  * Manipulate bits in a register.
  */
@@ -1320,12 +1508,18 @@ change_##name(unsigned long change, unsigned long val)		\
 __BUILD_CSR_OP(euen)
 __BUILD_CSR_OP(ecfg)
 __BUILD_CSR_OP(tlbidx)
-
+#ifdef CONFIG_64BIT
 #define set_csr_estat(val)	\
 	__dcsrxchg(val, val, LOONGARCH_CSR_ESTAT)
 #define clear_csr_estat(val)	\
 	__dcsrxchg(~(val), val, LOONGARCH_CSR_ESTAT)
 
+#else
+#define set_csr_estat(val)      \
+        __csrxchg(val, val, LOONGARCH_CSR_ESTAT)
+#define clear_csr_estat(val)    \
+        __csrxchg(~(val), val, LOONGARCH_CSR_ESTAT)
+#endif
 #endif /* __ASSEMBLY__ */
 
 /* Generic EntryLo bit definitions */
@@ -1441,6 +1635,10 @@ __BUILD_CSR_OP(tlbidx)
 #define PL_256M		28
 
 /* ExStatus.ExcCode */
+#ifdef CONFIG_32BIT
+#define EXCCODE_GENERIC		32
+#endif
+
 #define EXCCODE_RSV		0	/* Reserved */
 #define EXCCODE_TLBL		1	/* TLB miss on a load */
 #define EXCCODE_TLBS		2	/* TLB miss on a store */
diff --git a/arch/loongarch/include/asm/mach-loongson32/boot_param.h b/arch/loongarch/include/asm/mach-loongson32/boot_param.h
new file mode 100644
index 000000000000..6d3b1509b458
--- /dev/null
+++ b/arch/loongarch/include/asm/mach-loongson32/boot_param.h
@@ -0,0 +1,92 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef __ASM_MACH_LOONGSON32_BOOT_PARAM_H_
+#define __ASM_MACH_LOONGSON32_BOOT_PARAM_H_
+
+#ifdef CONFIG_VT
+#include <linux/screen_info.h>
+#endif
+
+#define ADDRESS_TYPE_SYSRAM	1
+#define ADDRESS_TYPE_RESERVED	2
+#define ADDRESS_TYPE_ACPI	3
+#define ADDRESS_TYPE_NVS	4
+#define ADDRESS_TYPE_PMEM	5
+
+#define LOONGSON3_BOOT_MEM_MAP_MAX 128
+
+#define LOONGSON_EFIBOOT_SIGNATURE	"BPI"
+#define LOONGSON_MEM_LINKLIST		"MEM"
+#define LOONGSON_VBIOS_LINKLIST		"VBIOS"
+#define LOONGSON_SCREENINFO_LINKLIST	"SINFO"
+
+/* Values for Version BPI */
+enum bpi_version {
+	BPI_VERSION_V1 = 1000, /* Signature="BPI01000" */
+	BPI_VERSION_V2 = 1001, /* Signature="BPI01001" */
+};
+
+/* Flags in bootparamsinterface */
+#define BPI_FLAGS_UEFI_SUPPORTED BIT(0)
+
+struct _extention_list_hdr {
+	u64	signature;
+	u32	length;
+	u8	revision;
+	u8	checksum;
+	struct	_extention_list_hdr *next;
+} __packed;
+
+struct bootparamsinterface {
+	u64	signature;	/* {"B", "P", "I", "0", "1", ... } */
+	void	*systemtable;
+	struct	_extention_list_hdr *extlist;
+	u64	flags;
+} __packed;
+
+struct loongsonlist_mem_map {
+	struct	_extention_list_hdr header;	/* {"M", "E", "M"} */
+	u8	map_count;
+	struct	loongson_mem_map {
+		u32 mem_type;
+		u32 mem_start;
+		u32 mem_size;
+	} __packed map[LOONGSON3_BOOT_MEM_MAP_MAX];
+} __packed;
+
+struct loongsonlist_vbios {
+	struct	_extention_list_hdr header;	/* {"V", "B", "I", "O", "S"} */
+	u64	vbios_addr;
+} __packed;
+
+struct loongsonlist_screeninfo {
+	struct	_extention_list_hdr header;	/* {"S", "I", "N", "F", "O"} */
+	struct	screen_info si;
+} __packed;
+
+struct loongson_board_info {
+	int bios_size;
+	char *bios_vendor;
+	char *bios_version;
+	char *bios_release_date;
+	char *board_name;
+	char *board_vendor;
+};
+
+struct loongson_system_configuration {
+	int bpi_ver;
+	int nr_cpus;
+	int nr_nodes;
+	int nr_pch_pics;
+	int boot_cpu_id;
+	int cores_per_node;
+	int cores_per_package;
+	char *cpuname;
+	u64 vgabios_addr;
+	u64 reserved_cpus_mask;
+};
+
+extern struct loongson_board_info b_info;
+extern struct bootparamsinterface *efi_bp;
+extern struct loongsonlist_mem_map *loongson_mem_map;
+extern struct loongson_system_configuration loongson_sysconf;
+#endif
diff --git a/arch/loongarch/include/asm/mach-loongson32/irq.h b/arch/loongarch/include/asm/mach-loongson32/irq.h
new file mode 100644
index 000000000000..a4c9e25e1af9
--- /dev/null
+++ b/arch/loongarch/include/asm/mach-loongson32/irq.h
@@ -0,0 +1,80 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef __ASM_MACH_LOONGSON32_IRQ_H_
+#define __ASM_MACH_LOONGSON32_IRQ_H_
+
+#define NR_IRQS	(64 + 256)
+
+#define LOONGSON_CPU_UART0_VEC		10 /* CPU UART0 */
+#define LOONGSON_CPU_THSENS_VEC		14 /* CPU Thsens */
+#define LOONGSON_CPU_HT0_VEC		16 /* CPU HT0 irq vector base number */
+#define LOONGSON_CPU_HT1_VEC		24 /* CPU HT1 irq vector base number */
+
+/* IRQ number definitions */
+#define LOONGSON_LPC_IRQ_BASE		0
+#define LOONGSON_LPC_LAST_IRQ		(LOONGSON_LPC_IRQ_BASE + 15)
+
+#define LOONGSON_CPU_IRQ_BASE		16
+#define LOONGSON_LINTC_IRQ		(LOONGSON_CPU_IRQ_BASE + 2) /* IP2 for CPU local interrupt controller */
+#define LOONGSON_BRIDGE_IRQ		(LOONGSON_CPU_IRQ_BASE + 3) /* IP3 for bridge */
+#define LOONGSON_TIMER_IRQ		(LOONGSON_CPU_IRQ_BASE + 11) /* IP11 CPU Timer */
+#define LOONGSON_CPU_LAST_IRQ		(LOONGSON_CPU_IRQ_BASE + 14)
+
+#define LOONGSON_PCH_IRQ_BASE		64
+#define LOONGSON_PCH_ACPI_IRQ		(LOONGSON_PCH_IRQ_BASE + 47)
+#define LOONGSON_PCH_LAST_IRQ		(LOONGSON_PCH_IRQ_BASE + 64 - 1)
+
+#define LOONGSON_MSI_IRQ_BASE		(LOONGSON_PCH_IRQ_BASE + 64)
+#define LOONGSON_MSI_LAST_IRQ		(LOONGSON_PCH_IRQ_BASE + 256 - 1)
+
+#define GSI_MIN_CPU_IRQ		LOONGSON_CPU_IRQ_BASE
+#define GSI_MAX_CPU_IRQ		(LOONGSON_CPU_IRQ_BASE + 48 - 1)
+#define GSI_MIN_PCH_IRQ		LOONGSON_PCH_IRQ_BASE
+#define GSI_MAX_PCH_IRQ		(LOONGSON_PCH_IRQ_BASE + 256 - 1)
+
+#define MAX_PCH_PICS 4
+
+extern int find_pch_pic(u32 gsi);
+
+static inline void eiointc_enable(void)
+{
+	uint64_t misc;
+
+	misc = iocsr_readq(LOONGARCH_IOCSR_MISC_FUNC);
+	misc |= IOCSR_MISC_FUNC_EXT_IOI_EN;
+	iocsr_writeq(misc, LOONGARCH_IOCSR_MISC_FUNC);
+}
+
+struct acpi_madt_lio_pic;
+struct acpi_madt_eio_pic;
+struct acpi_madt_ht_pic;
+struct acpi_madt_bio_pic;
+struct acpi_madt_msi_pic;
+struct acpi_madt_lpc_pic;
+
+struct fwnode_handle *liointc_acpi_init(struct acpi_madt_lio_pic *acpi_liointc);
+struct fwnode_handle *eiointc_acpi_init(struct acpi_madt_eio_pic *acpi_eiointc);
+
+struct fwnode_handle *htvec_acpi_init(struct fwnode_handle *parent,
+					struct acpi_madt_ht_pic *acpi_htvec);
+struct fwnode_handle *pch_lpc_acpi_init(struct fwnode_handle *parent,
+					struct acpi_madt_lpc_pic *acpi_pchlpc);
+struct fwnode_handle *pch_msi_acpi_init(struct fwnode_handle *parent,
+					struct acpi_madt_msi_pic *acpi_pchmsi);
+struct fwnode_handle *pch_pic_acpi_init(struct fwnode_handle *parent,
+					struct acpi_madt_bio_pic *acpi_pchpic);
+
+extern struct acpi_madt_lio_pic *acpi_liointc;
+extern struct acpi_madt_eio_pic *acpi_eiointc;
+extern struct acpi_madt_ht_pic *acpi_htintc;
+extern struct acpi_madt_lpc_pic *acpi_pchlpc;
+extern struct acpi_madt_msi_pic *acpi_pchmsi;
+extern struct acpi_madt_bio_pic *acpi_pchpic[MAX_PCH_PICS];
+
+extern struct fwnode_handle *acpi_liointc_handle;
+extern struct fwnode_handle *acpi_msidomain_handle;
+extern struct fwnode_handle *acpi_picdomain_handle[MAX_PCH_PICS];
+
+extern void fixup_irqs(void);
+extern void loongson3_ipi_interrupt(int irq);
+
+#endif /* __ASM_MACH_LOONGSON32_IRQ_H_ */
diff --git a/arch/loongarch/include/asm/mach-loongson32/loongson.h b/arch/loongarch/include/asm/mach-loongson32/loongson.h
new file mode 100644
index 000000000000..0878709b534a
--- /dev/null
+++ b/arch/loongarch/include/asm/mach-loongson32/loongson.h
@@ -0,0 +1,165 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Author: Huacai Chen <chenhuacai@loongson.cn>
+ * Copyright (C) 2020-2021 Loongson Technology Corporation Limited
+ */
+
+#ifndef __ASM_MACH_LOONGSON32_LOONGSON_H
+#define __ASM_MACH_LOONGSON32_LOONGSON_H
+
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/pci.h>
+#include <asm/addrspace.h>
+
+#include <boot_param.h>
+
+extern const struct plat_smp_ops loongson3_smp_ops;
+
+/* loongson-specific command line, env and memory initialization */
+extern void __init fw_init_environ(void);
+extern void __init fw_init_memory(void);
+extern void __init fw_init_numa_memory(void);
+
+#define LOONGSON_REG(x) \
+	(*(volatile u32 *)((char *)TO_UNCAC(LOONGSON_REG_BASE) + (x)))
+
+#define LOONGSON_LIO_BASE	0x18000000
+#define LOONGSON_LIO_SIZE	0x00100000	/* 1M */
+#define LOONGSON_LIO_TOP	(LOONGSON_LIO_BASE+LOONGSON_LIO_SIZE-1)
+
+#define LOONGSON_BOOT_BASE	0x1c000000
+#define LOONGSON_BOOT_SIZE	0x02000000	/* 32M */
+#define LOONGSON_BOOT_TOP	(LOONGSON_BOOT_BASE+LOONGSON_BOOT_SIZE-1)
+
+#define LOONGSON_REG_BASE	0x1fe00000
+#define LOONGSON_REG_SIZE	0x00100000	/* 1M */
+#define LOONGSON_REG_TOP	(LOONGSON_REG_BASE+LOONGSON_REG_SIZE-1)
+
+/* GPIO Regs - r/w */
+
+#define LOONGSON_GPIODATA		LOONGSON_REG(0x11c)
+#define LOONGSON_GPIOIE			LOONGSON_REG(0x120)
+#define LOONGSON_REG_GPIO_BASE          (LOONGSON_REG_BASE + 0x11c)
+
+#define MAX_PACKAGES 4
+
+/* Chip Config registor of each physical cpu package */
+extern u32 loongson_chipcfg[MAX_PACKAGES];
+#define LOONGSON_CHIPCFG(id) (*(volatile u32 *)(loongson_chipcfg[id]))
+
+/* Chip Temperature registor of each physical cpu package */
+extern u32 loongson_chiptemp[MAX_PACKAGES];
+#define LOONGSON_CHIPTEMP(id) (*(volatile u32 *)(loongson_chiptemp[id]))
+
+/* Freq Control register of each physical cpu package */
+extern u32 loongson_freqctrl[MAX_PACKAGES];
+#define LOONGSON_FREQCTRL(id) (*(volatile u32 *)(loongson_freqctrl[id]))
+
+#define xconf_readl(addr) readl(addr)
+#define xconf_readq(addr) readq(addr)
+
+static inline void xconf_writel(u32 val, volatile void __iomem *addr)
+{
+	asm volatile (
+	"	st.w	%[v], %[hw], 0	\n"
+	"	ld.b	$r0, %[hw], 0	\n"
+	:
+	: [hw] "r" (addr), [v] "r" (val)
+	);
+}
+
+static inline void xconf_writeq(u64 val64, volatile void __iomem *addr)
+{
+	asm volatile (
+	"	st.d	%[v], %[hw], 0	\n"
+	"	ld.b	$r0, %[hw], 0	\n"
+	:
+	: [hw] "r" (addr),  [v] "r" (val64)
+	);
+}
+
+/* ============== LS7A registers =============== */
+#define LS7A_PCH_REG_BASE		0x10000000UL
+/* LPC regs */
+#define LS7A_LPC_REG_BASE		(LS7A_PCH_REG_BASE + 0x00002000)
+/* CHIPCFG regs */
+#define LS7A_CHIPCFG_REG_BASE		(LS7A_PCH_REG_BASE + 0x00010000)
+/* MISC reg base */
+#define LS7A_MISC_REG_BASE		(LS7A_PCH_REG_BASE + 0x00080000)
+/* ACPI regs */
+#define LS7A_ACPI_REG_BASE		(LS7A_MISC_REG_BASE + 0x00050000)
+/* RTC regs */
+#define LS7A_RTC_REG_BASE		(LS7A_MISC_REG_BASE + 0x00050100)
+
+#define LS7A_DMA_CFG			(volatile void *)TO_UNCAC(LS7A_CHIPCFG_REG_BASE + 0x041c)
+#define LS7A_DMA_NODE_SHF		8
+#define LS7A_DMA_NODE_MASK		0x1F00
+
+#define LS7A_INT_MASK_REG		(volatile void *)TO_UNCAC(LS7A_PCH_REG_BASE + 0x020)
+#define LS7A_INT_EDGE_REG		(volatile void *)TO_UNCAC(LS7A_PCH_REG_BASE + 0x060)
+#define LS7A_INT_CLEAR_REG		(volatile void *)TO_UNCAC(LS7A_PCH_REG_BASE + 0x080)
+#define LS7A_INT_HTMSI_EN_REG		(volatile void *)TO_UNCAC(LS7A_PCH_REG_BASE + 0x040)
+#define LS7A_INT_ROUTE_ENTRY_REG	(volatile void *)TO_UNCAC(LS7A_PCH_REG_BASE + 0x100)
+#define LS7A_INT_HTMSI_VEC_REG		(volatile void *)TO_UNCAC(LS7A_PCH_REG_BASE + 0x200)
+#define LS7A_INT_STATUS_REG		(volatile void *)TO_UNCAC(LS7A_PCH_REG_BASE + 0x3a0)
+#define LS7A_INT_POL_REG		(volatile void *)TO_UNCAC(LS7A_PCH_REG_BASE + 0x3e0)
+#define LS7A_LPC_INT_CTL		(volatile void *)TO_UNCAC(LS7A_PCH_REG_BASE + 0x2000)
+#define LS7A_LPC_INT_ENA		(volatile void *)TO_UNCAC(LS7A_PCH_REG_BASE + 0x2004)
+#define LS7A_LPC_INT_STS		(volatile void *)TO_UNCAC(LS7A_PCH_REG_BASE + 0x2008)
+#define LS7A_LPC_INT_CLR		(volatile void *)TO_UNCAC(LS7A_PCH_REG_BASE + 0x200c)
+#define LS7A_LPC_INT_POL		(volatile void *)TO_UNCAC(LS7A_PCH_REG_BASE + 0x2010)
+
+#define LS7A_PMCON_SOC_REG		(volatile void *)TO_UNCAC(LS7A_ACPI_REG_BASE + 0x000)
+#define LS7A_PMCON_RESUME_REG		(volatile void *)TO_UNCAC(LS7A_ACPI_REG_BASE + 0x004)
+#define LS7A_PMCON_RTC_REG		(volatile void *)TO_UNCAC(LS7A_ACPI_REG_BASE + 0x008)
+#define LS7A_PM1_EVT_REG		(volatile void *)TO_UNCAC(LS7A_ACPI_REG_BASE + 0x00c)
+#define LS7A_PM1_ENA_REG		(volatile void *)TO_UNCAC(LS7A_ACPI_REG_BASE + 0x010)
+#define LS7A_PM1_CNT_REG		(volatile void *)TO_UNCAC(LS7A_ACPI_REG_BASE + 0x014)
+#define LS7A_PM1_TMR_REG		(volatile void *)TO_UNCAC(LS7A_ACPI_REG_BASE + 0x018)
+#define LS7A_P_CNT_REG			(volatile void *)TO_UNCAC(LS7A_ACPI_REG_BASE + 0x01c)
+#define LS7A_GPE0_STS_REG		(volatile void *)TO_UNCAC(LS7A_ACPI_REG_BASE + 0x028)
+#define LS7A_GPE0_ENA_REG		(volatile void *)TO_UNCAC(LS7A_ACPI_REG_BASE + 0x02c)
+#define LS7A_RST_CNT_REG		(volatile void *)TO_UNCAC(LS7A_ACPI_REG_BASE + 0x030)
+#define LS7A_WD_SET_REG			(volatile void *)TO_UNCAC(LS7A_ACPI_REG_BASE + 0x034)
+#define LS7A_WD_TIMER_REG		(volatile void *)TO_UNCAC(LS7A_ACPI_REG_BASE + 0x038)
+#define LS7A_THSENS_CNT_REG		(volatile void *)TO_UNCAC(LS7A_ACPI_REG_BASE + 0x04c)
+#define LS7A_GEN_RTC_1_REG		(volatile void *)TO_UNCAC(LS7A_ACPI_REG_BASE + 0x050)
+#define LS7A_GEN_RTC_2_REG		(volatile void *)TO_UNCAC(LS7A_ACPI_REG_BASE + 0x054)
+#define LS7A_DPM_CFG_REG		(volatile void *)TO_UNCAC(LS7A_ACPI_REG_BASE + 0x400)
+#define LS7A_DPM_STS_REG		(volatile void *)TO_UNCAC(LS7A_ACPI_REG_BASE + 0x404)
+#define LS7A_DPM_CNT_REG		(volatile void *)TO_UNCAC(LS7A_ACPI_REG_BASE + 0x408)
+
+typedef enum {
+	ACPI_PCI_HOTPLUG_STATUS	= 1 << 1,
+	ACPI_CPU_HOTPLUG_STATUS	= 1 << 2,
+	ACPI_MEM_HOTPLUG_STATUS	= 1 << 3,
+	ACPI_POWERBUTTON_STATUS	= 1 << 8,
+	ACPI_RTC_WAKE_STATUS	= 1 << 10,
+	ACPI_PCI_WAKE_STATUS	= 1 << 14,
+	ACPI_ANY_WAKE_STATUS	= 1 << 15,
+} AcpiEventStatusBits;
+
+#define HT1LO_OFFSET		0xe0000000000UL
+
+/* PCI Configuration Space Base */
+#define HT1LO_PCICFG_BASE	0xefdfe000000UL
+#define HT1LO_PCICFG_BASE_TP1	0xefdff000000UL
+
+#define MCFG_EXT_PCICFG_BASE		0xefe00000000UL
+#define HT1LO_EXT_PCICFG_BASE		(((struct pci_controller *)(bus)->sysdata)->mcfg_addr)
+#define HT1LO_EXT_PCICFG_BASE_TP1	(HT1LO_EXT_PCICFG_BASE + 0x10000000)
+
+/* REG ACCESS*/
+#define ls7a_readb(addr)			  (*(volatile unsigned char  *)TO_UNCAC(addr))
+#define ls7a_readw(addr)			  (*(volatile unsigned short *)TO_UNCAC(addr))
+#define ls7a_readl(addr)			  (*(volatile unsigned int   *)TO_UNCAC(addr))
+#define ls7a_readq(addr)			  (*(volatile unsigned long  *)TO_UNCAC(addr))
+#define ls7a_writeb(val, addr)		*(volatile unsigned char  *)TO_UNCAC(addr) = (val)
+#define ls7a_writew(val, addr)		*(volatile unsigned short *)TO_UNCAC(addr) = (val)
+#define ls7a_writel(val, addr)		ls7a_write_type(val, addr, uint32_t)
+#define ls7a_writeq(val, addr)		ls7a_write_type(val, addr, uint64_t)
+#define ls7a_write(val, addr)		ls7a_write_type(val, addr, uint64_t)
+
+#endif /* __ASM_MACH_LOONGSON32_LOONGSON_H */
diff --git a/arch/loongarch/include/asm/mach-loongson32/topology.h b/arch/loongarch/include/asm/mach-loongson32/topology.h
new file mode 100644
index 000000000000..2bfad6a6ce30
--- /dev/null
+++ b/arch/loongarch/include/asm/mach-loongson32/topology.h
@@ -0,0 +1,26 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef _ASM_MACH_TOPOLOGY_H
+#define _ASM_MACH_TOPOLOGY_H
+
+#ifdef CONFIG_NUMA
+
+extern cpumask_t cpus_on_node[];
+
+#define cpumask_of_node(node)  (&cpus_on_node[node])
+
+struct pci_bus;
+extern int pcibus_to_node(struct pci_bus *);
+
+#define cpumask_of_pcibus(bus)	(cpu_online_mask)
+
+extern unsigned char __node_distances[MAX_NUMNODES][MAX_NUMNODES];
+
+void numa_set_distance(int from, int to, int distance);
+
+#define node_distance(from, to)	(__node_distances[(from)][(to)])
+
+#else
+#define pcibus_to_node(bus)	0
+#endif
+
+#endif /* _ASM_MACH_TOPOLOGY_H */
diff --git a/arch/loongarch/include/asm/percpu.h b/arch/loongarch/include/asm/percpu.h
index ea3c3e7808dc..259c3902e14f 100644
--- a/arch/loongarch/include/asm/percpu.h
+++ b/arch/loongarch/include/asm/percpu.h
@@ -5,8 +5,8 @@
 #ifndef __ASM_PERCPU_H
 #define __ASM_PERCPU_H
 
+#ifdef CONFIG_64BIT
 #include <asm/cmpxchg.h>
-
 /* Use r21 for fast access */
 register unsigned long __my_cpu_offset __asm__("$r21");
 
@@ -191,6 +191,7 @@ do {									\
 #define this_cpu_xchg_2(pcp, val) _percpu_xchg(pcp, val)
 #define this_cpu_xchg_4(pcp, val) _percpu_xchg(pcp, val)
 #define this_cpu_xchg_8(pcp, val) _percpu_xchg(pcp, val)
+#endif
 
 #include <asm-generic/percpu.h>
 
diff --git a/arch/loongarch/include/asm/pgtable-32.h b/arch/loongarch/include/asm/pgtable-32.h
new file mode 100644
index 000000000000..250662565823
--- /dev/null
+++ b/arch/loongarch/include/asm/pgtable-32.h
@@ -0,0 +1,153 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 1994, 95, 96, 97, 98, 99, 2000, 2003 Ralf Baechle
+ * Copyright (C) 1999, 2000, 2001 Silicon Graphics, Inc.
+ */
+#ifndef _ASM_PGTABLE_32_H
+#define _ASM_PGTABLE_32_H
+
+#include <asm/addrspace.h>
+#include <asm/page.h>
+
+#include <linux/linkage.h>
+#include <asm/fixmap.h>
+
+#define __ARCH_USE_5LEVEL_HACK
+#include <asm-generic/pgtable-nopmd.h>
+
+#ifdef CONFIG_PAGE_SIZE_4KB
+#include <asm-generic/pgtable-nopud.h>
+#endif
+
+#ifdef CONFIG_HIGHMEM
+#include <asm/highmem.h>
+#endif
+
+
+/*
+ * - add_temporary_entry() add a temporary TLB entry. We use TLB entries
+ *	starting at the top and working down. This is for populating the
+ *	TLB before trap_init() puts the TLB miss handler in place. It
+ *	should be used only for entries matching the actual page tables,
+ *	to prevent inconsistencies.
+ */
+
+/*
+ * Basically we have the same two-level (which is the logical three level
+ * Linux page table layout folded) page tables as the i386.  Some day
+ * when we have proper page coloring support we can have a 1% quicker
+ * tlb refill handling mechanism, but for now it is a bit slower but
+ * works even with the cache aliasing problem the R4k and above have.
+ */
+
+/* PGDIR_SHIFT determines what a third-level page table entry can map */
+#define PGDIR_SHIFT	(2 * PAGE_SHIFT  - PTE_T_LOG2)
+#define PGDIR_SIZE	(1UL << PGDIR_SHIFT)
+#define PGDIR_MASK	(~(PGDIR_SIZE-1))
+
+/*
+ * Entries per page directory level: we use two-level, so
+ * we don't really have any PUD/PMD directory physically.
+ */
+
+#define PGD_ORDER               0
+#define PUD_ORDER               aieeee_attempt_to_allocate_pud
+#define PMD_ORDER               0
+#define PTE_ORDER               0
+
+
+#define PTRS_PER_PGD	(USER_PTRS_PER_PGD * 2)
+#define PTRS_PER_PTE	(PAGE_SIZE / sizeof(pte_t))
+
+#define USER_PTRS_PER_PGD	(0x80000000UL/PGDIR_SIZE)
+#define FIRST_USER_ADDRESS	0UL
+
+#ifndef __ASSEMBLY__
+#define VMALLOC_START	  MAP_BASE
+#define FIXADDR_START 0xe0000000UL
+#define PKMAP_END	((FIXADDR_START) & ~((LAST_PKMAP << PAGE_SHIFT)-1))
+#define PKMAP_BASE	(PKMAP_END - PAGE_SIZE * LAST_PKMAP)
+
+#ifdef CONFIG_HIGHMEM
+# define VMALLOC_END	(PKMAP_BASE-2*PAGE_SIZE)
+#else
+# define VMALLOC_END	(FIXADDR_START-2*PAGE_SIZE)
+#endif
+
+#define pte_ERROR(e) \
+	printk("%s:%d: bad pte %08lx.\n", __FILE__, __LINE__, pte_val(e))
+#define pgd_ERROR(e) \
+	printk("%s:%d: bad pgd %08lx.\n", __FILE__, __LINE__, pgd_val(e))
+
+
+extern pte_t invalid_pte_table[PTRS_PER_PTE];
+
+/*
+ * Empty pgd/pmd entries point to the invalid_pte_table.
+ */
+static inline int pmd_none(pmd_t pmd)
+{
+	return pmd_val(pmd) == (unsigned long) invalid_pte_table;
+}
+
+#define pmd_bad(pmd)		(pmd_val(pmd) & ~PAGE_MASK)
+
+static inline int pmd_present(pmd_t pmd)
+{
+	return pmd_val(pmd) != (unsigned long) invalid_pte_table;
+}
+
+static inline void pmd_clear(pmd_t *pmdp)
+{
+	pmd_val(*pmdp) = ((unsigned long) invalid_pte_table);
+}
+
+#define pte_pfn(x)		((unsigned long)((x).pte >> _PFN_SHIFT))
+#define pfn_pte(pfn, prot)	__pte(((unsigned long long)(pfn) << _PFN_SHIFT) | pgprot_val(prot))
+
+#define pte_page(x)		pfn_to_page(pte_pfn(x))
+
+#define __pgd_offset(address)	pgd_index(address)
+#define __pud_offset(address)	(((address) >> PUD_SHIFT) & (PTRS_PER_PUD-1))
+#define __pmd_offset(address)	(((address) >> PMD_SHIFT) & (PTRS_PER_PMD-1))
+
+/* to find an entry in a kernel page-table-directory */
+#define pgd_offset_k(address) pgd_offset(&init_mm, address)
+
+#define pgd_index(address)	(((address) >> PGDIR_SHIFT) & (PTRS_PER_PGD-1))
+
+/* to find an entry in a page-table-directory */
+#define pgd_offset(mm, addr)	((mm)->pgd + pgd_index(addr))
+
+/* Find an entry in the third-level page table.. */
+#define __pte_offset(address)						\
+	(((address) >> PAGE_SHIFT) & (PTRS_PER_PTE - 1))
+#define pte_offset(dir, address)					\
+	((pte_t *) pmd_page_vaddr(*(dir)) + __pte_offset(address))
+#define pte_offset_kernel(dir, address)					\
+	((pte_t *) pmd_page_vaddr(*(dir)) + __pte_offset(address))
+
+/*#define pte_offset_map(dir, address)					\
+  ((pte_t *)page_address(pmd_page(*(dir))) + __pte_offset(address))
+*/
+#define pte_unmap(pte) ((void)(pte))
+
+/*
+ * Constraints:
+ *      _PAGE_PRESENT at bit 0
+ *      _PAGE_MODIFIED at bit 4
+ *      _PAGE_GLOBAL at bit 6
+ *      _PAGE_VALID at bit 7
+ */
+#define __swp_type(x)			(((x).val >> 8) & 0x1f)
+#define __swp_offset(x)			 ((x).val >> 13)
+#define __swp_entry(type,offset)	((swp_entry_t)	{ ((type) << 8) | ((offset) << 13) })
+#define __pte_to_swp_entry(pte)		((swp_entry_t) { pte_val(pte) })
+#define __swp_entry_to_pte(x)		((pte_t) { (x).val })
+
+#endif
+
+#endif /* _ASM_PGTABLE_32_H */
diff --git a/arch/loongarch/include/asm/pgtable-bits.h b/arch/loongarch/include/asm/pgtable-bits.h
index a196c8b3760a..b7d23d240a6a 100644
--- a/arch/loongarch/include/asm/pgtable-bits.h
+++ b/arch/loongarch/include/asm/pgtable-bits.h
@@ -7,6 +7,7 @@
 
 /* Page table bits */
 
+#ifdef CONFIG_64BIT
 #define	_PAGE_VALID_SHIFT	0
 #define	_PAGE_DIRTY_SHIFT	1
 #define	_PAGE_PLV_SHIFT		2  /* 2~3, two bits */
@@ -23,31 +24,66 @@
 #define	_PAGE_NO_READ_SHIFT	61
 #define	_PAGE_NO_EXEC_SHIFT	62
 #define	_PAGE_RPLV_SHIFT	63
+#endif
+
+#ifdef CONFIG_32BIT
+#define _PAGE_VALID_SHIFT       0
+#define _PAGE_DIRTY_SHIFT       1
+#define _PAGE_PLV_SHIFT         2  /* 2~3, two bits */
+#define _CACHE_SHIFT            4  /* 4~5, two bits */
+#define _PAGE_GLOBAL_SHIFT      6
+#define _PAGE_HUGE_SHIFT        6  /* HUGE is a PMD bit */
+#define _PAGE_PRESENT_SHIFT     7
+#define _PAGE_WRITE_SHIFT       8
+#define _PAGE_PROTNONE_SHIFT    9
+#define _PAGE_SPECIAL_SHIFT     10
+#define _PAGE_HGLOBAL_SHIFT     12 /* HGlobal is a PMD bit */
+#define _PAGE_PFN_SHIFT         12
+#define _PAGE_PFN_END_SHIFT	31
+#endif
 
 /* Used only by software */
+#ifdef CONFIG_64BIT
 #define _PAGE_PRESENT		(_ULCAST_(1) << _PAGE_PRESENT_SHIFT)
 #define _PAGE_WRITE		(_ULCAST_(1) << _PAGE_WRITE_SHIFT)
 #define _PAGE_PROTNONE		(_ULCAST_(1) << _PAGE_PROTNONE_SHIFT)
 #define _PAGE_SPECIAL		(_ULCAST_(1) << _PAGE_SPECIAL_SHIFT)
+#endif
+
+#ifdef CONFIG_32BIT
+#define _PAGE_PRESENT           (_ULCAST_(1) << _PAGE_PRESENT_SHIFT)
+#define _PAGE_WRITE             (_ULCAST_(1) << _PAGE_WRITE_SHIFT)
+#define _PAGE_MODIFIED          (_ULCAST_(1) << _PAGE_DIRTY_SHIFT) //it may be useless
+#define _PAGE_SPECIAL           (_ULCAST_(1)<<_PAGE_SPECIAL_SHIFT)
+#define _PAGE_PROTNONE          (_ULCAST_(1) << _PAGE_PROTNONE_SHIFT)
+#endif
 
 /* Used by TLB hardware (placed in EntryLo*) */
+#ifdef CONFIG_64BIT
+#define _PAGE_NO_READ           (_ULCAST_(1) << _PAGE_NO_READ_SHIFT)
+#define _PAGE_NO_EXEC           (_ULCAST_(1) << _PAGE_NO_EXEC_SHIFT)
+#define _PAGE_RPLV              (_ULCAST_(1) << _PAGE_RPLV_SHIFT)
+#endif
+
+#ifdef CONFIG_32BIT
+#define _PAGE_NO_EXEC	0
+#define _PAGE_NO_READ	0
+#endif
+
 #define _PAGE_VALID		(_ULCAST_(1) << _PAGE_VALID_SHIFT)
 #define _PAGE_DIRTY		(_ULCAST_(1) << _PAGE_DIRTY_SHIFT)
 #define _PAGE_PLV		(_ULCAST_(3) << _PAGE_PLV_SHIFT)
 #define _PAGE_GLOBAL		(_ULCAST_(1) << _PAGE_GLOBAL_SHIFT)
 #define _PAGE_HUGE		(_ULCAST_(1) << _PAGE_HUGE_SHIFT)
 #define _PAGE_HGLOBAL		(_ULCAST_(1) << _PAGE_HGLOBAL_SHIFT)
-#define _PAGE_NO_READ		(_ULCAST_(1) << _PAGE_NO_READ_SHIFT)
-#define _PAGE_NO_EXEC		(_ULCAST_(1) << _PAGE_NO_EXEC_SHIFT)
-#define _PAGE_RPLV		(_ULCAST_(1) << _PAGE_RPLV_SHIFT)
 #define _CACHE_MASK		(_ULCAST_(3) << _CACHE_SHIFT)
 #define _PFN_SHIFT		(PAGE_SHIFT - 12 + _PAGE_PFN_SHIFT)
 
 #define _PAGE_USER	(PLV_USER << _PAGE_PLV_SHIFT)
 #define _PAGE_KERN	(PLV_KERN << _PAGE_PLV_SHIFT)
 
-#define _PFN_MASK (~((_ULCAST_(1) << (_PFN_SHIFT)) - 1) & \
-		  ((_ULCAST_(1) << (_PAGE_PFN_END_SHIFT)) - 1))
+#define _PFN_MASK	(~((_ULCAST_(1) << (_PFN_SHIFT)) - 1) & \
+			((_ULCAST_(1) << (_PAGE_PFN_END_SHIFT)) - 1))
 
 /*
  * Cache attributes
diff --git a/arch/loongarch/include/asm/pgtable.h b/arch/loongarch/include/asm/pgtable.h
index 2c66f2d5a9ff..e6a0a6ba0b06 100644
--- a/arch/loongarch/include/asm/pgtable.h
+++ b/arch/loongarch/include/asm/pgtable.h
@@ -9,7 +9,13 @@
 #include <linux/mmzone.h>
 #include <asm/io.h>
 #include <asm/pgtable-bits.h>
+#ifdef CONFIG_64BIT
 #include <asm/pgtable-64.h>
+#endif
+#ifdef CONFIG_32BIT
+#include <asm/pgtable-32.h>
+#endif
+
 
 struct mm_struct;
 struct vm_area_struct;
diff --git a/arch/loongarch/include/asm/stackframe.h b/arch/loongarch/include/asm/stackframe.h
index db462a457f1a..645c1bc44333 100644
--- a/arch/loongarch/include/asm/stackframe.h
+++ b/arch/loongarch/include/asm/stackframe.h
@@ -162,7 +162,7 @@
 	andi	t0, t0, 0x3	/* extract pplv bit */
 	beqz	t0, 9f
 
-	li.d	tp, ~_THREAD_MASK
+	PTR_LI	tp, ~_THREAD_MASK
 	and	tp, tp, sp
 	cfi_st  x0, PT_R21, \docfi
 9:
diff --git a/arch/loongarch/include/asm/syscall.h b/arch/loongarch/include/asm/syscall.h
index 7d877ebfda77..199d57818ef3 100644
--- a/arch/loongarch/include/asm/syscall.h
+++ b/arch/loongarch/include/asm/syscall.h
@@ -68,7 +68,13 @@ static inline void syscall_get_arguments(struct task_struct *task,
 
 static inline int syscall_get_arch(struct task_struct *task)
 {
+#ifdef CONFIG_32BIT
+	return AUDIT_ARCH_LOONGARCH32;
+#endif
+
+#ifdef CONFIG_64BIT
 	return AUDIT_ARCH_LOONGARCH64;
+#endif
 }
 
 #endif	/* __ASM_LOONGARCH_SYSCALL_H */
diff --git a/arch/loongarch/include/asm/time.h b/arch/loongarch/include/asm/time.h
index 4d97151c16aa..d455998b3855 100644
--- a/arch/loongarch/include/asm/time.h
+++ b/arch/loongarch/include/asm/time.h
@@ -14,6 +14,7 @@ extern u64 const_clock_freq;
 
 extern void sync_counter(void);
 
+#ifdef CONFIG_64BIT
 static inline unsigned int calc_const_freq(void)
 {
 	unsigned int res;
@@ -34,6 +35,14 @@ static inline unsigned int calc_const_freq(void)
 	else
 		return (base_freq * cfm / cfd);
 }
+#endif
+
+#ifdef CONFIG_32BIT
+static inline unsigned int calc_const_freq(void)
+{
+	return 200000000;
+}
+#endif
 
 /*
  * Initialize the calling CPU's timer interrupt as clockevent device
diff --git a/arch/loongarch/include/asm/uaccess.h b/arch/loongarch/include/asm/uaccess.h
index 860077c2dc13..660dea686442 100644
--- a/arch/loongarch/include/asm/uaccess.h
+++ b/arch/loongarch/include/asm/uaccess.h
@@ -28,6 +28,22 @@ extern u64 __ua_limit;
 
 #endif /* CONFIG_64BIT */
 
+
+#ifdef CONFIG_32BIT
+
+extern u32 __ua_limit;
+#define __UA_LIMIT      __ua_limit
+
+#define __UA_ADDR       ".word"
+#define __UA_LA         "la.abs"
+#define __UA_ADDU       "add.w"
+#define __UA_t0         "$r12"
+#define __UA_t1         "$r13"
+#define __UA_SLLI       "slli.w"
+
+#endif /* CONFIG_32BIT */
+
+
 /*
  * Is a address valid? This does a straightforward calculation rather
  * than tests.
@@ -251,8 +267,8 @@ do {									\
 	} __gu_tmp;							\
 									\
 	__asm__ __volatile__(						\
-	"1:	ld.w	%1, (%3)				\n"	\
-	"2:	ld.w	%D1, 4(%3)				\n"	\
+	"1:	ld.w	%1, %3 , 0				\n"	\
+	"2:	ld.w	%D1, %3 , 4				\n"	\
 	"3:							\n"	\
 	"	.section	.fixup,\"ax\"			\n"	\
 	"4:	li.w	%0, %4					\n"	\
@@ -310,8 +326,8 @@ do {									\
 #define __put_data_asm_ll32(insn, ptr)					\
 {									\
 	__asm__ __volatile__(						\
-	"1:	st.w	%2, (%3)	# __put_user_asm_ll32	\n"	\
-	"2:	st.w	%D2, 4(%3)				\n"	\
+	"1:	st.w	%2, %3 ,0	# __put_user_asm_ll32	\n"	\
+	"2:	st.w	%D2, %3 ,4				\n"	\
 	"3:							\n"	\
 	"	.section	.fixup,\"ax\"			\n"	\
 	"4:	li.w	%0, %4					\n"	\
diff --git a/arch/loongarch/include/asm/unistd.h b/arch/loongarch/include/asm/unistd.h
index 25b6f2d0b4e5..295e68df2447 100644
--- a/arch/loongarch/include/asm/unistd.h
+++ b/arch/loongarch/include/asm/unistd.h
@@ -5,7 +5,13 @@
  *
  * Copyright (C) 2020-2021 Loongson Technology Corporation Limited
  */
+#ifdef CONFIG_32BIT
+#define __ARCH_WANT_STAT64
+#define __ARCH_WANT_TIME32_SYSCALLS
+#endif
 
 #include <uapi/asm/unistd.h>
 
+#define TRANS_ARCH_MASK                 0xffff0000
+#define SYS_NUM_MASK                    0xffff
 #define NR_syscalls (__NR_syscalls)
diff --git a/arch/loongarch/include/asm/vdso/gettimeofday.h b/arch/loongarch/include/asm/vdso/gettimeofday.h
index 18ae4c9e2bdd..02698e6e11e7 100644
--- a/arch/loongarch/include/asm/vdso/gettimeofday.h
+++ b/arch/loongarch/include/asm/vdso/gettimeofday.h
@@ -71,7 +71,24 @@ static __always_inline int clock_getres_fallback(
 
 	return ret;
 }
+#ifdef CONFIG_32BIT
+static __always_inline u64 __arch_get_hw_counter(s32 clock_mode,
+						 const struct vdso_data *vd)
+{
+	unsigned int count;
+	unsigned int count1;
+	u64 res;
+
+	__asm__ __volatile__(
+	"	rdcntvl.w %0\n"
+	"   rdcntvh.w %1\n "
+	: "=r" (count), "=r"(count1));
+
+	res = ((u64)count1 <<32)| count;
+	return res;
+}
 
+#else
 static __always_inline u64 __arch_get_hw_counter(s32 clock_mode,
 						 const struct vdso_data *vd)
 {
@@ -83,6 +100,7 @@ static __always_inline u64 __arch_get_hw_counter(s32 clock_mode,
 
 	return count;
 }
+#endif
 
 static inline bool loongarch_vdso_hres_capable(void)
 {
diff --git a/arch/loongarch/include/uapi/asm/unistd.h b/arch/loongarch/include/uapi/asm/unistd.h
index b344b1f91715..5797898a43c7 100644
--- a/arch/loongarch/include/uapi/asm/unistd.h
+++ b/arch/loongarch/include/uapi/asm/unistd.h
@@ -2,5 +2,11 @@
 #define __ARCH_WANT_NEW_STAT
 #define __ARCH_WANT_SYS_CLONE
 #define __ARCH_WANT_SYS_CLONE3
+#define __ARCH_WANT_SET_GET_RLIMIT
+
+#ifdef __loongarch32
+#define __ARCH_WANT_STAT64
+#define __ARCH_WANT_TIME32_SYSCALLS
+#endif
 
 #include <asm-generic/unistd.h>
diff --git a/arch/loongarch/kernel/Makefile b/arch/loongarch/kernel/Makefile
index e8ac09514544..fd2024b12663 100644
--- a/arch/loongarch/kernel/Makefile
+++ b/arch/loongarch/kernel/Makefile
@@ -5,12 +5,13 @@
 
 extra-y		:= head.o vmlinux.lds
 
-obj-y		+= cmpxchg.o cpu-probe.o elf.o entry.o genex.o idle.o irq.o \
-		   process.o ptrace.o reset.o setup.o signal.o io.o \
+obj-y		+= cmpxchg.o elf.o entry.o genex.o idle.o irq.o \
+		   process.o ptrace.o reset.o setup.o signal.o \
 		   syscall.o time.o topology.o traps.o unaligned.o \
-		   cmdline.o switch.o cacheinfo.o vdso.o
+		   cmdline.o switch.o vdso.o
 
 obj-$(CONFIG_ACPI)		+= acpi.o
+
 obj-$(CONFIG_EFI) 		+= efi.o
 
 obj-$(CONFIG_MODULES)		+= module.o
@@ -19,6 +20,10 @@ obj-$(CONFIG_CPU_HAS_FPU)	+= fpu.o
 
 obj-$(CONFIG_SMP)		+= smp.o
 
+obj-$(CONFIG_EARLY_PRINTK)	+= early_printk.o
+
+obj-$(CONFIG_32BIT)		+= cpu-probe32.o scall32.o
+
 obj-$(CONFIG_64BIT)		+= scall64.o
 
 obj-$(CONFIG_PROC_FS)		+= proc.o
diff --git a/arch/loongarch/kernel/acpi.c b/arch/loongarch/kernel/acpi.c
index ee334b60e652..9d8d78bbe77b 100644
--- a/arch/loongarch/kernel/acpi.c
+++ b/arch/loongarch/kernel/acpi.c
@@ -350,80 +350,6 @@ int __init acpi_boot_init(void)
 	return 0;
 }
 
-#ifdef CONFIG_ACPI_NUMA
-
-static __init int setup_node(int pxm)
-{
-	return acpi_map_pxm_to_node(pxm);
-}
-
-/*
- * Callback for SLIT parsing.  pxm_to_node() returns NUMA_NO_NODE for
- * I/O localities since SRAT does not list them.  I/O localities are
- * not supported at this point.
- */
-extern unsigned char __node_distances[MAX_NUMNODES][MAX_NUMNODES];
-unsigned int numa_distance_cnt;
-
-static inline unsigned int get_numa_distances_cnt(struct acpi_table_slit *slit)
-{
-	return slit->locality_count;
-}
-
-void __init numa_set_distance(int from, int to, int distance)
-{
-	if ((u8)distance != distance || (from == to && distance != LOCAL_DISTANCE)) {
-		pr_warn_once("Warning: invalid distance parameter, from=%d to=%d distance=%d\n",
-				from, to, distance);
-		return;
-	}
-
-	__node_distances[from][to] = distance;
-}
-
-/* Callback for Proximity Domain -> CPUID mapping */
-void __init
-acpi_numa_processor_affinity_init(struct acpi_srat_cpu_affinity *pa)
-{
-	int pxm, node;
-
-	if (srat_disabled())
-		return;
-	if (pa->header.length != sizeof(struct acpi_srat_cpu_affinity)) {
-		bad_srat();
-		return;
-	}
-	if ((pa->flags & ACPI_SRAT_CPU_ENABLED) == 0)
-		return;
-	pxm = pa->proximity_domain_lo;
-	if (acpi_srat_revision >= 2) {
-		pxm |= (pa->proximity_domain_hi[0] << 8);
-		pxm |= (pa->proximity_domain_hi[1] << 16);
-		pxm |= (pa->proximity_domain_hi[2] << 24);
-	}
-	node = setup_node(pxm);
-	if (node < 0) {
-		pr_err("SRAT: Too many proximity domains %x\n", pxm);
-		bad_srat();
-		return;
-	}
-
-	if (pa->apic_id >= CONFIG_NR_CPUS) {
-		pr_info("SRAT: PXM %u -> CPU 0x%02x -> Node %u skipped apicid that is too big\n",
-				pxm, pa->apic_id, node);
-		return;
-	}
-
-	early_numa_add_cpu(pa->apic_id, node);
-
-	set_cpuid_to_node(pa->apic_id, node);
-	node_set(node, numa_nodes_parsed);
-	pr_info("SRAT: PXM %u -> CPU 0x%02x -> Node %u\n", pxm, pa->apic_id, node);
-}
-
-void __init acpi_numa_arch_fixup(void) {}
-#endif
-
 void __init arch_reserve_mem_area(acpi_physical_address addr, size_t size)
 {
 	u8 map_count = loongson_mem_map->map_count;
@@ -440,17 +366,6 @@ void __init arch_reserve_mem_area(acpi_physical_address addr, size_t size)
 
 static int __ref acpi_map_cpu2node(acpi_handle handle, int cpu, int physid)
 {
-#ifdef CONFIG_ACPI_NUMA
-	int nid;
-
-	nid = acpi_get_node(handle);
-	if (nid != NUMA_NO_NODE) {
-		set_cpuid_to_node(physid, nid);
-		node_set(nid, numa_nodes_parsed);
-		set_cpu_numa_node(cpu, nid);
-		cpumask_set_cpu(cpu, cpumask_of_node(nid));
-	}
-#endif
 	return 0;
 }
 
@@ -474,9 +389,6 @@ EXPORT_SYMBOL(acpi_map_cpu);
 
 int acpi_unmap_cpu(int cpu)
 {
-#ifdef CONFIG_ACPI_NUMA
-	set_cpuid_to_node(cpu_logical_map(cpu), NUMA_NO_NODE);
-#endif
 	set_cpu_present(cpu, false);
 	num_processors--;
 
diff --git a/arch/loongarch/kernel/cpu-probe.c b/arch/loongarch/kernel/cpu-probe.c
index 0583ea9264c9..bfac66f1602f 100644
--- a/arch/loongarch/kernel/cpu-probe.c
+++ b/arch/loongarch/kernel/cpu-probe.c
@@ -73,17 +73,6 @@ static void cpu_probe_addrbits(struct cpuinfo_loongarch *c)
 
 static void set_isa(struct cpuinfo_loongarch *c, unsigned int isa)
 {
-	switch (isa) {
-	case LOONGARCH_CPU_ISA_LA64:
-		c->isa_level |= LOONGARCH_CPU_ISA_LA64;
-		fallthrough;
-	case LOONGARCH_CPU_ISA_LA32S:
-		c->isa_level |= LOONGARCH_CPU_ISA_LA32S;
-		fallthrough;
-	case LOONGARCH_CPU_ISA_LA32R:
-		c->isa_level |= LOONGARCH_CPU_ISA_LA32R;
-		break;
-	}
 }
 
 static void decode_configs(struct cpuinfo_loongarch *c)
diff --git a/arch/loongarch/kernel/cpu-probe32.c b/arch/loongarch/kernel/cpu-probe32.c
new file mode 100644
index 000000000000..89059f5edcbf
--- /dev/null
+++ b/arch/loongarch/kernel/cpu-probe32.c
@@ -0,0 +1,198 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Processor capabilities determination functions.
+ *
+ * Copyright (C) 2020-2021 Loongson Technology Corporation Limited
+ */
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/ptrace.h>
+#include <linux/smp.h>
+#include <linux/stddef.h>
+#include <linux/export.h>
+#include <linux/printk.h>
+#include <linux/uaccess.h>
+
+#include <asm/cpu.h>
+#include <asm/cpu-features.h>
+#include <asm/fpu.h>
+#include <asm/loongarchregs.h>
+#include <asm/elf.h>
+#include <asm/pgtable-bits.h>
+
+/* Hardware capabilities */
+unsigned int elf_hwcap __read_mostly;
+EXPORT_SYMBOL_GPL(elf_hwcap);
+
+/*
+ * Determine the FCSR mask for FPU hardware.
+ */
+static inline void cpu_set_fpu_fcsr_mask(struct cpuinfo_loongarch *c)
+{
+	unsigned long sr, mask, fcsr, fcsr0, fcsr1;
+
+	fcsr = c->fpu_csr0;
+	mask = FPU_CSR_ALL_X | FPU_CSR_ALL_E | FPU_CSR_ALL_S | FPU_CSR_RM;
+
+	sr = read_csr_euen();
+	enable_fpu();
+
+	fcsr0 = fcsr & mask;
+	write_fcsr(LOONGARCH_FCSR0, fcsr0);
+	fcsr0 = read_fcsr(LOONGARCH_FCSR0);
+
+	fcsr1 = fcsr | ~mask;
+	write_fcsr(LOONGARCH_FCSR0, fcsr1);
+	fcsr1 = read_fcsr(LOONGARCH_FCSR0);
+
+	write_fcsr(LOONGARCH_FCSR0, fcsr);
+
+	write_csr_euen(sr);
+
+	c->fpu_mask = ~(fcsr0 ^ fcsr1) & ~mask;
+}
+
+static inline void set_elf_platform(int cpu, const char *plat)
+{
+	if (cpu == 0)
+		__elf_platform = plat;
+}
+
+/* MAP BASE */
+unsigned long vm_map_base;
+EXPORT_SYMBOL_GPL(vm_map_base);
+
+static void cpu_probe_addrbits(struct cpuinfo_loongarch *c)
+{
+#ifdef __NEED_ADDRBITS_PROBE
+	c->pabits = (read_cpucfg(LOONGARCH_CPUCFG1) & CPUCFG1_PABITS) >> 4;
+	c->vabits = (read_cpucfg(LOONGARCH_CPUCFG1) & CPUCFG1_VABITS) >> 12;
+	vm_map_base = 0UL - (1UL << c->vabits);
+#endif
+	c->pabits = 31;
+	c->vabits = 31;
+	vm_map_base = 0UL - (1UL << c->vabits);
+}
+
+static void set_isa(struct cpuinfo_loongarch *c, unsigned int isa)
+{
+	switch (isa) {
+	case LOONGARCH_CPU_ISA_LA32S:
+		c->isa_level |= LOONGARCH_CPU_ISA_LA32S;
+		fallthrough;
+	case LOONGARCH_CPU_ISA_LA32R:
+		c->isa_level |= LOONGARCH_CPU_ISA_LA32R;
+		break;
+	}
+}
+
+static void decode_configs(struct cpuinfo_loongarch *c)
+{
+        unsigned long asid_mask;
+
+	asid_mask =0xff;
+	set_cpu_asid_mask(c, asid_mask);
+	c->tlbsizemtlb = 0x40;
+	c->tlbsizestlbsets = 0x100;
+	c->tlbsizestlbways = 0x8;
+	c->tlbsize = c->tlbsizemtlb + c->tlbsizestlbsets*  c->tlbsizestlbways;
+}
+
+#define MAX_NAME_LEN	32
+#define VENDOR_OFFSET	0
+#define CPUNAME_OFFSET	9
+
+static char cpu_full_name[MAX_NAME_LEN] = "        -        ";
+
+static inline void cpu_probe_loongson(struct cpuinfo_loongarch *c, unsigned int cpu)
+{
+	c->options = LOONGARCH_CPU_CPUCFG | LOONGARCH_CPU_CSR |
+		     LOONGARCH_CPU_TLB | LOONGARCH_CPU_VINT | LOONGARCH_CPU_WATCH;
+
+	decode_configs(c);
+	elf_hwcap |= HWCAP_LOONGARCH_CRC32;
+
+	__cpu_full_name[cpu] = cpu_full_name;
+
+	switch (c->processor_id & PRID_IMP_MASK) {
+	case PRID_IMP_LOONGSON_32:
+		c->cputype = CPU_LOONGSON32;
+		set_isa(c, LOONGARCH_CPU_ISA_LA32S);
+		__cpu_family[cpu] = "Loongson-32bit";
+		pr_info("Standard 32-bit Loongson Processor probed\n");
+		break;
+	default: // Default to 64 bit
+		c->cputype = CPU_LOONGSON64;
+		set_isa(c, LOONGARCH_CPU_ISA_LA64);
+		__cpu_family[cpu] = "Loongson-64bit";
+		pr_info("Unknown 64-bit Loongson Processor probed\n");
+	}
+}
+
+
+
+/* For use by uaccess.h */
+u32 __ua_limit;
+EXPORT_SYMBOL(__ua_limit);
+
+
+const char *__cpu_family[NR_CPUS];
+const char *__cpu_full_name[NR_CPUS];
+const char *__elf_platform;
+
+void cpu_probe(void)
+{
+	struct cpuinfo_loongarch *c = &current_cpu_data;
+	unsigned int cpu = smp_processor_id();
+
+	set_elf_platform(cpu, "loongarch");
+
+	c->cputype	= CPU_UNKNOWN;
+	c->processor_id = 0x4200;
+
+	c->fpu_csr0	= FPU_CSR_RN;
+	c->fpu_mask	= FPU_CSR_RSVD;
+
+	switch (c->processor_id & PRID_IMP_MASK) {
+	case PRID_IMP_LOONGSON_32:
+		cpu_probe_loongson(c, cpu);
+		break;
+	}
+
+	BUG_ON(!__cpu_family[cpu]);
+	BUG_ON(c->cputype == CPU_UNKNOWN);
+
+	cpu_probe_addrbits(c);
+
+	if (cpu == 0)
+		__ua_limit = ~((1ul << cpu_vabits) - 1);
+}
+
+void cpu_report(void)
+{
+	struct cpuinfo_loongarch *c = &current_cpu_data;
+
+	pr_info("CPU%d revision is: %08x (%s)\n",
+		smp_processor_id(), c->processor_id, cpu_family_string());
+	if (c->options & LOONGARCH_CPU_FPU)
+		pr_info("FPU%d revision is: %08x\n", smp_processor_id(), c->fpu_vers);
+}
+
+void cpu_set_cluster(struct cpuinfo_loongarch *cpuinfo, unsigned int cluster)
+{
+	/* Ensure the core number fits in the field */
+	WARN_ON(cluster > (LOONGARCH_GLOBALNUMBER_CLUSTER >>
+			   LOONGARCH_GLOBALNUMBER_CLUSTER_SHF));
+
+	cpuinfo->globalnumber &= ~LOONGARCH_GLOBALNUMBER_CLUSTER;
+	cpuinfo->globalnumber |= cluster << LOONGARCH_GLOBALNUMBER_CLUSTER_SHF;
+}
+
+void cpu_set_core(struct cpuinfo_loongarch *cpuinfo, unsigned int core)
+{
+	/* Ensure the core number fits in the field */
+	WARN_ON(core > (LOONGARCH_GLOBALNUMBER_CORE >> LOONGARCH_GLOBALNUMBER_CORE_SHF));
+
+	cpuinfo->globalnumber &= ~LOONGARCH_GLOBALNUMBER_CORE;
+	cpuinfo->globalnumber |= core << LOONGARCH_GLOBALNUMBER_CORE_SHF;
+}
diff --git a/arch/loongarch/kernel/early_printk.c b/arch/loongarch/kernel/early_printk.c
new file mode 100644
index 000000000000..916a6d135ae2
--- /dev/null
+++ b/arch/loongarch/kernel/early_printk.c
@@ -0,0 +1,37 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2020-2021 Loongson Technology Corporation Limited
+ */
+#include <linux/kernel.h>
+#include <linux/console.h>
+#include <linux/printk.h>
+#include <linux/init.h>
+#include <asm/setup.h>
+
+extern void prom_putchar(char);
+extern struct console *early_console;
+
+static void early_console_write(struct console *con, const char *s, unsigned n)
+{
+	while (n-- && *s) {
+		if (*s == '\n')
+			prom_putchar('\r');
+		prom_putchar(*s);
+		s++;
+	}
+}
+
+static struct console early_console_prom = {
+	.name	= "early",
+	.write	= early_console_write,
+	.flags	= CON_PRINTBUFFER | CON_BOOT,
+	.index	= -1
+};
+
+void __init setup_early_printk(void)
+{
+	if (early_console)
+		return;
+	early_console = &early_console_prom;
+	register_console(&early_console_prom);
+}
diff --git a/arch/loongarch/kernel/genex.S b/arch/loongarch/kernel/genex.S
index 7f146339e552..a72820228d26 100644
--- a/arch/loongarch/kernel/genex.S
+++ b/arch/loongarch/kernel/genex.S
@@ -74,7 +74,6 @@ SYM_FUNC_END(except_vec_cex)
 	.macro	__BUILD_HANDLER exception handler clear verbose ext
 	.align	5
 	SYM_FUNC_START(handle_\exception)
-	BACKUP_T0T1
 	SAVE_ALL
 	SYM_INNER_LABEL(handle_\exception\ext, SYM_L_GLOBAL)
 	__build_clear_\clear
@@ -112,47 +111,67 @@ SYM_FUNC_END(handle_syscall)
  * Common Vectored Interrupt
  * Complete the register saves and invoke the do_vi() handler
  */
+
 SYM_FUNC_START(except_vec_vi_handler)
-	la	t1, __arch_cpu_idle
-	LONG_L  t0, sp, PT_EPC
+
+	BACKUP_T0T1
+	csrrd	t0, LOONGARCH_CSR_ESTAT
+	srli.w	t1, t0, 0x10   /* get Ecode */
+	andi	t1, t1, 0x3f
+	beq	t1, zero, 1f	/* if irq */
+
+        csrrd	t0, LOONGARCH_CSR_EENTRY
+        slli.w	t1, t1, 0x9  /* get ex entry shift = Ecode * vec_size  */
+        add.w	t0, t0, t1
+        lu12i.w	t1, 0x4
+        sub.w	t0, t0, t1
+        jirl	zero,t0 , 0  /* go to exception_handler */
+
+1:
+	SAVE_SOME
+	la.abs	t1, __arch_cpu_idle
+	LONG_L	t0, sp, PT_EPC
+
 	/* 32 byte rollback region */
 	ori	t0, t0, 0x1f
 	xori	t0, t0, 0x1f
-	bne	t0, t1, 1f
-	LONG_S  t0, sp, PT_EPC
-1:	SAVE_TEMP
+	bne	t0, t1, 2f
+	LONG_S	t0, sp, PT_EPC
+2:
+	SAVE_TEMP
 	SAVE_STATIC
+
 	CLI
+	TRACE_IRQS_OFF
 
-	LONG_L		s0, tp, TI_REGS
-	LONG_S		sp, tp, TI_REGS
+	ld.w	s0, tp, TI_REGS
+	st.w	sp, tp, TI_REGS
+	move	s1, sp
 
-	move		s1, sp /* Preserve sp */
+	csrrd	t0, LOONGARCH_CSR_TMID
+	la.abs	t1, irq_stack
+	slli.w	t0, t0, LONGLOG
+	ld.w	t0, t1, 0
 
-	/* Get IRQ stack for this CPU */
-	la		t1, irq_stack
-	LONG_ADDU	t1, t1, x0
-	LONG_L		t0, t1, 0
+	li.w	t1, ~(_THREAD_SIZE-1)
+	and	t1, t1, sp
+	beq	t0, t1, 2f
 
-	/* Check if already on IRQ stack */
-	PTR_LI		t1, ~(_THREAD_SIZE-1)
-	and		t1, t1, sp
-	beq		t0, t1, 2f
+	li.w	t1, _IRQ_STACK_START
+	add.w	sp, t0, t1
+	st.w	s1,sp, 0
 
-	/* Switch to IRQ stack */
-	li.w		t1, _IRQ_STACK_START
-	PTR_ADDU	sp, t0, t1
+2:
+	la.abs	t0, plat_irq_dispatch
+	jirl	ra, t0, 0
 
-	/* Save task's sp on IRQ stack so that unwinding can follow it */
-	LONG_S		s1, sp, 0
-2:	la		t0, do_vi
-	jirl		ra, t0, 0
+	move	sp, s1
 
-	move		sp, s1 /* Restore sp */
-	la		t0, ret_from_irq
-	jirl    	zero, t0, 0
+	la.abs	t0, ret_from_irq
+	jirl	zero, t0, 0
 SYM_FUNC_END(except_vec_vi_handler)
 
+
 	.macro	BUILD_VI_HANDLER num
 	.align	5
 SYM_FUNC_START(handle_vi_\num)
diff --git a/arch/loongarch/kernel/head.S b/arch/loongarch/kernel/head.S
index 4a25f03b0d29..bb26bb7e642f 100644
--- a/arch/loongarch/kernel/head.S
+++ b/arch/loongarch/kernel/head.S
@@ -17,52 +17,69 @@ SYM_ENTRY(_stext, SYM_L_GLOBAL, SYM_A_NONE)
 
 	__REF
 
-SYM_CODE_START(kernel_entry)			# kernel entry point
+SYM_CODE_START(kernel_entry)                    # kernel entry point
 
-	/* We might not get launched at the address the kernel is linked to,
-	   so we jump there.  */
-	la.abs		t0, 0f
-	jirl		zero, t0, 0
+        /* We might not get launched at the address the kernel is linked to,
+           so we jump there.  */
+        la.abs          t0, 0f
+        jirl            zero, t0, 0
 0:
-	la		t0, __bss_start		# clear .bss
-	st.d		zero, t0, 0
-	la		t1, __bss_stop - LONGSIZE
+#ifdef CONFIG_USE_OF
+
+        li.w            t1, -2
+        or              t2, a1, zero
+        beq             a0, t1, dtb_found
+
+        li.w            t2, 0
+dtb_found:
+#endif
+
+#if 0
+	la              t0, __bss_start         # clear .bss
+        PTR_S           zero, t0, 0
+        la              t1, __bss_stop - LONGSIZE
 1:
-	addi.d		t0, t0, LONGSIZE
-	st.d		zero, t0, 0
-	bne		t0, t1, 1b
-
-	la		t0, fw_arg0
-	st.d		a0, t0, 0		# firmware arguments
-	la		t0, fw_arg1
-	st.d		a1, t0, 0
-	la		t0, fw_arg2
-	st.d		a2, t0, 0
-	la		t0, fw_arg3
-	st.d		a3, t0, 0
-
-	/* Config direct window and set PG */
-	li.d		t0, CSR_DMW0_INIT	# UC, PLV0, 0x8000 xxxx xxxx xxxx
-	csrwr		t0, LOONGARCH_CSR_DMWIN0
-	li.d		t0, CSR_DMW1_INIT	# CA, PLV0, 0x9000 xxxx xxxx xxxx
-	csrwr		t0, LOONGARCH_CSR_DMWIN1
-	/* Enable PG */
-	li.w		t0, 0xb0		# PLV=0, IE=0, PG=1
-	csrwr		t0, LOONGARCH_CSR_CRMD
+        PTR_ADDIU	t0, t0, LONGSIZE
+        PTR_S		zero, t0, 0
+        bne		t0, t1, 1b
+#endif
+
+        la              t0, fw_arg0
+        PTR_S           a0, t0, 0               # firmware arguments
+        la              t0, fw_arg1
+        PTR_S           a1, t0, 0
+        la              t0, fw_arg2
+        PTR_S           a2, t0, 0
+        la              t0, fw_arg3
+        PTR_S           a3, t0, 0
+
+#ifdef CONFIG_USE_OF
+        la      t0, fw_passed_dtb
+        PTR_S            t2, t0, 0
+#endif
+
+        /* Config direct window and set PG */
+        PTR_LI          t0, 0xa0000011
+        csrwr           t0, LOONGARCH_CSR_DMWIN0
+        PTR_LI          t0, 0x80000001
+        csrwr           t0, LOONGARCH_CSR_DMWIN1
+        /* Enable PG */
+        li.w            t0, 0xb0                # PLV=0, IE=0, PG=1
+        csrwr           t0, LOONGARCH_CSR_CRMD
 
-	/* KScratch3 used for percpu base, initialized as 0 */
-	csrwr		zero, PERCPU_BASE_KS
-	/* GPR21 used for percpu base (runtime), initialized as 0 */
-	or		x0, zero, zero
+        /* KScratch3 used for percpu base, initialized as 0 */
+        csrwr           zero, PERCPU_BASE_KS
+        /* GPR21 used for percpu base (runtime), initialized as 0 */
+        or              x0, zero, zero
 
-	la		tp, init_thread_union
-	/* Set the SP after an empty pt_regs.  */
-	PTR_LI		sp, (_THREAD_SIZE - 32 - PT_SIZE)
-	PTR_ADDU	sp, sp, tp
-	set_saved_sp	sp, t0, t1
-	PTR_ADDIU	sp, sp, -4 * SZREG	# init stack pointer
+        la              tp, init_thread_union
+        /* Set the SP after an empty pt_regs.  */
+        PTR_LI          sp, (_THREAD_SIZE - 32 - PT_SIZE)
+        PTR_ADDU        sp, sp, tp
+        set_saved_sp    sp, t0, t1
+        PTR_ADDIU       sp, sp, -4 * SZREG      # init stack pointer
 
-	b		start_kernel
+        b               start_kernel
 
 SYM_CODE_END(kernel_entry)
 
@@ -73,9 +90,9 @@ SYM_CODE_END(kernel_entry)
  * function after setting up the stack and tp registers.
  */
 SYM_CODE_START(smpboot_entry)
-	li.d		t0, CSR_DMW0_INIT	# UC, PLV0
+	PTR_LI		t0, CSR_DMW0_INIT	# UC, PLV0
 	csrwr		t0, LOONGARCH_CSR_DMWIN0
-	li.d		t0, CSR_DMW1_INIT	# CA, PLV0
+	PTR_LI		t0, CSR_DMW1_INIT	# CA, PLV0
 	csrwr		t0, LOONGARCH_CSR_DMWIN1
 	li.w		t0, 0xb0		# PLV=0, IE=0, PG=1
 	csrwr		t0, LOONGARCH_CSR_CRMD
diff --git a/arch/loongarch/kernel/irq.c b/arch/loongarch/kernel/irq.c
index cacf928b03f3..6d84bbd26c75 100644
--- a/arch/loongarch/kernel/irq.c
+++ b/arch/loongarch/kernel/irq.c
@@ -34,7 +34,9 @@ atomic_t irq_err_count;
 
 int arch_show_interrupts(struct seq_file *p, int prec)
 {
+#ifdef CONFIG_SMP
 	show_ipi_list(p, prec);
+#endif
 	seq_printf(p, "%*s: %10u\n", prec, "ERR", atomic_read(&irq_err_count));
 	return 0;
 }
diff --git a/arch/loongarch/kernel/proc.c b/arch/loongarch/kernel/proc.c
index 443ede08c386..5fc4617d3c5c 100644
--- a/arch/loongarch/kernel/proc.c
+++ b/arch/loongarch/kernel/proc.c
@@ -30,75 +30,6 @@ int proc_cpuinfo_notifier_call_chain(unsigned long val, void *v)
 
 static int show_cpuinfo(struct seq_file *m, void *v)
 {
-	unsigned long n = (unsigned long) v - 1;
-	unsigned int version = cpu_data[n].processor_id & 0xff;
-	unsigned int fp_version = cpu_data[n].fpu_vers;
-	struct proc_cpuinfo_notifier_args proc_cpuinfo_notifier_args;
-
-#ifdef CONFIG_SMP
-	if (!cpu_online(n))
-		return 0;
-#endif
-
-	/*
-	 * For the first processor also print the system type
-	 */
-	if (n == 0)
-		seq_printf(m, "system type\t\t: %s\n", get_system_type());
-
-	seq_printf(m, "processor\t\t: %ld\n", n);
-	seq_printf(m, "package\t\t\t: %d\n", cpu_data[n].package);
-	seq_printf(m, "core\t\t\t: %d\n", cpu_core(&cpu_data[n]));
-	seq_printf(m, "cpu family\t\t: %s\n", __cpu_family[n]);
-	seq_printf(m, "model name\t\t: %s\n", __cpu_full_name[n]);
-	seq_printf(m, "CPU Revision\t\t: 0x%02x\n", version);
-	seq_printf(m, "FPU Revision\t\t: 0x%02x\n", fp_version);
-	seq_printf(m, "CPU MHz\t\t\t: %llu.%02llu\n",
-		      cpu_clock_freq / 1000000, (cpu_clock_freq / 10000) % 100);
-	seq_printf(m, "BogoMIPS\t\t: %llu.%02llu\n",
-		      (cpu_data[n].udelay_val * cpu_clock_freq / const_clock_freq) / (500000/HZ),
-		      ((cpu_data[n].udelay_val * cpu_clock_freq / const_clock_freq) / (5000/HZ)) % 100);
-	seq_printf(m, "TLB entries\t\t: %d\n", cpu_data[n].tlbsize);
-	seq_printf(m, "Address sizes\t\t: %d bits physical, %d bits virtual\n",
-		      cpu_pabits + 1, cpu_vabits + 1);
-
-	seq_printf(m, "isa\t\t\t:");
-	if (cpu_has_loongarch32)
-		seq_printf(m, "%s", " loongarch32");
-	if (cpu_has_loongarch64)
-		seq_printf(m, "%s", " loongarch64");
-	seq_printf(m, "\n");
-
-	seq_printf(m, "features\t\t:");
-	if (cpu_has_cpucfg)	seq_printf(m, "%s", " cpucfg");
-	if (cpu_has_lam)	seq_printf(m, "%s", " lam");
-	if (cpu_has_ual)	seq_printf(m, "%s", " ual");
-	if (cpu_has_fpu)	seq_printf(m, "%s", " fpu");
-	if (cpu_has_lsx)	seq_printf(m, "%s", " lsx");
-	if (cpu_has_lasx)	seq_printf(m, "%s", " lasx");
-	if (cpu_has_complex)	seq_printf(m, "%s", " complex");
-	if (cpu_has_crypto)	seq_printf(m, "%s", " crypto");
-	if (cpu_has_lvz)	seq_printf(m, "%s", " lvz");
-	if (cpu_has_lbt_x86)	seq_printf(m, "%s", " lbt_x86");
-	if (cpu_has_lbt_arm)	seq_printf(m, "%s", " lbt_arm");
-	if (cpu_has_lbt_mips)	seq_printf(m, "%s", " lbt_mips");
-	seq_printf(m, "\n");
-
-	seq_printf(m, "hardware watchpoint\t: %s",
-		      cpu_has_watch ? "yes, " : "no\n");
-	if (cpu_has_watch) {
-		seq_printf(m, "iwatch count: %d, dwatch count: %d\n",
-		      cpu_data[n].watch_ireg_count, cpu_data[n].watch_dreg_count);
-	}
-
-	proc_cpuinfo_notifier_args.m = m;
-	proc_cpuinfo_notifier_args.n = n;
-
-	raw_notifier_call_chain(&proc_cpuinfo_chain, 0,
-				&proc_cpuinfo_notifier_args);
-
-	seq_printf(m, "\n");
-
 	return 0;
 }
 
diff --git a/arch/loongarch/kernel/ptrace.c b/arch/loongarch/kernel/ptrace.c
index fa0def6a67cd..0101895de046 100644
--- a/arch/loongarch/kernel/ptrace.c
+++ b/arch/loongarch/kernel/ptrace.c
@@ -211,16 +211,7 @@ static int cfg_get(struct task_struct *target,
 		   const struct user_regset *regset,
 		   struct membuf to)
 {
-	int i, r;
-	u32 cfg_val;
-
-	i = 0;
-	while (to.left > 0) {
-		cfg_val = read_cpucfg(i++);
-		r = membuf_write(&to, &cfg_val, sizeof(u32));
-	}
-
-	return r;
+	return 0;
 }
 
 /*
diff --git a/arch/loongarch/kernel/scall32.S b/arch/loongarch/kernel/scall32.S
new file mode 100644
index 000000000000..836cde4d402c
--- /dev/null
+++ b/arch/loongarch/kernel/scall32.S
@@ -0,0 +1,126 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2020-2021 Loongson Technology Corporation Limited
+ */
+#include <linux/errno.h>
+#include <asm/asm.h>
+#include <asm/asmmacro.h>
+#include <asm/irqflags.h>
+#include <asm/loongarchregs.h>
+#include <asm/regdef.h>
+#include <asm/stackframe.h>
+#include <asm/asm-offsets.h>
+#include <asm/thread_info.h>
+#include <asm/unistd.h>
+
+	.text
+	.cfi_sections	.debug_frame
+	.align	5
+SYM_FUNC_START(handle_sys)
+	csrrd	t0, PERCPU_BASE_KS
+	la.abs	t1, kernelsp
+	PTR_ADDU	t1, t1, t0
+	or	t2, sp, zero
+	LONG_L	sp, t1, 0
+
+	PTR_ADDIU	sp, sp, -PT_SIZE
+	cfi_st	t2, PT_R3
+	cfi_rel_offset  sp, PT_R3
+	csrrd	t2, LOONGARCH_CSR_PRMD
+	LONG_S	t2, sp, PT_PRMD
+	csrrd	t2, LOONGARCH_CSR_CRMD
+	LONG_S	t2, sp, PT_CRMD
+	csrrd	t2, LOONGARCH_CSR_ECFG
+	LONG_S	t2, sp, PT_ECFG
+	csrrd	t2, LOONGARCH_CSR_EUEN
+	LONG_S	t2, sp, PT_EUEN
+	cfi_st	ra, PT_R1
+	cfi_st	a0, PT_R4
+	cfi_st	a1, PT_R5
+	cfi_st	a2, PT_R6
+	cfi_st	a3, PT_R7
+	cfi_st	a4, PT_R8
+	cfi_st	a5, PT_R9
+	cfi_st	a6, PT_R10
+	cfi_st	a7, PT_R11
+	csrrd	ra, LOONGARCH_CSR_EPC
+	LONG_S	ra, sp, PT_EPC
+
+	cfi_rel_offset ra, PT_EPC
+
+	cfi_st	tp, PT_R2
+	cfi_st	x0, PT_R21
+	cfi_st	fp, PT_R22
+
+	PTR_LI	tp, ~_THREAD_MASK
+	and	tp, tp, sp
+
+	STI
+
+	/* save the initial A0 value (needed in signal handlers) */
+	LONG_S	a0, sp, PT_ORIG_A0
+	LONG_L	t1, sp, PT_EPC		# skip syscall on return
+	PTR_ADDIU	t1, t1, 4		# skip to next instruction
+	LONG_S	t1, sp, PT_EPC
+
+	PTR_LI	t1, _TIF_WORK_SYSCALL_ENTRY
+	LONG_L	t0, tp, TI_FLAGS	# syscall tracing enabled?
+	and	t0, t1, t0
+	bnez	t0, syscall_trace_entry
+
+syscall_common:
+	/* Check to make sure we don't jump to a bogus syscall number. */
+	li.w	t0, __NR_syscalls
+	PTR_SUBU	t2, a7, t0
+	bgez	t2, illegal_syscall
+
+	/* Syscall number held in a7 */
+	LONG_SLL	t0, a7, 2		# offset into table
+	la	t2, sys_call_table
+	PTR_ADDU	t0, t2, t0
+	LONG_L	t2, t0, 0		#syscall routine
+	beqz    t2, illegal_syscall
+
+	jalr	t2			# Do The Real Thing (TM)
+
+	LONG_L	t1, sp, PT_R11		# syscall number
+	PTR_ADDIU	t1, t1, 1		# +1 for handle_signal
+	LONG_S	t1, sp, PT_R0		# save it for syscall restarting
+	LONG_S	v0, sp, PT_R4		# result
+
+la_syscall_exit:
+	b	syscall_exit_partial
+
+/* ------------------------------------------------------------------------ */
+
+syscall_trace_entry:
+	SAVE_STATIC
+	move	a0, sp
+	move	a1, a7
+	bl	syscall_trace_enter
+
+	blt	v0, zero, 1f			# seccomp failed? Skip syscall
+
+	RESTORE_STATIC
+	LONG_L	a0, sp, PT_R4		# Restore argument registers
+	LONG_L	a1, sp, PT_R5
+	LONG_L	a2, sp, PT_R6
+	LONG_L	a3, sp, PT_R7
+	LONG_L	a4, sp, PT_R8
+	LONG_L	a5, sp, PT_R9
+	LONG_L	a6, sp, PT_R10
+	LONG_L	a7, sp, PT_R11		# Restore syscall (maybe modified)
+	b	syscall_common
+
+1:	b	syscall_exit
+
+	/*
+	 * The system call does not exist in this kernel
+	 */
+
+illegal_syscall:
+	/* This also isn't a valid syscall, throw an error.  */
+	li.w	v0, -ENOSYS			# error
+	LONG_S	v0, sp, PT_R4
+	b	la_syscall_exit
+SYM_FUNC_END(handle_sys)
diff --git a/arch/loongarch/kernel/scall64.S b/arch/loongarch/kernel/scall64.S
index ec4cf68d7feb..836cde4d402c 100644
--- a/arch/loongarch/kernel/scall64.S
+++ b/arch/loongarch/kernel/scall64.S
@@ -19,21 +19,21 @@
 SYM_FUNC_START(handle_sys)
 	csrrd	t0, PERCPU_BASE_KS
 	la.abs	t1, kernelsp
-	add.d	t1, t1, t0
+	PTR_ADDU	t1, t1, t0
 	or	t2, sp, zero
-	ld.d	sp, t1, 0
+	LONG_L	sp, t1, 0
 
-	addi.d	sp, sp, -PT_SIZE
+	PTR_ADDIU	sp, sp, -PT_SIZE
 	cfi_st	t2, PT_R3
 	cfi_rel_offset  sp, PT_R3
 	csrrd	t2, LOONGARCH_CSR_PRMD
-	st.d	t2, sp, PT_PRMD
+	LONG_S	t2, sp, PT_PRMD
 	csrrd	t2, LOONGARCH_CSR_CRMD
-	st.d	t2, sp, PT_CRMD
+	LONG_S	t2, sp, PT_CRMD
 	csrrd	t2, LOONGARCH_CSR_ECFG
-	st.d	t2, sp, PT_ECFG
+	LONG_S	t2, sp, PT_ECFG
 	csrrd	t2, LOONGARCH_CSR_EUEN
-	st.d	t2, sp, PT_EUEN
+	LONG_S	t2, sp, PT_EUEN
 	cfi_st	ra, PT_R1
 	cfi_st	a0, PT_R4
 	cfi_st	a1, PT_R5
@@ -44,7 +44,7 @@ SYM_FUNC_START(handle_sys)
 	cfi_st	a6, PT_R10
 	cfi_st	a7, PT_R11
 	csrrd	ra, LOONGARCH_CSR_EPC
-	st.d	ra, sp, PT_EPC
+	LONG_S	ra, sp, PT_EPC
 
 	cfi_rel_offset ra, PT_EPC
 
@@ -52,18 +52,18 @@ SYM_FUNC_START(handle_sys)
 	cfi_st	x0, PT_R21
 	cfi_st	fp, PT_R22
 
-	li.d	tp, ~_THREAD_MASK
+	PTR_LI	tp, ~_THREAD_MASK
 	and	tp, tp, sp
 
 	STI
 
 	/* save the initial A0 value (needed in signal handlers) */
-	st.d	a0, sp, PT_ORIG_A0
-	ld.d	t1, sp, PT_EPC		# skip syscall on return
-	addi.d	t1, t1, 4		# skip to next instruction
-	st.d	t1, sp, PT_EPC
+	LONG_S	a0, sp, PT_ORIG_A0
+	LONG_L	t1, sp, PT_EPC		# skip syscall on return
+	PTR_ADDIU	t1, t1, 4		# skip to next instruction
+	LONG_S	t1, sp, PT_EPC
 
-	li.d	t1, _TIF_WORK_SYSCALL_ENTRY
+	PTR_LI	t1, _TIF_WORK_SYSCALL_ENTRY
 	LONG_L	t0, tp, TI_FLAGS	# syscall tracing enabled?
 	and	t0, t1, t0
 	bnez	t0, syscall_trace_entry
@@ -71,24 +71,24 @@ SYM_FUNC_START(handle_sys)
 syscall_common:
 	/* Check to make sure we don't jump to a bogus syscall number. */
 	li.w	t0, __NR_syscalls
-	sub.d	t2, a7, t0
+	PTR_SUBU	t2, a7, t0
 	bgez	t2, illegal_syscall
 
 	/* Syscall number held in a7 */
-	slli.d	t0, a7, 3		# offset into table
+	LONG_SLL	t0, a7, 2		# offset into table
 	la	t2, sys_call_table
-	add.d	t0, t2, t0
-	ld.d	t2, t0, 0		#syscall routine
+	PTR_ADDU	t0, t2, t0
+	LONG_L	t2, t0, 0		#syscall routine
 	beqz    t2, illegal_syscall
 
 	jalr	t2			# Do The Real Thing (TM)
 
-	ld.d	t1, sp, PT_R11		# syscall number
-	addi.d	t1, t1, 1		# +1 for handle_signal
-	st.d	t1, sp, PT_R0		# save it for syscall restarting
-	st.d	v0, sp, PT_R4		# result
+	LONG_L	t1, sp, PT_R11		# syscall number
+	PTR_ADDIU	t1, t1, 1		# +1 for handle_signal
+	LONG_S	t1, sp, PT_R0		# save it for syscall restarting
+	LONG_S	v0, sp, PT_R4		# result
 
-la64_syscall_exit:
+la_syscall_exit:
 	b	syscall_exit_partial
 
 /* ------------------------------------------------------------------------ */
@@ -102,14 +102,14 @@ syscall_trace_entry:
 	blt	v0, zero, 1f			# seccomp failed? Skip syscall
 
 	RESTORE_STATIC
-	ld.d	a0, sp, PT_R4		# Restore argument registers
-	ld.d	a1, sp, PT_R5
-	ld.d	a2, sp, PT_R6
-	ld.d	a3, sp, PT_R7
-	ld.d	a4, sp, PT_R8
-	ld.d	a5, sp, PT_R9
-	ld.d	a6, sp, PT_R10
-	ld.d	a7, sp, PT_R11		# Restore syscall (maybe modified)
+	LONG_L	a0, sp, PT_R4		# Restore argument registers
+	LONG_L	a1, sp, PT_R5
+	LONG_L	a2, sp, PT_R6
+	LONG_L	a3, sp, PT_R7
+	LONG_L	a4, sp, PT_R8
+	LONG_L	a5, sp, PT_R9
+	LONG_L	a6, sp, PT_R10
+	LONG_L	a7, sp, PT_R11		# Restore syscall (maybe modified)
 	b	syscall_common
 
 1:	b	syscall_exit
@@ -121,6 +121,6 @@ syscall_trace_entry:
 illegal_syscall:
 	/* This also isn't a valid syscall, throw an error.  */
 	li.w	v0, -ENOSYS			# error
-	st.d	v0, sp, PT_R4
-	b	la64_syscall_exit
+	LONG_S	v0, sp, PT_R4
+	b	la_syscall_exit
 SYM_FUNC_END(handle_sys)
diff --git a/arch/loongarch/kernel/setup.c b/arch/loongarch/kernel/setup.c
index a3fb015e5f7a..976c91159090 100644
--- a/arch/loongarch/kernel/setup.c
+++ b/arch/loongarch/kernel/setup.c
@@ -8,7 +8,7 @@
  * Copyright (C) 1994, 95, 96, 97, 98, 99, 2000, 01, 02, 03  Ralf Baechle
  * Copyright (C) 1996 Stoned Elipot
  * Copyright (C) 1999 Silicon Graphics, Inc.
- * Copyright (C) 2000, 2001, 2002, 2007	 Maciej W. Rozycki
+ * Copyright (C) 2000, 2001, 2002, 2007         Maciej W. Rozycki
  */
 #include <linux/init.h>
 #include <linux/ioport.h>
@@ -32,9 +32,12 @@
 #include <asm/dma.h>
 #include <asm/sections.h>
 #include <asm/setup.h>
+
+#ifdef CONFIG_SMP
 #include <asm/smp.h>
+#endif
 
-DEFINE_PER_CPU(unsigned long, kernelsp);
+unsigned long kernelsp[NR_CPUS];
 unsigned long fw_arg0, fw_arg1, fw_arg2, fw_arg3;
 struct cpuinfo_loongarch cpu_data[NR_CPUS] __read_mostly;
 
@@ -92,7 +95,6 @@ void __init detect_memory_region(phys_addr_t start, phys_addr_t sz_min, phys_add
  * Manage initrd
  */
 #ifdef CONFIG_BLK_DEV_INITRD
-
 static int __init rd_start_early(char *p)
 {
 	unsigned long start = memparse(p, &p);
@@ -318,11 +320,9 @@ static void __init arch_mem_init(char **cmdline_p)
 	memblock_set_bottom_up(false);
 	sparse_init();
 	memblock_set_bottom_up(true);
-
 	plat_swiotlb_setup();
 
 	dma_contiguous_reserve(PFN_PHYS(max_low_pfn));
-
 	memblock_dump_all();
 
 	early_memtest(PFN_PHYS(ARCH_PFN_OFFSET), PFN_PHYS(max_low_pfn));
@@ -393,12 +393,18 @@ static void __init prefill_possible_map(void)
 #else
 static inline void prefill_possible_map(void) {}
 #endif
+#ifdef CONFIG_EARLY_PRINTK
+extern void setup_early_printk(void);
+#endif
 
 void __init setup_arch(char **cmdline_p)
 {
 	cpu_probe();
-
 	early_init();
+
+#ifdef CONFIG_EARLY_PRINTK
+	setup_early_printk();
+#endif
 	bootcmdline_init(cmdline_p);
 
 	init_initrd();
@@ -409,7 +415,9 @@ void __init setup_arch(char **cmdline_p)
 	arch_mem_init(cmdline_p);
 
 	resource_init();
+#ifdef CONFIG_SMP
 	plat_smp_setup();
+#endif
 	prefill_possible_map();
 
 	cpu_cache_init();
diff --git a/arch/loongarch/kernel/switch.S b/arch/loongarch/kernel/switch.S
index 0955d9938044..033ddd359313 100644
--- a/arch/loongarch/kernel/switch.S
+++ b/arch/loongarch/kernel/switch.S
@@ -18,15 +18,15 @@
 	.align	5
 SYM_FUNC_START(resume)
 	csrrd	t1, LOONGARCH_CSR_PRMD
-	stptr.d	t1, a0, THREAD_CSRPRMD
+	LONG_SPTR	t1, a0, THREAD_CSRPRMD
 	csrrd	t1, LOONGARCH_CSR_CRMD
-	stptr.d	t1, a0, THREAD_CSRCRMD
+	LONG_SPTR	t1, a0, THREAD_CSRCRMD
 	csrrd	t1, LOONGARCH_CSR_ECFG
-	stptr.d	t1, a0, THREAD_CSRECFG
+	LONG_SPTR	t1, a0, THREAD_CSRECFG
 	csrrd	t1, LOONGARCH_CSR_EUEN
-	stptr.d	t1, a0, THREAD_CSREUEN
+	LONG_SPTR	t1, a0, THREAD_CSREUEN
 	cpu_save_nonscratch a0
-	stptr.d	ra, a0, THREAD_REG01
+	LONG_SPTR	ra, a0, THREAD_REG01
 
 	/*
 	 * The order of restoring the registers takes care of the race
@@ -39,9 +39,9 @@ SYM_FUNC_START(resume)
 	PTR_ADDU	t0, t0, tp
 	set_saved_sp	t0, t1, t2
 
-	ldptr.d	t1, a1, THREAD_CSRPRMD
+	LONG_LPTR	t1, a1, THREAD_CSRPRMD
 	csrwr	t1, LOONGARCH_CSR_PRMD
-	ldptr.d	t1, a1, THREAD_CSREUEN
+	LONG_LPTR	t1, a1, THREAD_CSREUEN
 	csrwr	t1, LOONGARCH_CSR_EUEN
 
 	jr	ra
diff --git a/arch/loongarch/kernel/syscall.c b/arch/loongarch/kernel/syscall.c
index 63da5e2d90f4..f30188978023 100644
--- a/arch/loongarch/kernel/syscall.c
+++ b/arch/loongarch/kernel/syscall.c
@@ -30,6 +30,7 @@
 
 #define __str2(x) #x
 #define __str(x) __str2(x)
+
 #define save_static(symbol)                            \
 __asm__(                                               \
        ".text\n\t"                                     \
@@ -37,15 +38,15 @@ __asm__(                                               \
        ".align\t2\n\t"                                 \
        ".type\t__" #symbol ", @function\n\t"           \
 	"__"#symbol":\n\t"                             \
-       "st.d\t$r23,$r3,"__str(PT_R23)"\n\t"            \
-       "st.d\t$r24,$r3,"__str(PT_R24)"\n\t"            \
-       "st.d\t$r25,$r3,"__str(PT_R25)"\n\t"            \
-       "st.d\t$r26,$r3,"__str(PT_R26)"\n\t"            \
-       "st.d\t$r27,$r3,"__str(PT_R27)"\n\t"            \
-       "st.d\t$r28,$r3,"__str(PT_R28)"\n\t"            \
-       "st.d\t$r29,$r3,"__str(PT_R29)"\n\t"            \
-       "st.d\t$r30,$r3,"__str(PT_R30)"\n\t"            \
-       "st.d\t$r31,$r3,"__str(PT_R31)"\n\t"            \
+       __str(LONG_S)"\t$r23,$r3,"__str(PT_R23)"\n\t"            \
+       __str(LONG_S)"\t$r24,$r3,"__str(PT_R24)"\n\t"            \
+       __str(LONG_S)"\t$r25,$r3,"__str(PT_R25)"\n\t"            \
+       __str(LONG_S)"\t$r26,$r3,"__str(PT_R26)"\n\t"            \
+       __str(LONG_S)"\t$r27,$r3,"__str(PT_R27)"\n\t"            \
+       __str(LONG_S)"\t$r28,$r3,"__str(PT_R28)"\n\t"            \
+       __str(LONG_S)"\t$r29,$r3,"__str(PT_R29)"\n\t"            \
+       __str(LONG_S)"\t$r30,$r3,"__str(PT_R30)"\n\t"            \
+       __str(LONG_S)"\t$r31,$r3,"__str(PT_R31)"\n\t"            \
        "b\t" #symbol "\n\t"                            \
        ".size\t__" #symbol",. - __" #symbol)
 
diff --git a/arch/loongarch/kernel/time.c b/arch/loongarch/kernel/time.c
index 3a645f0f59ed..4719310fb379 100644
--- a/arch/loongarch/kernel/time.c
+++ b/arch/loongarch/kernel/time.c
@@ -17,11 +17,10 @@
 #include <asm/loongarchregs.h>
 #include <asm/time.h>
 
-u64 cpu_clock_freq;
-EXPORT_SYMBOL(cpu_clock_freq);
 u64 const_clock_freq;
 EXPORT_SYMBOL(const_clock_freq);
-
+u64 cpu_clock_freq;
+EXPORT_SYMBOL(cpu_clock_freq);
 static DEFINE_SPINLOCK(state_lock);
 static DEFINE_PER_CPU(struct clock_event_device, constant_clockevent_device);
 
@@ -65,12 +64,14 @@ static int constant_set_state_oneshot_stopped(struct clock_event_device *evt)
 
 static int constant_set_state_periodic(struct clock_event_device *evt)
 {
-	unsigned long period;
+	u64 period;
 	unsigned long timer_config;
 
 	spin_lock(&state_lock);
 
-	period = const_clock_freq / HZ;
+	period = const_clock_freq;
+	do_div(period, HZ);
+
 	timer_config = period & CSR_TCFG_VAL;
 	timer_config |= (CSR_TCFG_PERIOD | CSR_TCFG_EN);
 	csr_writeq(timer_config, LOONGARCH_CSR_TCFG);
@@ -98,7 +99,7 @@ static int constant_timer_next_event(unsigned long delta, struct clock_event_dev
 
 static unsigned long __init get_loops_per_jiffy(void)
 {
-	unsigned long lpj = (unsigned long)const_clock_freq;
+	u64 lpj = const_clock_freq;
 
 	do_div(lpj, HZ);
 
@@ -128,30 +129,20 @@ unsigned long calibrate_delay_is_known(void)
 }
 #endif
 
-static long init_timeval;
-
-void sync_counter(void)
-{
-	/* Ensure counter begin at 0 */
-	csr_writeq(-init_timeval, LOONGARCH_CSR_CNTC);
-}
-
 int constant_clockevent_init(void)
 {
 	unsigned int irq;
 	unsigned int cpu = smp_processor_id();
 	unsigned long min_delta = 0x600;
-	unsigned long max_delta = (1UL << 48) - 1;
+	unsigned long max_delta = (1ULL << 31) - 1;
 	struct clock_event_device *cd;
 	static int timer_irq_installed = 0;
 
 	irq = LOONGSON_TIMER_IRQ;
 
 	cd = &per_cpu(constant_clockevent_device, cpu);
-
 	cd->name = "Constant";
-	cd->features = CLOCK_EVT_FEAT_ONESHOT | CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_PERCPU;
-
+	cd->features = CLOCK_EVT_FEAT_ONESHOT;
 	cd->irq = irq;
 	cd->rating = 320;
 	cd->cpumask = cpumask_of(cpu);
@@ -169,11 +160,10 @@ int constant_clockevent_init(void)
 
 	timer_irq_installed = 1;
 
-	sync_counter();
-
 	if (request_irq(irq, constant_timer_interrupt, IRQF_PERCPU | IRQF_TIMER, "timer", NULL))
 		pr_err("Failed to request irq %d (timer)\n", irq);
 
+	set_csr_ecfg(0x800);
 	lpj_fine = get_loops_per_jiffy();
 	pr_info("Constant clock event device register\n");
 
@@ -187,7 +177,7 @@ static u64 read_const_counter(struct clocksource *clk)
 
 static struct clocksource clocksource_const = {
 	.name = "Constant",
-	.rating = 400,
+	.rating = 320,
 	.read = read_const_counter,
 	.mask = CLOCKSOURCE_MASK(64),
 	.flags = CLOCK_SOURCE_IS_CONTINUOUS,
@@ -195,28 +185,9 @@ static struct clocksource clocksource_const = {
 	.shift = 10,
 };
 
-unsigned long long notrace sched_clock(void)
+u64 native_sched_clock(void)
 {
-	/* 64-bit arithmetic can overflow, so use 128-bit. */
-	u64 t1, t2, t3;
-	unsigned long long rv;
-	u64 mult = clocksource_const.mult;
-	u64 shift = clocksource_const.shift;
-	u64 cnt = read_const_counter(NULL);
-
-	__asm__ (
-		"nor		%[t1], $r0, %[shift]	\n\t"
-		"mulh.du	%[t2], %[cnt], %[mult]	\n\t"
-		"mul.d		%[t3], %[cnt], %[mult]	\n\t"
-		"slli.d		%[t2], %[t2], 1		\n\t"
-		"srl.d		%[rv], %[t3], %[shift]	\n\t"
-		"sll.d		%[t1], %[t2], %[t1]	\n\t"
-		"or		%[rv], %[t1], %[rv]	\n\t"
-		: [rv] "=&r" (rv), [t1] "=&r" (t1), [t2] "=&r" (t2), [t3] "=&r" (t3)
-		: [cnt] "r" (cnt), [mult] "r" (mult), [shift] "r" (shift)
-		: );
-
-	return rv;
+	return read_const_counter(NULL);
 }
 
 int __init constant_clocksource_init(void)
@@ -231,6 +202,8 @@ int __init constant_clocksource_init(void)
 
 	res = clocksource_register_hz(&clocksource_const, freq);
 
+	sched_clock_register(native_sched_clock, 64, freq);
+
 	pr_info("Constant clock source device register\n");
 
 	return res;
@@ -243,8 +216,6 @@ void __init time_init(void)
 	else
 		const_clock_freq = calc_const_freq();
 
-	init_timeval = drdtime() - csr_readq(LOONGARCH_CSR_CNTC);
-
 	constant_clockevent_init();
 	constant_clocksource_init();
 }
diff --git a/arch/loongarch/kernel/topology.c b/arch/loongarch/kernel/topology.c
index ae5f0e5414a3..ab1a75c0b5a6 100644
--- a/arch/loongarch/kernel/topology.c
+++ b/arch/loongarch/kernel/topology.c
@@ -37,11 +37,6 @@ static int __init topology_init(void)
 {
 	int i, ret;
 
-#ifdef CONFIG_NUMA
-	for_each_online_node(i)
-		register_one_node(i);
-#endif /* CONFIG_NUMA */
-
 	for_each_present_cpu(i) {
 		struct cpu *c = &per_cpu(cpu_devices, i);
 
diff --git a/arch/loongarch/kernel/traps.c b/arch/loongarch/kernel/traps.c
index d180eacaaefa..2fda19fa61c6 100644
--- a/arch/loongarch/kernel/traps.c
+++ b/arch/loongarch/kernel/traps.c
@@ -58,7 +58,7 @@ extern asmlinkage void handle_lsx(void);
 extern asmlinkage void handle_lasx(void);
 extern asmlinkage void handle_reserved(void);
 extern asmlinkage void handle_watch(void);
-
+extern asmlinkage void except_vec_vi_handler(void);
 extern void *vi_table[];
 static vi_handler_t ip_handlers[EXCCODE_INT_NUM];
 
@@ -200,9 +200,6 @@ static void __show_regs(const struct pt_regs *regs)
 
 	if (exccode >= EXCCODE_TLBL && exccode <= EXCCODE_ALE)
 		printk("BadVA : %0*lx\n", field, regs->csr_badvaddr);
-
-	printk("PrId  : %08x (%s)\n", read_cpucfg(LOONGARCH_CPUCFG0),
-	       cpu_family_string());
 }
 
 void show_regs(struct pt_regs *regs)
@@ -601,9 +598,8 @@ extern void cache_error_setup(void);
 
 static void configure_exception_vector(void)
 {
-	csr_writeq(eentry, LOONGARCH_CSR_EENTRY);
-	csr_writeq(eentry, LOONGARCH_CSR_MERRENTRY);
-	csr_writeq(tlbrentry, LOONGARCH_CSR_TLBRENTRY);
+	csr_writel(eentry + 0x4000, LOONGARCH_CSR_EENTRY);
+	csr_writel( (tlbrentry & 0x0fffffff), LOONGARCH_CSR_TLBRENTRY);
 }
 
 void __init boot_cpu_trap_init(void)
@@ -613,6 +609,7 @@ void __init boot_cpu_trap_init(void)
 	memblock_set_bottom_up(true);
 	eentry = (unsigned long)memblock_alloc(size, 1 << fls(size));
 	tlbrentry = (unsigned long)memblock_alloc(PAGE_SIZE, PAGE_SIZE);
+	printk("eentry = 0x%lx,tlbrentry = 0x%lx", eentry, tlbrentry);
 	memblock_set_bottom_up(false);
 
 	setup_vint_size(vec_size);
@@ -692,6 +689,8 @@ void __init trap_init(void)
 		set_handler(i * vec_size, vec_start, vec_size);
 	}
 
+	set_handler(EXCCODE_GENERIC * vec_size , except_vec_vi_handler, vec_size);
+
 	set_handler(EXCCODE_TLBL * vec_size, handle_tlb_load, vec_size);
 	set_handler(EXCCODE_TLBS * vec_size, handle_tlb_store, vec_size);
 	set_handler(EXCCODE_TLBI * vec_size, handle_tlb_load, vec_size);
diff --git a/arch/loongarch/kernel/unaligned.c b/arch/loongarch/kernel/unaligned.c
index 630a7bdb57ce..38a6be4dfec3 100644
--- a/arch/loongarch/kernel/unaligned.c
+++ b/arch/loongarch/kernel/unaligned.c
@@ -23,6 +23,9 @@
 
 #include "access-helper.h"
 
+extern unsigned long unaligned_read(void *addr, void *value, unsigned long n, bool symbol);
+extern unsigned long unaligned_write(void *addr, unsigned long value, unsigned long n);
+
 static inline void write_fpr(unsigned int fd, unsigned long value)
 {
 #define WRITE_FPR(fd, value)		\
@@ -274,32 +277,32 @@ static void emulate_load_store_insn(struct pt_regs *regs, void __user *addr, uns
 	if (insn.reg2i12_format.opcode == ldd_op ||
 		insn.reg2i14_format.opcode == ldptrd_op ||
 		insn.reg3_format.opcode == ldxd_op) {
-		LoadDW(addr, value, res);
+		res = unaligned_read(addr, &value, 8, 1);
 		if (res)
 			goto fault;
 		regs->regs[insn.reg2i12_format.rd] = value;
 	} else if (insn.reg2i12_format.opcode == ldw_op ||
 		insn.reg2i14_format.opcode == ldptrw_op ||
 		insn.reg3_format.opcode == ldxw_op) {
-		LoadW(addr, value, res);
+		res = unaligned_read(addr, &value, 4, 1);
 		if (res)
 			goto fault;
 		regs->regs[insn.reg2i12_format.rd] = value;
 	} else if (insn.reg2i12_format.opcode == ldwu_op ||
 		insn.reg3_format.opcode == ldxwu_op) {
-		LoadWU(addr, value, res);
+		res = unaligned_read(addr, &value, 4, 0);
 		if (res)
 			goto fault;
 		regs->regs[insn.reg2i12_format.rd] = value;
 	} else if (insn.reg2i12_format.opcode == ldh_op ||
 		insn.reg3_format.opcode == ldxh_op) {
-		LoadHW(addr, value, res);
+		res = unaligned_read(addr, &value, 2, 1);
 		if (res)
 			goto fault;
 		regs->regs[insn.reg2i12_format.rd] = value;
 	} else if (insn.reg2i12_format.opcode == ldhu_op ||
 		insn.reg3_format.opcode == ldxhu_op) {
-		LoadHWU(addr, value, res);
+		res = unaligned_read(addr, &value, 2, 0);
 		if (res)
 			goto fault;
 		regs->regs[insn.reg2i12_format.rd] = value;
@@ -307,44 +310,44 @@ static void emulate_load_store_insn(struct pt_regs *regs, void __user *addr, uns
 		insn.reg2i14_format.opcode == stptrd_op ||
 		insn.reg3_format.opcode == stxd_op) {
 		value = regs->regs[insn.reg2i12_format.rd];
-		StoreDW(addr, value, res);
+		res = unaligned_write(addr, value, 8);
 		if (res)
 			goto fault;
 	} else if (insn.reg2i12_format.opcode == stw_op ||
 		insn.reg2i14_format.opcode == stptrw_op ||
 		insn.reg3_format.opcode == stxw_op) {
 		value = regs->regs[insn.reg2i12_format.rd];
-		StoreW(addr, value, res);
+		res = unaligned_write(addr, value, 4);
 		if (res)
 			goto fault;
 	} else if (insn.reg2i12_format.opcode == sth_op ||
 		insn.reg3_format.opcode == stxh_op) {
 		value = regs->regs[insn.reg2i12_format.rd];
-		StoreHW(addr, value, res);
+		res = unaligned_write(addr, value, 2);
 		if (res)
 			goto fault;
 	} else if (insn.reg2i12_format.opcode == fldd_op ||
 		insn.reg3_format.opcode == fldxd_op) {
-		LoadDW(addr, value, res);
+		res = unaligned_read(addr, &value, 8, 1);
 		if (res)
 			goto fault;
 		write_fpr(insn.reg2i12_format.rd, value);
 	} else if (insn.reg2i12_format.opcode == flds_op ||
 		insn.reg3_format.opcode == fldxs_op) {
-		LoadW(addr, value, res);
+		res = unaligned_read(addr, &value, 4, 1);
 		if (res)
 			goto fault;
 		write_fpr(insn.reg2i12_format.rd, value);
 	} else if (insn.reg2i12_format.opcode == fstd_op ||
 		insn.reg3_format.opcode == fstxd_op) {
 		value = read_fpr(insn.reg2i12_format.rd);
-		StoreDW(addr, value, res);
+		res = unaligned_write(addr, value, 8);
 		if (res)
 			goto fault;
 	} else if (insn.reg2i12_format.opcode == fsts_op ||
 		insn.reg3_format.opcode == fstxs_op) {
 		value = read_fpr(insn.reg2i12_format.rd);
-		StoreW(addr, value, res);
+		res = unaligned_write(addr, value, 4);
 		if (res)
 			goto fault;
 	} else
diff --git a/arch/loongarch/lib/Makefile b/arch/loongarch/lib/Makefile
index 7f32f3e4a6ec..08a570de2cfe 100644
--- a/arch/loongarch/lib/Makefile
+++ b/arch/loongarch/lib/Makefile
@@ -4,4 +4,6 @@
 #
 
 lib-y	+= delay.o memset.o memcpy.o memmove.o \
-	   clear_user.o copy_user.o dump_tlb.o
+	   clear_user.o copy_user.o unaligned.o
+
+obj-y += bswapsi.o bswapdi.o
diff --git a/arch/loongarch/lib/bswapdi.c b/arch/loongarch/lib/bswapdi.c
new file mode 100644
index 000000000000..fcef74084492
--- /dev/null
+++ b/arch/loongarch/lib/bswapdi.c
@@ -0,0 +1,17 @@
+// SPDX-License-Identifier: GPL-2.0
+#include <linux/export.h>
+#include <linux/compiler.h>
+
+unsigned long long notrace __bswapdi2(unsigned long long u)
+{
+	return (((u) & 0xff00000000000000ull) >> 56) |
+	       (((u) & 0x00ff000000000000ull) >> 40) |
+	       (((u) & 0x0000ff0000000000ull) >> 24) |
+	       (((u) & 0x000000ff00000000ull) >>  8) |
+	       (((u) & 0x00000000ff000000ull) <<  8) |
+	       (((u) & 0x0000000000ff0000ull) << 24) |
+	       (((u) & 0x000000000000ff00ull) << 40) |
+	       (((u) & 0x00000000000000ffull) << 56);
+}
+
+EXPORT_SYMBOL(__bswapdi2);
diff --git a/arch/loongarch/lib/bswapsi.c b/arch/loongarch/lib/bswapsi.c
new file mode 100644
index 000000000000..22d8e4f6d66e
--- /dev/null
+++ b/arch/loongarch/lib/bswapsi.c
@@ -0,0 +1,13 @@
+// SPDX-License-Identifier: GPL-2.0
+#include <linux/export.h>
+#include <linux/compiler.h>
+
+unsigned int notrace __bswapsi2(unsigned int u)
+{
+	return (((u) & 0xff000000) >> 24) |
+	       (((u) & 0x00ff0000) >>  8) |
+	       (((u) & 0x0000ff00) <<  8) |
+	       (((u) & 0x000000ff) << 24);
+}
+
+EXPORT_SYMBOL(__bswapsi2);
diff --git a/arch/loongarch/lib/clear_user.S b/arch/loongarch/lib/clear_user.S
index 3cc251cc57da..665782c43be7 100644
--- a/arch/loongarch/lib/clear_user.S
+++ b/arch/loongarch/lib/clear_user.S
@@ -23,8 +23,8 @@ SYM_FUNC_START(__clear_user)
 	beqz	a1, 2f
 
 1:	st.b	zero, a0, 0
-	addi.d	a0, a0, 1
-	addi.d	a1, a1, -1
+	LONG_ADDIU	a0, a0, 1
+	LONG_ADDIU	a1, a1, -1
 	bgt	a1, zero, 1b
 
 2:	move	v0, a1
diff --git a/arch/loongarch/lib/copy_user.S b/arch/loongarch/lib/copy_user.S
index 5a5d7a25995a..d8e40305d6b0 100644
--- a/arch/loongarch/lib/copy_user.S
+++ b/arch/loongarch/lib/copy_user.S
@@ -25,9 +25,9 @@ SYM_FUNC_START(__copy_user)
 
 1:	ld.b	t0, a1, 0
 2:	st.b	t0, a0, 0
-	addi.d	a0, a0, 1
-	addi.d	a1, a1, 1
-	addi.d	a2, a2, -1
+	LONG_ADDIU	a0, a0, 1
+	LONG_ADDIU	a1, a1, 1
+	LONG_ADDIU	a2, a2, -1
 	bgt	a2, zero, 1b
 
 3:	move	v0, a2
diff --git a/arch/loongarch/lib/memcpy.S b/arch/loongarch/lib/memcpy.S
index e94899d99624..c02480e07d95 100644
--- a/arch/loongarch/lib/memcpy.S
+++ b/arch/loongarch/lib/memcpy.S
@@ -6,7 +6,7 @@
 #include <asm/asmmacro.h>
 #include <asm/export.h>
 #include <asm/regdef.h>
-
+#include <asm/asm.h>
 /*
  * void *memcpy(void *dst, const void *src, size_t n)
  *
@@ -20,9 +20,9 @@ SYM_FUNC_START(memcpy)
 
 1:	ld.b	t0, a1, 0
 	st.b	t0, a0, 0
-	addi.d	a0, a0, 1
-	addi.d	a1, a1, 1
-	addi.d	a2, a2, -1
+	LONG_ADDIU	a0, a0, 1
+	LONG_ADDIU	a1, a1, 1
+	LONG_ADDIU	a2, a2, -1
 	bgt	a2, zero, 1b
 
 2:	move	v0, a3
diff --git a/arch/loongarch/lib/memmove.S b/arch/loongarch/lib/memmove.S
index f55d8dcd09dd..37b453e5b3e4 100644
--- a/arch/loongarch/lib/memmove.S
+++ b/arch/loongarch/lib/memmove.S
@@ -6,6 +6,7 @@
 #include <asm/asmmacro.h>
 #include <asm/export.h>
 #include <asm/regdef.h>
+#include <asm/asm.h>
 
 /*
  * void *rmemcpy(void *dst, const void *src, size_t n)
@@ -18,14 +19,14 @@ SYM_FUNC_START(rmemcpy)
 	move	a3, a0
 	beqz	a2, 2f
 
-	add.d	a0, a0, a2
-	add.d	a1, a1, a2
+	INT_ADDU	a0, a0, a2
+	INT_ADDU	a1, a1, a2
 
 1:	ld.b	t0, a1, -1
 	st.b	t0, a0, -1
-	addi.d	a0, a0, -1
-	addi.d	a1, a1, -1
-	addi.d	a2, a2, -1
+	INT_ADDIU	a0, a0, -1
+	INT_ADDIU	a1, a1, -1
+	INT_ADDIU	a2, a2, -1
 	bgt	a2, zero, 1b
 
 2:	move	v0, a3
diff --git a/arch/loongarch/lib/memset.S b/arch/loongarch/lib/memset.S
index f599017e68fd..0bed5709f754 100644
--- a/arch/loongarch/lib/memset.S
+++ b/arch/loongarch/lib/memset.S
@@ -6,6 +6,7 @@
 #include <asm/asmmacro.h>
 #include <asm/export.h>
 #include <asm/regdef.h>
+#include <asm/asm.h>
 
 /*
  * void *memset(void *s, int c, size_t n)
@@ -19,8 +20,8 @@ SYM_FUNC_START(memset)
 	beqz	a2, 2f
 
 1:	st.b	a1, a0, 0
-	addi.d	a0, a0, 1
-	addi.d	a2, a2, -1
+	INT_ADDIU	a0, a0, 1
+	INT_ADDIU	a2, a2, -1
 	bgt	a2, zero, 1b
 
 2:	move	v0, a3
diff --git a/arch/loongarch/lib/strncpy_user.S b/arch/loongarch/lib/strncpy_user.S
index b42d81045929..cbe9bdf259a2 100644
--- a/arch/loongarch/lib/strncpy_user.S
+++ b/arch/loongarch/lib/strncpy_user.S
@@ -25,11 +25,11 @@ SYM_FUNC_START(__strncpy_from_user)
 
 1:	ld.b	t0, a1, 0
 	st.b	t0, a0, 0
-	addi.d	a0, a0, 1
-	addi.d	a1, a1, 1
+	INT_ADDIU	a0, a0, 1
+	INT_ADDIU	a1, a1, 1
 	beqz	t0, 2f
 
-	addi.d	a3, a3, 1
+	INT_ADDIU	a3, a3, 1
 	blt	a3, a2, 1b
 
 	/*
diff --git a/arch/loongarch/lib/strnlen_user.S b/arch/loongarch/lib/strnlen_user.S
index 9288a5ad294e..9bbfe11e981f 100644
--- a/arch/loongarch/lib/strnlen_user.S
+++ b/arch/loongarch/lib/strnlen_user.S
@@ -22,8 +22,8 @@ SYM_FUNC_START(__strnlen_user)
 	move	a2, zero
 
 1:	ld.b	t0, a0, 0
-	addi.d	a0, a0, 1
-	addi.d	a2, a2, 1
+	INT_ADDIU	a0, a0, 1
+	INT_ADDIU	a2, a2, 1
 	beqz	t0, 2f
 
 	bge	a1, a2, 1b
diff --git a/arch/loongarch/lib/unaligned.S b/arch/loongarch/lib/unaligned.S
new file mode 100644
index 000000000000..e24767c7ae38
--- /dev/null
+++ b/arch/loongarch/lib/unaligned.S
@@ -0,0 +1,97 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2020-2021 Loongson Technology Corporation Limited
+ */
+
+#include <linux/linkage.h>
+
+#include <asm/asm.h>
+#include <asm/asmmacro.h>
+#include <asm/cpu.h>
+#include <asm/export.h>
+#include <asm/regdef.h>
+#include <uapi/asm-generic/errno-base.h>
+
+#define _ASM_EXTABLE(from, to)                  \
+        .section __ex_table, "a";               \
+        PTR     from, to;                       \
+        .previous
+
+/*
+ * unsigned long unaligned_read(void *value, void *addr, unsigned long n, bool symbol)
+ *
+ * a0: addr
+ * a1: value
+ * a2: n
+ * a3: symbol
+ */
+SYM_FUNC_START(unaligned_read)
+	beqz	a2, 4f
+
+	li.w	t1, 8
+	li.w	t2, 0
+
+	addi.w	t0, a2, -1
+	mul.w	t1, t0, t1
+	add.w 	a0, a0, t0
+
+	beq	a3, zero, 2f
+1:	ld.b	t3, a0, 0
+	b	3f
+
+2:	ld.bu	t3, a0, 0
+3:	sll.w	t3, t3, t1
+	or	t2, t2, t3
+	addi.w	t1, t1, -8
+	addi.w	a2, a2, -1
+	addi.w	a0, a0, -1
+	bgt	a2, zero, 2b
+4:	st.w	t2, a1, 0
+
+	move	v0, a2
+	jr	ra
+
+5:	li.w    v0, -EFAULT
+	jr	ra
+
+	.section .fixup, "ax"
+6:	li.w    v0, -EFAULT
+	jr	ra
+	.previous
+
+	_ASM_EXTABLE(1b, 6b)
+	_ASM_EXTABLE(2b, 6b)
+	_ASM_EXTABLE(4b, 6b)
+SYM_FUNC_END(unaligned_read)
+
+/*
+ * unsigned long unaligned_write(void *addr, unsigned long value, unsigned long n)
+ *
+ * a0: addr
+ * a1: value
+ * a2: n
+ */
+SYM_FUNC_START(unaligned_write)
+	beqz	a2, 3f
+
+	li.w	t0, 0
+1:	srl.w	t1, a1, t0
+2:	st.b	t1, a0, 0
+	addi.w	t0, t0, 8
+	addi.w	a2, a2, -1
+	addi.w	a0, a0, 1
+	bgt	a2, zero, 1b
+
+	move	v0, a2
+	jr	ra
+
+3:	li.w    v0, -EFAULT
+	jr	ra
+
+	.section .fixup, "ax"
+4:	li.w    v0, -EFAULT
+	jr	ra
+	.previous
+
+	_ASM_EXTABLE(2b, 4b)
+SYM_FUNC_END(unaligned_write)
diff --git a/arch/loongarch/loongson32/Kconfig b/arch/loongarch/loongson32/Kconfig
new file mode 100644
index 000000000000..7f29be8ccc04
--- /dev/null
+++ b/arch/loongarch/loongson32/Kconfig
@@ -0,0 +1,66 @@
+# SPDX-License-Identifier: GPL-2.0
+#if MACH_LOONGARCH32
+
+choice
+	prompt "Machine Type"
+
+config LOONGSON_MACH3X
+	bool "Generic Loongson 3 family machines"
+	select ARCH_MIGHT_HAVE_PC_PARPORT
+	select ARCH_MIGHT_HAVE_PC_SERIO
+	select GENERIC_ISA_DMA_SUPPORT_BROKEN
+	select BOOT_ELF32
+	select BOARD_SCACHE
+	select CPU_HAS_WB
+	select HAVE_CLK
+	select HW_HAS_PCI
+	select ISA
+	select HT_PCI
+	select IRQ_LOONGISA_CPU
+	select NR_CPUS_DEFAULT_4
+	select SPARSE_IRQ
+	select SYS_HAS_CPU_LOONGSON3
+	select SYS_HAS_EARLY_PRINTK
+	select SYS_SUPPORTS_64BIT_KERNEL
+	select SYS_SUPPORTS_HIGHMEM
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+	select LOONGSON_MC146818
+	select ZONE_DMA32
+	select DMA_MAYBE_COHERENT
+	select LEFI_FIRMWARE_INTERFACE
+	select USE_OF
+	select BUILTIN_DTB
+
+	help
+		Generic Loongson 3 family machines utilize the 3A/3B revision
+		of Loongson processor and LS7A chipset.
+
+config MACH_LOONGSON_32
+	bool "Generic Loongson32 machines"
+	select BOOT_ELF32
+	select CPU_SUPPORTS_CPUFREQ
+	select CPU_HAS_WB
+	select SYS_HAS_EARLY_PRINTK
+#	select SYS_SUPPORTS_HIGHMEM
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+	select HW_HAS_PCI
+	select LEFI_FIRMWARE_INTERFACE
+	select IRQ_LOONGISA_CPU
+	select OF_FLATTREE
+	#select DMA_MAYBE_COHERENT
+
+endchoice
+
+config LOONGSON_UART_BASE
+	bool
+	default y
+	depends on EARLY_PRINTK || SERIAL_8250
+
+config LOONGSON_MC146818
+	bool
+	default n
+
+config LEFI_FIRMWARE_INTERFACE
+	bool
+
+#endif # MACH_LOONGARCH32
diff --git a/arch/loongarch/loongson32/Makefile b/arch/loongarch/loongson32/Makefile
new file mode 100644
index 000000000000..9a48e4063b8e
--- /dev/null
+++ b/arch/loongarch/loongson32/Makefile
@@ -0,0 +1,11 @@
+#
+# All Loongson based systems
+#
+
+obj-y += prom.o setup.o env.o reset.o irq.o mem.o serial.o uart_base.o
+
+obj-$(CONFIG_SMP)	+= smp.o
+
+obj-$(CONFIG_PCI_MSI)	+= msi.o
+
+obj-$(CONFIG_EARLY_PRINTK)	+= early_printk.o
diff --git a/arch/loongarch/loongson32/Platform b/arch/loongarch/loongson32/Platform
new file mode 100644
index 000000000000..8b86ef81be82
--- /dev/null
+++ b/arch/loongarch/loongson32/Platform
@@ -0,0 +1,18 @@
+#
+# Loongson Processors' Support
+#
+#
+
+cflags-$(CONFIG_CPU_LOONGSON3)  += $(call as-option,-Wa$(comma)-mno-fix-loongson3-llsc,)
+cflags-$(CONFIG_CPU_LOONGSON3)  += $(call as-option,-Wa$(comma)-mno-fix-ls3a-llsc,)
+
+
+
+
+#
+# Loongson Machines Support
+#
+
+platform-$(CONFIG_MACH_LOONGSON32) += loongson32/
+cflags-$(CONFIG_MACH_LOONGSON32)   += -I$(srctree)/arch/loongarch/include/asm/mach-loongson32
+load-$(CONFIG_MACH_LOONGSON32)     += 0xa0300000
diff --git a/arch/loongarch/loongson32/early_printk.c b/arch/loongarch/loongson32/early_printk.c
new file mode 100644
index 000000000000..d8a95b7c5f40
--- /dev/null
+++ b/arch/loongarch/loongson32/early_printk.c
@@ -0,0 +1,71 @@
+/*  early printk support
+ *
+ *  Copyright (c) 2009 Philippe Vachon <philippe@cowpig.ca>
+ *  Copyright (c) 2009 Lemote Inc.
+ *  Author: Wu Zhangjin, wuzhangjin@gmail.com
+ *
+ *  This program is free software; you can redistribute	 it and/or modify it
+ *  under  the terms of	 the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the	License, or (at your
+ *  option) any later version.
+ */
+#include <linux/serial_reg.h>
+#include <asm/setup.h>
+
+#include <loongson.h>
+
+#define PORT(base, offset) (u8 *)(base + offset)
+
+static inline unsigned int serial_in(unsigned char *base, int offset)
+{
+	return readb(PORT(base, offset));
+}
+
+static inline void serial_out(unsigned char *base, int offset, int value)
+{
+	writeb(value, PORT(base, offset));
+}
+
+void prom_putchar(char c)
+{
+	int timeout;
+	unsigned char *uart_base;
+
+	uart_base = (unsigned char *)0x9fe001e0;
+	timeout = 1024;
+
+	while (((serial_in(uart_base, UART_LSR) & UART_LSR_THRE) == 0) &&
+			(timeout-- > 0))
+		;
+
+	serial_out(uart_base, UART_TX, c);
+}
+
+void prom_printf(char *fmt, ...)
+{
+	va_list args;
+	/*
+	 * * CONFIG_FRAME_WARN is set to 1024 for Loongson3 platforms. It's
+	 * * value can be modified by the following menuconfig selection:
+	 * *    Kernel Hacking --->
+	 * *       (1024) Warn for stack frames larger than (needs gcc 4.4)
+	 * * We avoid this build check error by forcing stack size under 1024.
+	 * */
+	char ppbuf[1024 - 16];
+	char *bptr;
+
+	va_start(args, fmt);
+	vsprintf(ppbuf, fmt, args);
+
+	bptr = ppbuf;
+
+	while (*bptr != 0) {
+	if (*bptr == '\n')
+		prom_putchar('\r');
+
+	prom_putchar(*bptr++);
+}
+va_end(args);
+}
+EXPORT_SYMBOL_GPL(prom_printf);
+
diff --git a/arch/loongarch/loongson32/env.c b/arch/loongarch/loongson32/env.c
new file mode 100644
index 000000000000..d939dccafe40
--- /dev/null
+++ b/arch/loongarch/loongson32/env.c
@@ -0,0 +1,151 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Author: Huacai Chen <chenhuacai@loongson.cn>
+ *
+ * Copyright (C) 2020-2021 Loongson Technology Corporation Limited
+ */
+#include <linux/export.h>
+#include <linux/acpi.h>
+#include <linux/efi.h>
+#include <asm/fw.h>
+#include <asm/time.h>
+#include <asm/bootinfo.h>
+#include <loongson.h>
+
+struct bootparamsinterface *efi_bp;
+struct loongsonlist_mem_map *loongson_mem_map;
+struct loongsonlist_vbios *pvbios;
+struct loongson_system_configuration loongson_sysconf;
+EXPORT_SYMBOL(loongson_sysconf);
+
+u32 loongson_chipcfg[MAX_PACKAGES] = {0xbfc00180};
+u32 loongson_chiptemp[MAX_PACKAGES];
+u32 loongson_freqctrl[MAX_PACKAGES];
+unsigned long long smp_group[MAX_PACKAGES];
+
+static void __init register_addrs_set(u32 *registers, const u32 addr, int num)
+{
+	u64 i;
+
+	for (i = 0; i < num; i++) {
+		*registers = (i << 44) | addr;
+		registers++;
+	}
+}
+
+static u8 ext_listhdr_checksum(u8 *buffer, u32 length)
+{
+	u8 sum = 0;
+	u8 *end = buffer + length;
+
+	while (buffer < end) {
+		sum = (u8)(sum + *(buffer++));
+	}
+
+	return (sum);
+}
+
+static int parse_mem(struct _extention_list_hdr *head)
+{
+	loongson_mem_map = (struct loongsonlist_mem_map *)head;
+	if (ext_listhdr_checksum((u8 *)loongson_mem_map, head->length)) {
+		pr_warn("mem checksum error\n");
+		return -EPERM;
+	}
+
+	return 0;
+}
+
+static int parse_vbios(struct _extention_list_hdr *head)
+{
+	pvbios = (struct loongsonlist_vbios *)head;
+
+	if (ext_listhdr_checksum((u8 *)pvbios, head->length)) {
+		pr_warn("vbios_addr checksum error\n");
+		return -EPERM;
+	}
+
+	loongson_sysconf.vgabios_addr = pvbios->vbios_addr;
+
+	return 0;
+}
+
+static int parse_screeninfo(struct _extention_list_hdr *head)
+{
+	struct loongsonlist_screeninfo *pscreeninfo;
+
+	pscreeninfo = (struct loongsonlist_screeninfo *)head;
+	if (ext_listhdr_checksum((u8 *)pscreeninfo, head->length)) {
+		pr_warn("screeninfo_addr checksum error\n");
+		return -EPERM;
+	}
+
+	memcpy(&screen_info, &pscreeninfo->si, sizeof(screen_info));
+
+	return 0;
+}
+
+static int list_find(struct _extention_list_hdr *head)
+{
+	struct _extention_list_hdr *fhead = head;
+
+	if (fhead == NULL) {
+		pr_warn("the link is empty!\n");
+		return -1;
+	}
+
+	while (fhead != NULL) {
+		if (memcmp(&(fhead->signature), LOONGSON_MEM_LINKLIST, 3) == 0) {
+			if (parse_mem(fhead) != 0) {
+				pr_warn("parse mem failed\n");
+				return -EPERM;
+			}
+		} else if (memcmp(&(fhead->signature), LOONGSON_VBIOS_LINKLIST, 5) == 0) {
+			if (parse_vbios(fhead) != 0) {
+				pr_warn("parse vbios failed\n");
+				return -EPERM;
+			}
+		} else if (memcmp(&(fhead->signature), LOONGSON_SCREENINFO_LINKLIST, 5) == 0) {
+			if (parse_screeninfo(fhead) != 0) {
+				pr_warn("parse screeninfo failed\n");
+				return -EPERM;
+			}
+		}
+		fhead = fhead->next;
+	}
+
+	return 0;
+}
+
+static int get_bpi_version(void *signature)
+{
+	return 1;
+}
+
+void __init fw_init_environ(void)
+{
+	efi_bp = (struct bootparamsinterface *)_fw_envp;
+	loongson_sysconf.bpi_ver = get_bpi_version(&efi_bp->signature);
+
+#ifdef CONFIG_SMP
+	register_addrs_set(smp_group, TO_UNCAC(0x1fe01000), 16);
+#endif
+	register_addrs_set(loongson_chipcfg, TO_UNCAC(0x1fe00180), 4);
+	register_addrs_set(loongson_chiptemp, TO_UNCAC(0x1fe0019c), 4);
+	register_addrs_set(loongson_freqctrl, TO_UNCAC(0x1fe001d0), 4);
+
+	if (list_find(efi_bp->extlist))
+		pr_warn("Scan bootparam failed\n");
+}
+
+static int __init init_cpu_fullname(void)
+{
+	int cpu;
+
+	if (loongson_sysconf.cpuname && !strncmp(loongson_sysconf.cpuname, "Loongson", 8)) {
+		for (cpu = 0; cpu < NR_CPUS; cpu++)
+			__cpu_full_name[cpu] = loongson_sysconf.cpuname;
+	}
+	return 0;
+}
+arch_initcall(init_cpu_fullname);
diff --git a/arch/loongarch/loongson32/irq.c b/arch/loongarch/loongson32/irq.c
new file mode 100644
index 000000000000..f5a907f0e60c
--- /dev/null
+++ b/arch/loongarch/loongson32/irq.c
@@ -0,0 +1,96 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2020-2021 Loongson Technology Corporation Limited
+ */
+#include <linux/compiler.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/irqchip.h>
+#include <linux/irqdomain.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/stddef.h>
+#include <asm/irq.h>
+#include <asm/setup.h>
+#include <asm/loongarchregs.h>
+#include <loongson.h>
+
+struct acpi_madt_lio_pic *acpi_liointc;
+struct acpi_madt_eio_pic *acpi_eiointc;
+struct acpi_madt_ht_pic *acpi_htintc;
+struct acpi_madt_lpc_pic *acpi_pchlpc;
+struct acpi_madt_msi_pic *acpi_pchmsi;
+struct acpi_madt_bio_pic *acpi_pchpic[MAX_PCH_PICS];
+
+struct fwnode_handle *acpi_liointc_handle;
+struct fwnode_handle *acpi_msidomain_handle;
+struct fwnode_handle *acpi_picdomain_handle[MAX_PCH_PICS];
+
+void mach_irq_dispatch(unsigned int pending)
+{
+        if (pending & 0x800)
+		do_IRQ(LOONGSON_TIMER_IRQ);
+	if (pending & 0x20)
+		do_IRQ(4);
+	if (pending & 0x4)
+		do_IRQ(LOONGSON_BRIDGE_IRQ) ; //in fact , it's for ehternet
+	if (pending & 0x8)
+		do_IRQ(LOONGSON_LINTC_IRQ);
+}
+
+asmlinkage void plat_irq_dispatch(void)
+{
+	unsigned int pending;
+	pending = read_csr_estat() & read_csr_ecfg();
+	/* machine-specific plat_irq_dispatch */
+	mach_irq_dispatch(pending);
+}
+
+int find_pch_pic(u32 gsi)
+{
+	int i, start, end;
+
+	/* Find the PCH_PIC that manages this GSI. */
+	for (i = 0; i < loongson_sysconf.nr_pch_pics; i++) {
+		struct acpi_madt_bio_pic *irq_cfg = acpi_pchpic[i];
+
+		start = irq_cfg->gsi_base;
+		end   = irq_cfg->gsi_base + irq_cfg->size;
+		if (gsi >= start && gsi < end)
+			return i;
+	}
+
+	pr_err("ERROR: Unable to locate PCH_PIC for GSI %d\n", gsi);
+	return -1;
+}
+
+void __init setup_IRQ(void)
+{
+	irqchip_init();
+}
+
+static inline void mask_loongson_irq(struct irq_data *d) { }
+static inline void unmask_loongson_irq(struct irq_data *d) { }
+
+static struct irq_chip loongson_irq_chip = {
+	.name           = "Loongson",
+	.irq_ack        = mask_loongson_irq,
+	.irq_mask       = mask_loongson_irq,
+	.irq_mask_ack   = mask_loongson_irq,
+	.irq_unmask     = unmask_loongson_irq,
+	.irq_eoi        = unmask_loongson_irq,
+};
+
+
+void __init arch_init_irq(void)
+{
+	clear_csr_ecfg(ECFG0_IM);
+	clear_csr_estat(ESTATF_IP);
+
+	setup_IRQ();
+	irq_set_chip_and_handler(LOONGSON_LINTC_IRQ,
+			&loongson_irq_chip, handle_percpu_irq);
+
+	set_csr_ecfg(ECFGF_IP0 | ECFGF_IP1 |ECFGF_IP2 | ECFGF_IP3| ECFGF_IPI | ECFGF_PC);
+}
diff --git a/arch/loongarch/loongson32/mem.c b/arch/loongarch/loongson32/mem.c
new file mode 100644
index 000000000000..42e663a4527f
--- /dev/null
+++ b/arch/loongarch/loongson32/mem.c
@@ -0,0 +1,105 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2020-2021 Loongson Technology Corporation Limited
+ */
+#include <linux/fs.h>
+#include <linux/mm.h>
+#include <linux/memblock.h>
+
+#include <asm/bootinfo.h>
+#include <asm/sections.h>
+
+#include <loongson.h>
+#include <boot_param.h>
+
+extern struct loongsonlist_mem_map *loongson_mem_map;
+
+void __init memblock_remove_mem(void)
+{
+	int i;
+	u32 mem_start, mem_size;
+
+	for (i = 0; i < loongson_mem_map->map_count; i++) {
+		mem_start = loongson_mem_map->map[i].mem_start;
+		mem_size = loongson_mem_map->map[i].mem_size;
+
+		memblock_remove(mem_start, mem_size);
+	}
+}
+
+void __init early_memblock_init(void)
+{
+	int i;
+	u32 mem_type;
+	u32 mem_start, mem_end, mem_size;
+
+	if (!loongson_mem_map)
+                return;
+
+	/* parse memory information */
+	for (i = 0; i < loongson_mem_map->map_count; i++) {
+		mem_type = loongson_mem_map->map[i].mem_type;
+		mem_start = loongson_mem_map->map[i].mem_start;
+		mem_size = loongson_mem_map->map[i].mem_size;
+		mem_end = mem_start + mem_size;
+
+		switch (mem_type) {
+		case ADDRESS_TYPE_SYSRAM:
+			memblock_add(mem_start, mem_size);
+			if (max_low_pfn < (mem_end >> PAGE_SHIFT))
+				max_low_pfn = mem_end >> PAGE_SHIFT;
+			break;
+		}
+	}
+	memblock_set_current_limit(PFN_PHYS(max_low_pfn));
+}
+
+void __init fw_init_memory(void)
+{
+	int i;
+	u32 mem_type;
+	u32 mem_start, mem_end, mem_size;
+	unsigned long start_pfn, end_pfn;
+	static unsigned long num_physpages;
+
+	/* parse memory information */
+	for (i = 0; i < loongson_mem_map->map_count; i++) {
+		mem_type = loongson_mem_map->map[i].mem_type;
+		mem_start = loongson_mem_map->map[i].mem_start;
+		mem_size = loongson_mem_map->map[i].mem_size;
+		mem_end = mem_start + mem_size;
+
+		switch (mem_type) {
+		case ADDRESS_TYPE_SYSRAM:
+			mem_start = PFN_ALIGN(mem_start);
+			mem_end = PFN_ALIGN(mem_end - PAGE_SIZE + 1);
+			num_physpages += (mem_size >> PAGE_SHIFT);
+			memblock_add(loongson_mem_map->map[i].mem_start,
+				     loongson_mem_map->map[i].mem_size);
+			memblock_set_node(mem_start, mem_size, &memblock.memory, 0);
+			break;
+		case ADDRESS_TYPE_ACPI:
+		case ADDRESS_TYPE_RESERVED:
+			memblock_reserve(loongson_mem_map->map[i].mem_start,
+					 loongson_mem_map->map[i].mem_size);
+			break;
+		}
+	}
+
+	get_pfn_range_for_nid(0, &start_pfn, &end_pfn);
+	pr_info("start_pfn=0x%lx, end_pfn=0x%lx, num_physpages:0x%lx\n",
+				start_pfn, end_pfn, num_physpages);
+
+	NODE_DATA(0)->node_start_pfn = start_pfn;
+	NODE_DATA(0)->node_spanned_pages = end_pfn - start_pfn;
+
+	/* used by finalize_initrd() */
+	max_low_pfn = end_pfn;
+
+	/* Reserve the first 2MB */
+	memblock_reserve(PHYS_OFFSET, 0x200000);
+
+	/* Reserve the kernel text/data/bss */
+	memblock_reserve(__pa_symbol(&_text),
+			 __pa_symbol(&_end) - __pa_symbol(&_text));
+}
diff --git a/arch/loongarch/loongson32/prom.c b/arch/loongarch/loongson32/prom.c
new file mode 100644
index 000000000000..c743fd49c702
--- /dev/null
+++ b/arch/loongarch/loongson32/prom.c
@@ -0,0 +1,125 @@
+/*
+ * LoongArch support for CONFIG_OF device tree support
+ *
+ * Copyright (C) 2010 Cisco Systems Inc. <dediao@cisco.com>
+ * Copyright (C) 2020 Loongson Technology Corporation Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/export.h>
+#include <linux/errno.h>
+#include <linux/types.h>
+#include <linux/debugfs.h>
+#include <linux/of.h>
+#include <linux/of_fdt.h>
+#include <linux/of_platform.h>
+
+#include <asm/bootinfo.h>
+#include <asm/page.h>
+
+void __init add_memory_region(phys_addr_t start, phys_addr_t size, long type)
+{
+    int x = boot_mem_map.nr_map;
+    int i;
+
+    /*
+     * If the region reaches the top of the physical address space, adjust
+     * the size slightly so that (start + size) doesn't overflow
+     */
+    if (start + size - 1 == PHYS_ADDR_MAX)
+        --size;
+
+    /* Sanity check */
+    if (start + size < start) {
+        pr_warn("Trying to add an invalid memory region, skipped\n");
+        return;
+    }
+
+    /*
+     * Try to merge with existing entry, if any.
+     */
+    for (i = 0; i < boot_mem_map.nr_map; i++) {
+        struct boot_mem_map_entry *entry = boot_mem_map.map + i;
+        unsigned long top;
+
+        if (entry->type != type)
+            continue;
+
+        if (start + size < entry->addr)
+            continue;           /* no overlap */
+
+        if (entry->addr + entry->size < start)
+            continue;           /* no overlap */
+
+        top = max(entry->addr + entry->size, start + size);
+        entry->addr = min(entry->addr, start);
+        entry->size = top - entry->addr;
+
+        return;
+    }
+
+    if (boot_mem_map.nr_map == BOOT_MEM_MAP_MAX) {
+         pr_err("Ooops! Too many entries in the memory map!\n");
+         return;
+     }
+
+     boot_mem_map.map[x].addr = start;
+     boot_mem_map.map[x].size = size;
+     boot_mem_map.map[x].type = type;
+     boot_mem_map.nr_map++;
+
+
+}
+
+void __init early_init_dt_add_memory_arch(u64 base, u64 size)
+{
+	if (base >= PHYS_ADDR_MAX) {
+		pr_warn("Trying to add an invalid memory region, skipped\n");
+		return;
+	}
+
+	/* Truncate the passed memory region instead of type casting */
+	if (base + size - 1 >= PHYS_ADDR_MAX || base + size < base) {
+		pr_warn("Truncate memory region %llx @ %llx to size %llx\n",
+			size, base, PHYS_ADDR_MAX - base);
+		size = PHYS_ADDR_MAX - base;
+	}
+
+	add_memory_region(base, size, BOOT_MEM_RAM);
+}
+
+int __init early_init_dt_reserve_memory_arch(phys_addr_t base,
+					phys_addr_t size, bool nomap)
+{
+	add_memory_region(base, size, BOOT_MEM_RESERVED);
+	return 0;
+}
+
+void __init __dt_setup_arch(void *bph)
+{
+	if (!early_init_dt_scan(bph))
+		return;
+}
+
+int __init __dt_register_buses(const char *bus0, const char *bus1)
+{
+	static struct of_device_id of_ids[3];
+
+	if (!of_have_populated_dt())
+		panic("device tree not present");
+
+	strlcpy(of_ids[0].compatible, bus0, sizeof(of_ids[0].compatible));
+	if (bus1) {
+		strlcpy(of_ids[1].compatible, bus1,
+			sizeof(of_ids[1].compatible));
+	}
+
+	if (of_platform_populate(NULL, of_ids, NULL, NULL))
+		panic("failed to populate DT");
+
+	return 0;
+}
diff --git a/arch/loongarch/loongson32/reset.c b/arch/loongarch/loongson32/reset.c
new file mode 100644
index 000000000000..0ca20679a0a7
--- /dev/null
+++ b/arch/loongarch/loongson32/reset.c
@@ -0,0 +1,54 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Author: Huacai Chen, chenhuacai@loongson.cn
+ * Copyright (C) 2020-2021 Loongson Technology Corporation Limited
+ */
+#include <linux/acpi.h>
+#include <linux/cpu.h>
+#include <linux/delay.h>
+#include <linux/efi.h>
+#include <linux/init.h>
+#include <linux/pm.h>
+#include <linux/slab.h>
+#include <acpi/reboot.h>
+#include <asm/bootinfo.h>
+#include <asm/delay.h>
+#include <asm/idle.h>
+#include <asm/reboot.h>
+#include <boot_param.h>
+
+static void loongson_restart(void)
+{
+#ifdef CONFIG_EFI
+	if (efi_capsule_pending(NULL))
+		efi_reboot(REBOOT_WARM, NULL);
+	else
+		efi_reboot(REBOOT_COLD, NULL);
+#endif
+	if (!acpi_disabled)
+		acpi_reboot();
+
+	while (1) {
+		__arch_cpu_idle();
+	}
+}
+
+static void loongson_poweroff(void)
+{
+#ifdef CONFIG_EFI
+	efi.reset_system(EFI_RESET_SHUTDOWN, EFI_SUCCESS, 0, NULL);
+#endif
+	while (1) {
+		__arch_cpu_idle();
+	}
+}
+
+static int __init loongarch_reboot_setup(void)
+{
+	pm_restart = loongson_restart;
+	pm_power_off = loongson_poweroff;
+
+	return 0;
+}
+
+arch_initcall(loongarch_reboot_setup);
diff --git a/arch/loongarch/loongson32/serial.c b/arch/loongarch/loongson32/serial.c
new file mode 100644
index 000000000000..e53dd3f74caa
--- /dev/null
+++ b/arch/loongarch/loongson32/serial.c
@@ -0,0 +1,68 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2020-2021 Loongson Technology Corporation Limited
+ */
+
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/serial_8250.h>
+#include <loongson.h>
+
+#define PORT(int, clk)			\
+{								\
+	.irq		= int,					\
+	.uartclk	= clk,					\
+	.iotype		= UPIO_PORT,				\
+	.flags		= UPF_BOOT_AUTOCONF | UPF_SKIP_TEST,	\
+	.regshift	= 0,					\
+}
+
+#define PORT_M(int, clk)				\
+{								\
+	.irq		= 50 + (int),		\
+	.uartclk	= clk,					\
+	.iotype		= UPIO_MEM,				\
+	.membase	= (void __iomem *)NULL,			\
+	.flags		= UPF_BOOT_AUTOCONF | UPF_SKIP_TEST,	\
+	.regshift	= 0,					\
+}
+
+static struct plat_serial8250_port uart8250_data[][3] = {
+	[0]	= {PORT_M(2, 33000000), {} },
+	[1] = {PORT_M(2, 33000000), {} },
+	[2]	= {},
+};
+
+static struct platform_device uart8250_device = {
+	.name = "serial8250",
+	.id = PLAT8250_DEV_PLATFORM,
+};
+
+extern unsigned long _loongson_uart_base[];
+extern unsigned long loongson_uart_base[];
+
+static int __init serial_init(void)
+{
+	unsigned char iotype;
+
+	iotype = uart8250_data[1][0].iotype;
+
+		uart8250_data[1][0].mapbase =
+			loongson_uart_base[0];
+		uart8250_data[1][0].membase =
+			(void __iomem *)_loongson_uart_base[0];
+		uart8250_data[1][0].uartclk =0x10000000;
+
+	memset(&uart8250_data[1][0],
+			0, sizeof(struct plat_serial8250_port));
+	uart8250_device.dev.platform_data = uart8250_data[1];
+
+	return platform_device_register(&uart8250_device);
+}
+module_init(serial_init);
+
+static void __init serial_exit(void)
+{
+	platform_device_unregister(&uart8250_device);
+}
+module_exit(serial_exit);
diff --git a/arch/loongarch/loongson32/setup.c b/arch/loongarch/loongson32/setup.c
new file mode 100644
index 000000000000..ed301e114e77
--- /dev/null
+++ b/arch/loongarch/loongson32/setup.c
@@ -0,0 +1,360 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Author: Huacai Chen <chenhuacai@loongson.cn>
+ * Copyright (C) 2020-2021 Loongson Technology Corporation Limited
+ */
+#include <linux/acpi.h>
+#include <linux/dmi.h>
+#include <linux/efi.h>
+#include <linux/export.h>
+#include <linux/init.h>
+#include <linux/memblock.h>
+#include <asm/acpi.h>
+#include <asm/bootinfo.h>
+#include <asm/cacheflush.h>
+#include <asm/efi.h>
+#include <asm/fw.h>
+#include <asm/time.h>
+
+#ifdef CONFIG_VT
+#include <linux/console.h>
+#include <linux/screen_info.h>
+#include <linux/platform_device.h>
+#endif
+
+#include <loongson.h>
+#include <linux/libfdt.h>
+#include <linux/of_fdt.h>
+#include <linux/of.h>
+
+#define SMBIOS_BIOSSIZE_OFFSET		0x09
+#define SMBIOS_BIOSEXTERN_OFFSET	0x13
+#define SMBIOS_FREQLOW_OFFSET		0x16
+#define SMBIOS_FREQHIGH_OFFSET		0x17
+#define SMBIOS_FREQLOW_MASK		0xFF
+#define SMBIOS_CORE_PACKAGE_OFFSET	0x23
+#define LOONGSON_EFI_ENABLE		(1 << 3)
+#define efi_table_attr(inst, attr)      (inst->attr)
+
+struct loongson_board_info b_info;
+static const char dmi_empty_string[] = "        ";
+void *loongson_fdt_blob;
+const efi_system_table_t *efi_system_table;
+
+extern void __init memblock_remove_mem(void);
+extern char __dtb_start[];
+extern u32 __dtb_loongson32_ls_begin[];
+extern void __init __dt_setup_arch(void *bph);
+extern bool __init early_init_dt_verify(void *params);
+extern inline u64 of_read_number(const __be32 *cell, int size);
+
+struct loongsonlist_mem_map global_mem_map;
+struct boot_mem_map boot_mem_map;
+
+const char *get_system_type(void)
+{
+	return "generic-loongson-machine";
+}
+
+static int __init parse_cluster(struct device_node *cluster, int depth)
+{
+        char name[10];
+        bool leaf = true;
+        bool has_cores = false;
+        struct device_node *c;
+        int core_id = 0;
+        int i, ret;
+
+        i = 0;
+        do {
+                snprintf(name, sizeof(name), "cluster%d", i);
+                c = of_get_child_by_name(cluster, name);
+                if (c) {
+                        leaf = false;
+                        ret = parse_cluster(c, depth + 1);
+                        of_node_put(c);
+                        if (ret != 0)
+                                return ret;
+                }
+                i++;
+        } while (c);
+
+        i = 0;
+        do {
+                snprintf(name, sizeof(name), "core%d", i);
+                c = of_get_child_by_name(cluster, name);
+                if (c) {
+                        has_cores = true;
+
+                        if (depth == 0) {
+                                pr_err("%pOF: cpu-map children should be clusters\n",
+                                       c);
+                                of_node_put(c);
+                                return -EINVAL;
+                        }
+
+                        if (leaf) {
+                                core_id++;
+                        } else {
+                                pr_err("%pOF: Non-leaf cluster with core %s\n",
+                                       cluster, name);
+                                ret = -EINVAL;
+                        }
+                        of_node_put(c);
+                        if (ret != 0)
+                                return ret;
+                }
+                i++;
+        } while (c);
+
+        if (leaf && !has_cores)
+                pr_warn("%pOF: empty cluster\n", cluster);
+
+        if (loongson_sysconf.cores_per_package == 0)
+                loongson_sysconf.cores_per_package = core_id;
+
+        return 0;
+}
+
+static const char *dmi_string_parse(const struct dmi_header *dm, u8 s)
+{
+	const u8 *bp = ((u8 *) dm) + dm->length;
+
+	if (s) {
+		s--;
+		while (s > 0 && *bp) {
+			bp += strlen(bp) + 1;
+			s--;
+		}
+
+		if (*bp != 0) {
+			size_t len = strlen(bp)+1;
+			size_t cmp_len = len > 8 ? 8 : len;
+
+			if (!memcmp(bp, dmi_empty_string, cmp_len))
+				return dmi_empty_string;
+
+			return bp;
+		}
+	}
+
+	return "";
+}
+
+static void __init parse_cpu_table(const struct dmi_header *dm)
+{
+	long freq_temp = 0;
+	char *dmi_data = (char *)dm;
+
+	freq_temp = ((*(dmi_data + SMBIOS_FREQHIGH_OFFSET) << 8) +
+			((*(dmi_data + SMBIOS_FREQLOW_OFFSET)) & SMBIOS_FREQLOW_MASK));
+	cpu_clock_freq = freq_temp * 1000000;
+
+	loongson_sysconf.cpuname = (void *)dmi_string_parse(dm, dmi_data[16]);
+	loongson_sysconf.cores_per_package = *(dmi_data + SMBIOS_CORE_PACKAGE_OFFSET);
+
+	pr_info("CpuClock = %llu\n", cpu_clock_freq);
+}
+
+static void __init parse_bios_table(const struct dmi_header *dm)
+{
+	int bios_extern;
+	char *dmi_data = (char *)dm;
+
+	bios_extern = *(dmi_data + SMBIOS_BIOSEXTERN_OFFSET);
+	b_info.bios_size = *(dmi_data + SMBIOS_BIOSSIZE_OFFSET);
+
+	if (bios_extern & LOONGSON_EFI_ENABLE)
+		set_bit(EFI_BOOT, &efi.flags);
+	else
+		clear_bit(EFI_BOOT, &efi.flags);
+}
+
+static void __init find_tokens(const struct dmi_header *dm, void *dummy)
+{
+	switch (dm->type) {
+	case 0x0: /* Extern BIOS */
+		parse_bios_table(dm);
+		break;
+	case 0x4: /* Calling interface */
+		parse_cpu_table(dm);
+		break;
+	}
+}
+
+static void __init smbios_parse(void)
+{
+	b_info.bios_vendor = (void *)dmi_get_system_info(DMI_BIOS_VENDOR);
+	b_info.bios_version = (void *)dmi_get_system_info(DMI_BIOS_VERSION);
+	b_info.bios_release_date = (void *)dmi_get_system_info(DMI_BIOS_DATE);
+	b_info.board_vendor = (void *)dmi_get_system_info(DMI_BOARD_VENDOR);
+	b_info.board_name = (void *)dmi_get_system_info(DMI_BOARD_NAME);
+	dmi_walk(find_tokens, NULL);
+}
+
+void __init early_init(void)
+{
+	fw_init_cmdline();
+	fw_init_environ();
+	early_memblock_init();
+}
+
+#define INVALID_HWID    0xFFFF
+static u64 __init of_get_hwid(struct device_node *dn)
+{
+        const __be32 *cell = of_get_property(dn, "reg", NULL);
+
+	if (!cell) {
+		pr_err("%pOF: missing reg property\n", dn);
+		return INVALID_HWID;
+	}
+
+	return of_read_number(cell, of_n_addr_cells(dn));
+}
+
+static int __init parse_dt_topology(void)
+{
+        struct device_node *cn, *map;
+        int ret = 0;
+
+        cn = of_find_node_by_path("/cpus");
+        if (!cn) {
+                return 0;
+        }
+
+        map = of_get_child_by_name(cn, "cpu-map");
+        if (!map)
+                goto out;
+
+        ret = parse_cluster(map, 0);
+        if (ret != 0)
+                goto out_map;
+
+out_map:
+        of_node_put(map);
+out:
+        of_node_put(cn);
+        return ret;
+}
+
+static void __init parse_dt_cpus(void)
+{
+        struct device_node *dn;
+        int i;
+        int nid = 0;
+        int hwids[NR_CPUS];
+        nodemask_t nodes_mask;
+        int nr_nodes;
+
+        loongson_sysconf.reserved_cpus_mask = -1;
+        loongson_sysconf.boot_cpu_id = read_csr_cpuid();
+
+        nodes_clear(nodes_mask);
+        for_each_node_by_type(dn, "cpu") {
+                u64 hwid = of_get_hwid(dn);
+
+                if (hwid >= INVALID_HWID)
+                        continue;
+
+                for (i = 0; i < loongson_sysconf.nr_cpus; i++) {
+                        if (hwids[i] == hwid) {
+                                pr_err("%pOF: duplicate cpu reg properties in the DT\n", dn);
+                                continue;
+                        }
+                }
+
+                nid = of_node_to_nid(dn);
+                if (nid != NUMA_NO_NODE)
+                        node_set(nid, nodes_mask);
+
+                if (of_node_to_nid(dn) == 0)
+                        loongson_sysconf.cores_per_node++;
+
+                if (loongson_sysconf.nr_cpus >= NR_CPUS)
+                        break;
+
+                hwids[loongson_sysconf.nr_cpus] = hwid;
+                loongson_sysconf.reserved_cpus_mask &= (~(1 << hwid));
+                loongson_sysconf.nr_cpus++;
+        }
+        nr_nodes = nodes_weight(nodes_mask);
+        if (nr_nodes)
+                loongson_sysconf.nr_nodes = nodes_weight(nodes_mask);
+}
+
+static void loongson_mem_init(void)
+{
+        int i;
+
+        memset(&global_mem_map, 0, sizeof(global_mem_map));
+        global_mem_map.map_count = boot_mem_map.nr_map;
+        for (i = 0; i < boot_mem_map.nr_map; i++) {
+                struct boot_mem_map_entry *bm_entry = boot_mem_map.map + i;
+                struct loongson_mem_map *lm_entry = global_mem_map.map + i;
+
+                if (bm_entry->type == 1)
+                        lm_entry->mem_type = ADDRESS_TYPE_SYSRAM;
+                else
+                        lm_entry->mem_type = ADDRESS_TYPE_RESERVED;
+
+                lm_entry->mem_start = bm_entry->addr;
+                lm_entry->mem_size = bm_entry->size;
+        }
+
+        if (global_mem_map.map_count == 0)
+                panic("No memory available!");
+}
+
+void __init device_tree_init(void)
+{
+        if (!initial_boot_params)
+                return;
+
+        if (early_init_dt_verify(initial_boot_params))
+                unflatten_and_copy_device_tree();
+}
+
+
+void __init platform_init(void)
+{
+	//unsigned long fdt_addr, fdt_size;
+	/* init base address of io space */
+	set_io_port_base((unsigned long)
+		ioremap(LOONGSON_LIO_BASE, LOONGSON_LIO_SIZE));
+	efi_init();
+#ifdef CONFIG_ACPI_TABLE_UPGRADE
+	acpi_table_upgrade();
+#endif
+
+	loongson_fdt_blob = __dtb_loongson32_ls_begin;
+	__dt_setup_arch(loongson_fdt_blob);
+	early_init_fdt_reserve_self();
+	early_init_fdt_scan_reserved_mem();
+
+	loongson_mem_init();
+	loongson_mem_map = &global_mem_map;
+	early_memblock_init();
+	device_tree_init();
+	parse_dt_cpus();
+	parse_dt_topology();
+
+	fw_init_memory();
+	dmi_setup();
+	smbios_parse();
+	pr_info("The BIOS Version: %s\n", b_info.bios_version);
+
+	efi_runtime_init();
+
+}
+
+static int __init register_gop_device(void)
+{
+	void *pd;
+
+	if (screen_info.orig_video_isVGA != VIDEO_TYPE_EFI)
+		return 0;
+	pd = platform_device_register_data(NULL, "efi-framebuffer", 0,
+			&screen_info, sizeof(screen_info));
+	return PTR_ERR_OR_ZERO(pd);
+}
+subsys_initcall(register_gop_device);
diff --git a/arch/loongarch/loongson32/smp.c b/arch/loongarch/loongson32/smp.c
new file mode 100644
index 000000000000..3d1a9b3cf90e
--- /dev/null
+++ b/arch/loongarch/loongson32/smp.c
@@ -0,0 +1,20 @@
+#include <linux/init.h>
+#include <linux/cpu.h>
+#include <linux/sched.h>
+#include <linux/sched/hotplug.h>
+#include <linux/sched/task_stack.h>
+#include <linux/seq_file.h>
+#include <linux/smp.h>
+#include <linux/syscore_ops.h>
+#include <linux/tracepoint.h>
+#include <asm/processor.h>
+#include <asm/time.h>
+#include <asm/tlbflush.h>
+#include <asm/cacheflush.h>
+#include <loongson.h>
+
+static DEFINE_PER_CPU(int, cpu_state);
+DEFINE_PER_CPU_SHARED_ALIGNED(irq_cpustat_t, irq_stat);
+EXPORT_PER_CPU_SYMBOL(irq_stat);
+
+
diff --git a/arch/loongarch/loongson32/uart_base.c b/arch/loongarch/loongson32/uart_base.c
new file mode 100644
index 000000000000..c35c1e5bb60e
--- /dev/null
+++ b/arch/loongarch/loongson32/uart_base.c
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2009 Lemote Inc.
+ * Author: Wu Zhangjin, wuzhangjin@gmail.com
+ *
+ * This program is free software; you can redistribute	it and/or modify it
+ * under  the terms of	the GNU General	 Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/export.h>
+#include <asm/bootinfo.h>
+
+#include <loongson.h>
+
+/* raw */
+unsigned long loongson_uart_base[3] = {};
+/* ioremapped */
+unsigned long _loongson_uart_base[3] = {};
+
+EXPORT_SYMBOL(loongson_uart_base);
+EXPORT_SYMBOL(_loongson_uart_base);
+
+void prom_init_loongson_uart_base(void)
+{
+	loongson_uart_base[0] =(unsigned long ) 0x9fe001e0;
+	_loongson_uart_base[0] =
+		(unsigned long)ioremap(loongson_uart_base[0], 8);
+}
diff --git a/arch/loongarch/mm/Makefile b/arch/loongarch/mm/Makefile
index a3a137709650..43f1dbe247cc 100644
--- a/arch/loongarch/mm/Makefile
+++ b/arch/loongarch/mm/Makefile
@@ -3,8 +3,8 @@
 # Makefile for the Linux/LoongArch-specific parts of the memory manager.
 #
 
-obj-y				+= init.o cache.o tlb.o tlbex.o extable.o \
-				   fault.o ioremap.o maccess.o mmap.o pgtable.o page.o
+obj-y				+= init.o cache.o tlb.o extable.o \
+				   fault.o ioremap.o mmap.o pgtable.o page.o
 
-obj-$(CONFIG_64BIT)		+= pgtable-64.o
+obj-$(CONFIG_32BIT)		+= pgtable-32.o tlbex-32.o
 obj-$(CONFIG_HUGETLB_PAGE)	+= hugetlbpage.o
diff --git a/arch/loongarch/mm/cache.c b/arch/loongarch/mm/cache.c
index 9974ac92c1ca..36ab8e8c6df2 100644
--- a/arch/loongarch/mm/cache.c
+++ b/arch/loongarch/mm/cache.c
@@ -60,8 +60,6 @@ void cache_error_setup(void)
 
 static unsigned long icache_size __read_mostly;
 static unsigned long dcache_size __read_mostly;
-static unsigned long vcache_size __read_mostly;
-static unsigned long scache_size __read_mostly;
 
 static char *way_string[] = { NULL, "direct mapped", "2-way",
 	"3-way", "4-way", "5-way", "6-way", "7-way", "8-way",
@@ -75,28 +73,38 @@ static void probe_pcache(void)
 	unsigned int lsize, sets, ways;
 	unsigned int config;
 
-	config = read_cpucfg(LOONGARCH_CPUCFG17);
-	lsize = 1 << ((config & CPUCFG17_L1I_SIZE_M) >> CPUCFG17_L1I_SIZE);
+	config = 0xfe994cd3;
+
+	lsize = (config >> 19) & 7;
 	sets  = 1 << ((config & CPUCFG17_L1I_SETS_M) >> CPUCFG17_L1I_SETS);
 	ways  = ((config & CPUCFG17_L1I_WAYS_M) >> CPUCFG17_L1I_WAYS) + 1;
 
-	c->icache.linesz = lsize;
-	c->icache.sets = sets;
-	c->icache.ways = ways;
-	icache_size = sets * ways * lsize;
+	if (lsize)
+                        c->icache.linesz = 2 << lsize;
+                else
+                        c->icache.linesz = 0;
+	c->icache.sets = 64 << ((config >> 22) & 7);
+	c->icache.ways = 1 + ((config >> 16) & 7);
+	icache_size = c->icache.sets *
+                                          c->icache.ways *
+                                          c->icache.linesz;
 	c->icache.waysize = icache_size / c->icache.ways;
 
-	config = read_cpucfg(LOONGARCH_CPUCFG18);
-	lsize = 1 << ((config & CPUCFG18_L1D_SIZE_M) >> CPUCFG18_L1D_SIZE);
+
+	lsize = (config >> 10) & 7;
 	sets  = 1 << ((config & CPUCFG18_L1D_SETS_M) >> CPUCFG18_L1D_SETS);
 	ways  = ((config & CPUCFG18_L1D_WAYS_M) >> CPUCFG18_L1D_WAYS) + 1;
 
-	c->dcache.linesz = lsize;
-	c->dcache.sets = sets;
-	c->dcache.ways = ways;
-	dcache_size = sets * ways * lsize;
+	if (lsize)
+                        c->dcache.linesz = 2 << lsize;
+                else
+                        c->dcache.linesz = 0;
+	c->dcache.sets = 64 << ((config >> 13) & 7);
+	c->dcache.ways = 1 + ((config >> 7) & 7);
+	dcache_size = c->dcache.sets *
+                                          c->dcache.ways *
+                                          c->dcache.linesz;
 	c->dcache.waysize = dcache_size / c->dcache.ways;
-
 	c->options |= LOONGARCH_CPU_PREFETCH;
 
 	pr_info("Primary instruction cache %ldkB, %s, %s, linesize %d bytes.\n",
@@ -106,54 +114,8 @@ static void probe_pcache(void)
 		dcache_size >> 10, way_string[c->dcache.ways], "VIPT", "no aliases", c->dcache.linesz);
 }
 
-static void probe_vcache(void)
-{
-	struct cpuinfo_loongarch *c = &current_cpu_data;
-	unsigned int lsize, sets, ways;
-	unsigned int config;
-
-	config = read_cpucfg(LOONGARCH_CPUCFG19);
-	lsize = 1 << ((config & CPUCFG19_L2_SIZE_M) >> CPUCFG19_L2_SIZE);
-	sets  = 1 << ((config & CPUCFG19_L2_SETS_M) >> CPUCFG19_L2_SETS);
-	ways  = ((config & CPUCFG19_L2_WAYS_M) >> CPUCFG19_L2_WAYS) + 1;
-
-	c->vcache.linesz = lsize;
-	c->vcache.sets = sets;
-	c->vcache.ways = ways;
-	vcache_size = lsize * sets * ways;
-	c->vcache.waysize = vcache_size / c->vcache.ways;
-
-	pr_info("Unified victim cache %ldkB %s, linesize %d bytes.\n",
-		vcache_size >> 10, way_string[c->vcache.ways], c->vcache.linesz);
-}
-
-static void probe_scache(void)
-{
-	struct cpuinfo_loongarch *c = &current_cpu_data;
-	unsigned int lsize, sets, ways;
-	unsigned int config;
-
-	config = read_cpucfg(LOONGARCH_CPUCFG20);
-	lsize = 1 << ((config & CPUCFG20_L3_SIZE_M) >> CPUCFG20_L3_SIZE);
-	sets  = 1 << ((config & CPUCFG20_L3_SETS_M) >> CPUCFG20_L3_SETS);
-	ways  = ((config & CPUCFG20_L3_WAYS_M) >> CPUCFG20_L3_WAYS) + 1;
-
-	c->scache.linesz = lsize;
-	c->scache.sets = sets;
-	c->scache.ways = ways;
-	/* 4 cores. scaches are shared */
-	scache_size = lsize * sets * ways;
-	c->scache.waysize = scache_size / c->scache.ways;
-
-	pr_info("Unified secondary cache %ldkB %s, linesize %d bytes.\n",
-		scache_size >> 10, way_string[c->scache.ways], c->scache.linesz);
-}
-
 void cpu_cache_init(void)
 {
 	probe_pcache();
-	probe_vcache();
-	probe_scache();
-
 	shm_align_mask = PAGE_SIZE - 1;
 }
diff --git a/arch/loongarch/mm/fault.c b/arch/loongarch/mm/fault.c
index f3a523379993..04c6f6c25314 100644
--- a/arch/loongarch/mm/fault.c
+++ b/arch/loongarch/mm/fault.c
@@ -58,11 +58,14 @@ static void __kprobes __do_page_fault(struct pt_regs *regs, unsigned long write,
 	 * only copy the information from the master page table,
 	 * nothing more.
 	 */
+#ifdef CONFIG_32BIT
+#define VMALLOC_FAULT_TARGET vmalloc_fault
+#endif
+
 #ifdef CONFIG_64BIT
-# define VMALLOC_FAULT_TARGET no_context
-#else
-# define VMALLOC_FAULT_TARGET vmalloc_fault
+#define VMALLOC_FAULT_TARGET no_context
 #endif
+
 	if (unlikely(address >= VMALLOC_START && address <= VMALLOC_END))
 		goto VMALLOC_FAULT_TARGET;
 
@@ -252,15 +255,15 @@ static void __kprobes __do_page_fault(struct pt_regs *regs, unsigned long write,
 		pmd_t *pmd, *pmd_k;
 		pte_t *pte_k;
 
-		pgd = (pgd_t *) pgd_current[raw_smp_processor_id()] + offset;
+		pgd = (pgd_t *) __csrrd(LOONGARCH_CSR_PGD) +offset ;
 		pgd_k = init_mm.pgd + offset;
 
 		if (!pgd_present(*pgd_k))
 			goto no_context;
 		set_pgd(pgd, *pgd_k);
 
-		pud = pud_offset(pgd, address);
-		pud_k = pud_offset(pgd_k, address);
+		pud = pud_offset((p4d_t *)pgd, address);
+		pud_k = pud_offset((p4d_t *)pgd_k, address);
 		if (!pud_present(*pud_k))
 			goto no_context;
 
diff --git a/arch/loongarch/mm/init.c b/arch/loongarch/mm/init.c
index 9cdb12c61c48..9d797a542205 100644
--- a/arch/loongarch/mm/init.c
+++ b/arch/loongarch/mm/init.c
@@ -139,7 +139,7 @@ void free_init_pages(const char *what, unsigned long begin, unsigned long end)
 void free_initrd_mem(unsigned long start, unsigned long end)
 {
 	free_reserved_area((void *)start, (void *)end, POISON_FREE_INITMEM,
-			   "initrd");
+			"initrd");
 }
 #endif
 
@@ -181,17 +181,6 @@ void arch_refresh_nodedata(int nid, pg_data_t *pgdat)
 }
 #endif
 
-#ifdef CONFIG_NUMA
-int memory_add_physaddr_to_nid(u64 start)
-{
-	int nid;
-
-	nid = pa_to_nid(start);
-	return nid;
-}
-EXPORT_SYMBOL_GPL(memory_add_physaddr_to_nid);
-#endif
-
 #ifdef CONFIG_MEMORY_HOTREMOVE
 void arch_remove_memory(int nid, u64 start,
 		u64 size, struct vmem_altmap *altmap)
diff --git a/arch/loongarch/mm/ioremap.c b/arch/loongarch/mm/ioremap.c
index 4181290d82fc..46621ec81ad4 100644
--- a/arch/loongarch/mm/ioremap.c
+++ b/arch/loongarch/mm/ioremap.c
@@ -5,9 +5,9 @@
 
 #include <asm/io.h>
 
-void __init __iomem *early_ioremap(u64 phys_addr, unsigned long size)
+void __init __iomem *early_ioremap(u32 phys_addr, unsigned long size)
 {
-	return ((void __iomem *)TO_CAC(phys_addr));
+        return ((void __iomem *)(unsigned long)TO_CAC(phys_addr));
 }
 
 void __init early_iounmap(void __iomem *addr, unsigned long size)
diff --git a/arch/loongarch/mm/page.S b/arch/loongarch/mm/page.S
index 254b5c7f802b..31e7f359170e 100644
--- a/arch/loongarch/mm/page.S
+++ b/arch/loongarch/mm/page.S
@@ -11,72 +11,50 @@
 	.align 5
 SYM_FUNC_START(clear_page)
 	lu12i.w  t0, 1 << (PAGE_SHIFT - 12)
-	add.d    t0, t0, a0
+	LONG_ADDU    t0, t0, a0
 1:
-	st.d     zero, a0, 0
-	st.d     zero, a0, 8
-	st.d     zero, a0, 16
-	st.d     zero, a0, 24
-	st.d     zero, a0, 32
-	st.d     zero, a0, 40
-	st.d     zero, a0, 48
-	st.d     zero, a0, 56
-	addi.d   a0,   a0, 128
-	st.d     zero, a0, -64
-	st.d     zero, a0, -56
-	st.d     zero, a0, -48
-	st.d     zero, a0, -40
-	st.d     zero, a0, -32
-	st.d     zero, a0, -24
-	st.d     zero, a0, -16
-	st.d     zero, a0, -8
+	LONG_S     zero, a0, 0
+	LONG_S     zero, a0, 4
+	LONG_S     zero, a0, 8
+	LONG_S     zero, a0, 12
+	LONG_S     zero, a0, 16
+	LONG_S     zero, a0, 20
+	LONG_S     zero, a0, 24
+	LONG_S     zero, a0, 28
+
+	LONG_ADDIU   a0,   a0, 32
+
 	bne      t0,   a0, 1b
 
 	jirl     $r0, ra, 0
 SYM_FUNC_END(clear_page)
-EXPORT_SYMBOL(clear_page)
 
-.align 5
+
+	.align 5
 SYM_FUNC_START(copy_page)
 	lu12i.w  t8, 1 << (PAGE_SHIFT - 12)
-	add.d    t8, t8, a0
+	LONG_ADDU    t8, t8, a0
 1:
-	ld.d     t0, a1,  0
-	ld.d     t1, a1,  8
-	ld.d     t2, a1,  16
-	ld.d     t3, a1,  24
-	ld.d     t4, a1,  32
-	ld.d     t5, a1,  40
-	ld.d     t6, a1,  48
-	ld.d     t7, a1,  56
+	LONG_L     t0, a1,  0
+	LONG_L     t1, a1,  4
+	LONG_L     t2, a1,  8
+	LONG_L     t3, a1,  12
+	LONG_L     t4, a1,  16
+	LONG_L     t5, a1,  20
+	LONG_L     t6, a1,  24
+	LONG_L     t7, a1,  28
 
-	st.d     t0, a0,  0
-	st.d     t1, a0,  8
-	ld.d     t0, a1,  64
-	ld.d     t1, a1,  72
-	st.d     t2, a0,  16
-	st.d     t3, a0,  24
-	ld.d     t2, a1,  80
-	ld.d     t3, a1,  88
-	st.d     t4, a0,  32
-	st.d     t5, a0,  40
-	ld.d     t4, a1,  96
-	ld.d     t5, a1,  104
-	st.d     t6, a0,  48
-	st.d     t7, a0,  56
-	ld.d     t6, a1,  112
-	ld.d     t7, a1,  120
-	addi.d   a0, a0,  128
-	addi.d   a1, a1,  128
+	LONG_S     t0, a0,  0
+	LONG_S     t1, a0,  4
+	LONG_S     t2, a0,  8
+	LONG_S     t3, a0,  12
+	LONG_S     t4, a0,  16
+	LONG_S     t5, a0,  20
+	LONG_S     t6, a0,  24
+	LONG_S     t7, a0,  28
 
-	st.d     t0, a0,  -64
-	st.d     t1, a0,  -56
-	st.d     t2, a0,  -48
-	st.d     t3, a0,  -40
-	st.d     t4, a0,  -32
-	st.d     t5, a0,  -24
-	st.d     t6, a0,  -16
-	st.d     t7, a0,  -8
+	LONG_ADDIU   a0, a0,  32
+	LONG_ADDIU   a1, a1,  32
 
 	bne      t8, a0, 1b
 	jirl     $r0, ra, 0
diff --git a/arch/loongarch/mm/pgtable-32.c b/arch/loongarch/mm/pgtable-32.c
new file mode 100644
index 000000000000..fe7bd61a499b
--- /dev/null
+++ b/arch/loongarch/mm/pgtable-32.c
@@ -0,0 +1,45 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2020-2021 Loongson Technology Corporation Limited
+ */
+#include <linux/export.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <asm/pgtable.h>
+#include <asm/pgalloc.h>
+#include <asm/tlbflush.h>
+
+void pgd_init(unsigned long page)
+{
+	unsigned long *p, *end;
+	unsigned long entry;
+
+	entry = (unsigned long)invalid_pte_table;
+
+	p = (unsigned long *) page;
+	end = p + PTRS_PER_PGD;
+
+	do {
+		p[0] = entry;
+		p[1] = entry;
+		p[2] = entry;
+		p[3] = entry;
+		p[4] = entry;
+		p += 8;
+		p[-3] = entry;
+		p[-2] = entry;
+		p[-1] = entry;
+	} while (p != end);
+}
+
+
+void __init pagetable_init(void)
+{
+	pgd_t *pgd_base;
+
+	/* Initialize the entire pgd.  */
+	pgd_init((unsigned long)swapper_pg_dir);
+	pgd_init((unsigned long)invalid_pg_dir);
+
+	pgd_base = swapper_pg_dir;
+}
diff --git a/arch/loongarch/mm/pgtable.c b/arch/loongarch/mm/pgtable.c
index 9f776f200f5c..a76eff517101 100644
--- a/arch/loongarch/mm/pgtable.c
+++ b/arch/loongarch/mm/pgtable.c
@@ -16,7 +16,7 @@ pgd_t *pgd_alloc(struct mm_struct *mm)
 		init = pgd_offset(&init_mm, 0UL);
 		pgd_init((unsigned long)ret);
 		memcpy(ret + USER_PTRS_PER_PGD, init + USER_PTRS_PER_PGD,
-		       (PTRS_PER_PGD - USER_PTRS_PER_PGD) * sizeof(pgd_t));
+			(PTRS_PER_PGD - USER_PTRS_PER_PGD) * sizeof(pgd_t));
 	}
 
 	return ret;
diff --git a/arch/loongarch/mm/tlb.c b/arch/loongarch/mm/tlb.c
index 99a7f36c60ae..c90b2f4a809d 100644
--- a/arch/loongarch/mm/tlb.c
+++ b/arch/loongarch/mm/tlb.c
@@ -122,6 +122,7 @@ void local_flush_tlb_one(unsigned long page)
 	invtlb_addr(INVTLB_ADDR_GTRUE_OR_ASID, 0, page);
 }
 
+#ifdef CONFIG_HUGETLB_PAGE
 static void __update_hugetlb(struct vm_area_struct *vma, unsigned long address, pte_t *ptep)
 {
 	int idx;
@@ -147,20 +148,23 @@ static void __update_hugetlb(struct vm_area_struct *vma, unsigned long address,
 
 	local_irq_restore(flags);
 }
+#endif
 
 void __update_tlb(struct vm_area_struct *vma, unsigned long address, pte_t *ptep)
 {
 	int idx;
 	unsigned long flags;
-
+	unsigned long ptep_val;
 	/*
 	 * Handle debugger faulting in for debugee.
 	 */
 	if (current->active_mm != vma->vm_mm)
 		return;
 
+#ifdef CONFIG_HUGETLB_PAGE
 	if (pte_val(*ptep) & _PAGE_HUGE)
 		return __update_hugetlb(vma, address, ptep);
+#endif
 
 	local_irq_save(flags);
 
@@ -172,18 +176,19 @@ void __update_tlb(struct vm_area_struct *vma, unsigned long address, pte_t *ptep
 	tlb_probe();
 	idx = read_csr_tlbidx();
 	write_csr_pagesize(PS_DEFAULT_SIZE);
-	write_csr_entrylo0(pte_val(*ptep++));
-	write_csr_entrylo1(pte_val(*ptep));
+	ptep_val = ( ( pte_val(*ptep) >>12)<<8)|( pte_val(*ptep) & 0xff );
+	write_csr_entrylo0(ptep_val);
+	ptep++;
+	ptep_val = ( ( pte_val(*ptep) >>12)<<8)|( pte_val(*ptep) & 0xff );
+	write_csr_entrylo1(ptep_val);
 	if (idx < 0)
 		tlb_write_random();
 	else
 		tlb_write_indexed();
-
 	local_irq_restore(flags);
 }
 
 #ifdef CONFIG_TRANSPARENT_HUGEPAGE
-
 int has_transparent_hugepage(void)
 {
 	static unsigned int size = -1;
@@ -199,7 +204,6 @@ int has_transparent_hugepage(void)
 	}
 	return size == PS_HUGE_SIZE;
 }
-
 #endif /* CONFIG_TRANSPARENT_HUGEPAGE  */
 
 static void setup_pw(void)
@@ -221,13 +225,6 @@ static void setup_pw(void)
 	pte_i  = PAGE_SHIFT;    /* 3rd level PTE */
 	pte_w  = PAGE_SHIFT - 3;
 
-#ifndef __PAGETABLE_PMD_FOLDED
-	csr_writeq(pte_i | pte_w << 5 | pmd_i << 10 | pmd_w << 15, LOONGARCH_CSR_PWCTL0);
-	csr_writeq(pgd_i | pgd_w << 6, LOONGARCH_CSR_PWCTL1);
-#else
-	csr_writeq(pte_i | pte_w << 5, LOONGARCH_CSR_PWCTL0);
-	csr_writeq(pgd_i | pgd_w << 6, LOONGARCH_CSR_PWCTL1);
-#endif
 	csr_writeq((long)swapper_pg_dir, LOONGARCH_CSR_PGDH);
 }
 
@@ -242,12 +239,14 @@ static void output_pgtable_bits_defines(void)
 
 	pr_define("_PAGE_VALID_SHIFT %d\n", _PAGE_VALID_SHIFT);
 	pr_define("_PAGE_DIRTY_SHIFT %d\n", _PAGE_DIRTY_SHIFT);
+#ifdef CONFIG_HUGETLB_PAGE
 	pr_define("_PAGE_HUGE_SHIFT %d\n", _PAGE_HUGE_SHIFT);
+#endif
 	pr_define("_PAGE_GLOBAL_SHIFT %d\n", _PAGE_GLOBAL_SHIFT);
+
 	pr_define("_PAGE_PRESENT_SHIFT %d\n", _PAGE_PRESENT_SHIFT);
 	pr_define("_PAGE_WRITE_SHIFT %d\n", _PAGE_WRITE_SHIFT);
-	pr_define("_PAGE_NO_READ_SHIFT %d\n", _PAGE_NO_READ_SHIFT);
-	pr_define("_PAGE_NO_EXEC_SHIFT %d\n", _PAGE_NO_EXEC_SHIFT);
+
 	pr_define("_PFN_SHIFT %d\n", _PFN_SHIFT);
 	pr_debug("\n");
 }
@@ -261,16 +260,17 @@ void setup_tlb_handler(void)
 
 	/* The tlb handlers are generated only once */
 	if (!run_once) {
-		memcpy((void *)tlbrentry, handle_tlb_refill, 0x80);
-		local_flush_icache_range(tlbrentry, tlbrentry + 0x80);
+		memcpy((void *)tlbrentry, handle_tlb_refill, 0x200);
+		local_flush_icache_range(tlbrentry, tlbrentry + 0x200);
 		run_once++;
 	}
 }
 void tlb_init(void)
 {
 	write_csr_pagesize(PS_DEFAULT_SIZE);
+#ifdef CONFIG_64BIT
 	write_csr_stlbpgsize(PS_DEFAULT_SIZE);
-
+#endif
 	if (read_csr_pagesize() != PS_DEFAULT_SIZE)
 		panic("MMU doesn't support PAGE_SIZE=0x%lx", PAGE_SIZE);
 
diff --git a/arch/loongarch/mm/tlbex-32.S b/arch/loongarch/mm/tlbex-32.S
new file mode 100644
index 000000000000..a2805464cbda
--- /dev/null
+++ b/arch/loongarch/mm/tlbex-32.S
@@ -0,0 +1,307 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2020-2021 Loongson Technology Corporation Limited
+ */
+#include <asm/asm.h>
+#include <asm/export.h>
+#include <asm/loongarchregs.h>
+#include <asm/page.h>
+#include <asm/pgtable-bits.h>
+#include <asm/regdef.h>
+#include <asm/stackframe.h>
+
+#include <asm/pgtable-32.h>
+
+	.macro tlb_do_page_fault, write
+	SYM_FUNC_START(tlb_do_page_fault_\write)
+	SAVE_ALL
+	csrrd	a2, LOONGARCH_CSR_BADV
+	KMODE
+	move	a0, sp
+	REG_S	a2, sp, PT_BVADDR
+	li.w	a1, \write
+	la.abs	t0, do_page_fault
+	jirl    ra, t0, 0
+	la.abs	t0, ret_from_exception
+	jirl    zero, t0, 0
+	SYM_FUNC_END(tlb_do_page_fault_\write)
+	.endm
+
+SYM_FUNC_START(handle_tlb_rixi)
+	csrwr	t0, EXCEPTION_KS0
+	csrwr	t1, EXCEPTION_KS1
+SYM_FUNC_END(handle_tlb_rixi)
+	/* Go through */
+	tlb_do_page_fault 0
+	tlb_do_page_fault 1
+
+
+SYM_FUNC_START(handle_tlb_load)
+	csrwr	ra, EXCEPTION_KS2
+
+	lu12i.w	ra, 0xc
+	slli.w	ra, ra, 0x10
+	csrrd	t0, LOONGARCH_CSR_BADV
+	bgeu	t0, ra, vmalloc_load
+
+	csrrd	t1, LOONGARCH_CSR_PGD
+
+vmalloc_done_load:
+	/* Get PGD offset in bytes */
+	srli.w	t0, t0, 0x16
+	andi	t0, t0,	0x3ff
+	slli.w	t0, t0, 0x2
+	add.w	t1, t1, t0
+	csrrd	t0, LOONGARCH_CSR_BADV
+	ld.w	t1, t1, 0
+	srli.w	t0, t0, 0xc
+	andi	t0, t0, 0x3ff
+	slli.w	t0, t0, 0x2
+	add.w	t0, t0, t1
+
+label_smp_pgtable_load:
+	ld.w	t1, t0, 0
+	tlbsrch
+
+	srli.w  ra, t1, _PAGE_PRESENT_SHIFT
+	andi    ra, ra, 1
+	beq     ra, zero, nopage_tlb_load
+
+
+	ori	t1, t1, _PAGE_VALID
+	st.w	t1, t0, 0
+
+	ori	t0, t0, 0x4
+	xori	t0, t0, 0x4
+
+	ld.w	t1, t0, 0
+	srli.w	ra, t1, 0xc
+	slli.w	ra, ra, 0x8
+	andi	t1, t1, 0xff
+	add.w	t1, t1, ra
+	csrwr	t1, LOONGARCH_CSR_TLBELO0
+
+	ld.w	t0, t0, 0x4
+	srli.w  ra, t0, 0xc
+        slli.w  ra, ra, 0x8
+        andi    t0, t0, 0xff
+        add.w   t0, t0, ra
+	csrwr	t0, LOONGARCH_CSR_TLBELO1
+
+	tlbwr
+
+	csrrd	t0, LOONGARCH_CSR_KS0
+	csrrd	t1, LOONGARCH_CSR_KS1
+	csrrd	ra, EXCEPTION_KS2
+	ertn
+
+vmalloc_load:
+	la.abs  t1, swapper_pg_dir
+	b       vmalloc_done_load
+
+	/*
+	 * This is the entry point when build_tlbchange_handler_head
+	 * spots a huge page.
+	 */
+
+nopage_tlb_load:
+	dbar	0
+        csrrd   ra, EXCEPTION_KS2
+	la.abs	t0, tlb_do_page_fault_0
+	jirl	$r0, t0, 0
+
+SYM_FUNC_END(handle_tlb_load)
+
+
+
+
+SYM_FUNC_START(handle_tlb_store)
+	csrwr	ra, EXCEPTION_KS2
+
+	lu12i.w ra, 0xc
+        slli.w  ra, ra, 0x10
+	csrrd	t0, LOONGARCH_CSR_BADV
+	bgeu    t0, ra, vmalloc_store
+
+	csrrd	t1, LOONGARCH_CSR_PGD
+
+vmalloc_done_store:
+	/* Get PGD offset in bytes */
+	srli.w	t0, t0, 0x16
+	andi	t0, t0, 0x3ff
+	slli.w	t0, t0, 2
+	add.w	t1, t1, t0
+	csrrd	t0, LOONGARCH_CSR_BADV
+	ld.w	t1, t1, 0
+	srli.w	t0, t0, 0xc
+	andi	t0, t0, 0x3ff
+	slli.w	t0, t0, 0x2
+	add.w	t1, t1, t0
+
+label_smp_pgtable_store:
+	ld.w	t0, t1, 0
+	tlbsrch
+
+	srli.w  ra, t0, _PAGE_PRESENT_SHIFT
+        andi    ra, ra, ((_PAGE_PRESENT | _PAGE_WRITE) >> _PAGE_PRESENT_SHIFT)
+	xori    ra, ra, ((_PAGE_PRESENT | _PAGE_WRITE) >> _PAGE_PRESENT_SHIFT)
+	bne	ra, $r0, nopage_tlb_store
+
+	ori	t0, t0, (_PAGE_VALID | _PAGE_DIRTY)
+	st.w	t0, t1, 0
+
+	ori	t1, t1, 4
+	xori	t1, t1, 4
+
+	ld.w	t0, t1, 0
+	srli.w  ra, t0, 0xc
+        slli.w  ra, ra, 0x8
+        andi    t0, t0, 0xff
+        add.w   t0, t0, ra
+	csrwr   t0, LOONGARCH_CSR_TLBELO0
+
+	ld.w	t1, t1, 4
+	srli.w  ra, t1, 0xc
+        slli.w  ra, ra, 0x8
+        andi    t1, t1, 0xff
+        add.w   t1, t1, ra
+	csrwr	t1, LOONGARCH_CSR_TLBELO1
+
+	tlbwr
+
+	csrrd   t0, LOONGARCH_CSR_KS0
+	csrrd	t1, LOONGARCH_CSR_KS1
+	csrrd	ra, EXCEPTION_KS2
+	ertn
+
+vmalloc_store:
+        la.abs  t1, swapper_pg_dir
+        b       vmalloc_done_store
+
+	/*
+	 * This is the entry point when build_tlbchange_handler_head
+	 * spots a huge page.
+	 */
+
+nopage_tlb_store:
+	dbar	0
+	csrrd	ra, EXCEPTION_KS2
+	la.abs	t0, tlb_do_page_fault_1
+	jirl	$r0, t0, 0
+
+SYM_FUNC_END(handle_tlb_store)
+
+SYM_FUNC_START(handle_tlb_modify)
+	csrwr	ra, EXCEPTION_KS2
+
+	/*
+	 * The vmalloc handling is not in the hotpath.
+	 */
+	lu12i.w ra, 0xc
+        slli.w  ra, ra, 0x10
+        csrrd   t0, LOONGARCH_CSR_BADV
+        bgeu    t0, ra, vmalloc_modify
+
+	csrrd	t1, LOONGARCH_CSR_PGD
+
+vmalloc_done_modify:
+	/* Get PGD offset in bytes */
+	srli.w	t0, t0, 0x16
+	andi	t0, t0, 0x3ff
+	slli.w	t0, t0, 2
+	add.w	t1, t1, t0
+	csrrd	t0, LOONGARCH_CSR_BADV
+	ld.w	t1, t1, 0
+	srli.w	t0, t0, 0xc
+	andi	t0, t0, 0x3ff
+	slli.w	t0, t0, 0x2
+	add.w	t1, t1, t0
+
+label_smp_pgtable_modify:
+	ld.w	t0, t1, 0
+	tlbsrch
+
+	srli.w  ra, t0, _PAGE_WRITE_SHIFT
+        andi    ra, ra, 1
+	beq	ra, $r0, nopage_tlb_modify
+
+	ori	t0, t0, (_PAGE_VALID | _PAGE_DIRTY)
+	st.w	t0, t1, 0
+
+	ori	t1, t1, 4
+	xori	t1, t1, 4
+
+	ld.w	t0, t1, 0
+        srli.w  ra, t0, 0xc
+        slli.w  ra, ra, 0x8
+        andi    t0, t0, 0xff
+        add.w   t0, t0, ra
+	csrwr   t0, LOONGARCH_CSR_TLBELO0
+
+	ld.w	t1, t1, 0x4
+	srli.w  ra, t1, 0xc
+        slli.w  ra, ra, 0x8
+        andi    t1, t1, 0xff
+        add.w   t1, t1, ra
+	csrwr	t1, LOONGARCH_CSR_TLBELO1
+
+	tlbwr
+
+	csrrd	t0, LOONGARCH_CSR_KS0
+	csrrd	t1, LOONGARCH_CSR_KS1
+	csrrd	ra, EXCEPTION_KS2
+	ertn
+
+vmalloc_modify:
+        la.abs  t1, swapper_pg_dir
+        b       vmalloc_done_modify
+
+
+nopage_tlb_modify:
+	dbar	0
+	csrrd	ra, EXCEPTION_KS2
+	la.abs	t0, tlb_do_page_fault_1
+	jirl	$r0, t0, 0
+
+SYM_FUNC_END(handle_tlb_modify)
+
+SYM_FUNC_START(handle_tlb_refill)
+	csrwr	t0, LOONGARCH_CSR_KS0
+	csrwr   t1, LOONGARCH_CSR_KS1
+	csrwr   ra, EXCEPTION_KS2
+
+	csrrd	t0, LOONGARCH_CSR_PGD
+	csrrd   t1, LOONGARCH_CSR_BADV
+	srli.w	t1, t1, 0x16
+	slli.w	t1, t1, 0x2
+	add.w	t0, t0, t1
+	li.w	ra, 0xfffffff
+	and	t0, t0, ra
+	ld.w	t0, t0, 0
+
+	csrrd	t1, LOONGARCH_CSR_BADV
+	srli.w	t1, t1, 0xa
+	andi	t1, t1, 0xff8
+	add.w	t0, t0, t1
+	and	t0, t0, ra
+
+	ld.w	t1, t0, 0
+	srli.w  ra, t1, 0xc
+        slli.w  ra, ra, 0x8
+        andi    t1, t1, 0xff
+        add.w   t1, t1, ra
+	csrwr	t1, LOONGARCH_CSR_TLBELO0
+
+	ld.w	t1, t0, 0x4
+	srli.w  ra, t1, 0xc
+        slli.w  ra, ra, 0x8
+        andi    t1, t1, 0xff
+        add.w   t1, t1, ra
+	csrwr	t1, LOONGARCH_CSR_TLBELO1
+
+	tlbfill
+	csrrd	t0, LOONGARCH_CSR_KS0
+	csrrd   t1, LOONGARCH_CSR_KS1
+	csrrd   ra, EXCEPTION_KS2
+	ertn
+SYM_FUNC_END(handle_tlb_refill)
diff --git a/arch/loongarch/pci/pci.c b/arch/loongarch/pci/pci.c
index 24105cd53227..c031d7828793 100644
--- a/arch/loongarch/pci/pci.c
+++ b/arch/loongarch/pci/pci.c
@@ -181,6 +181,7 @@ int pcibios_dev_init(struct pci_dev *dev)
 		return 0;
 	return acpi_pci_irq_enable(dev);
 #endif
+	return 0;
 }
 
 int pcibios_enable_device(struct pci_dev *dev, int mask)
diff --git a/arch/loongarch/vdso/vdso.lds.S b/arch/loongarch/vdso/vdso.lds.S
index b453ed085b17..e1cd6b6f9ebf 100644
--- a/arch/loongarch/vdso/vdso.lds.S
+++ b/arch/loongarch/vdso/vdso.lds.S
@@ -4,7 +4,13 @@
  * Copyright (C) 2020-2021 Loongson Technology Corporation Limited
  */
 
+#ifdef CONFIG_32BIT
+OUTPUT_FORMAT("elf32-loongarch", "elf32-loongarch", "elf32-loongarch")
+#endif
+
+#ifdef CONFIG_64BIT
 OUTPUT_FORMAT("elf64-loongarch", "elf64-loongarch", "elf64-loongarch")
+#endif
 
 OUTPUT_ARCH(loongarch)
 
diff --git a/config.back b/config.back
new file mode 100644
index 000000000000..fe1b73c09462
--- /dev/null
+++ b/config.back
@@ -0,0 +1,2152 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Linux/loongarch 5.14.0-rc2 Kernel Configuration
+#
+CONFIG_CC_VERSION_TEXT="loongarch32-linux-gnu-gcc (GCC) 8.3.0"
+CONFIG_CC_IS_GCC=y
+CONFIG_GCC_VERSION=80300
+CONFIG_CLANG_VERSION=0
+CONFIG_AS_IS_GNU=y
+CONFIG_AS_VERSION=23101
+CONFIG_LD_IS_BFD=y
+CONFIG_LD_VERSION=23101
+CONFIG_LLD_VERSION=0
+CONFIG_CC_CAN_LINK=y
+CONFIG_CC_CAN_LINK_STATIC=y
+CONFIG_CC_HAS_ASM_GOTO=y
+CONFIG_CC_HAS_ASM_INLINE=y
+CONFIG_CC_HAS_NO_PROFILE_FN_ATTR=y
+CONFIG_IRQ_WORK=y
+CONFIG_BUILDTIME_TABLE_SORT=y
+
+#
+# General setup
+#
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+# CONFIG_COMPILE_TEST is not set
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_BUILD_SALT=""
+CONFIG_DEFAULT_INIT=""
+CONFIG_DEFAULT_HOSTNAME="(none)"
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_WATCH_QUEUE is not set
+CONFIG_CROSS_MEMORY_ATTACH=y
+# CONFIG_USELIB is not set
+# CONFIG_AUDIT is not set
+CONFIG_HAVE_ARCH_AUDITSYSCALL=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK=y
+CONFIG_GENERIC_IRQ_CHIP=y
+CONFIG_IRQ_DOMAIN=y
+CONFIG_HANDLE_DOMAIN_IRQ=y
+CONFIG_IRQ_FORCED_THREADING=y
+# end of IRQ subsystem
+
+CONFIG_GENERIC_TIME_VSYSCALL=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_GENERIC_CMOS_UPDATE=y
+
+#
+# Timers subsystem
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ_COMMON=y
+# CONFIG_HZ_PERIODIC is not set
+CONFIG_NO_HZ_IDLE=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+# end of Timers subsystem
+
+CONFIG_BPF=y
+
+#
+# BPF subsystem
+#
+CONFIG_BPF_SYSCALL=y
+# CONFIG_BPF_UNPRIV_DEFAULT_OFF is not set
+# CONFIG_BPF_PRELOAD is not set
+# end of BPF subsystem
+
+# CONFIG_PREEMPT_NONE is not set
+# CONFIG_PREEMPT_VOLUNTARY is not set
+CONFIG_PREEMPT=y
+CONFIG_PREEMPT_COUNT=y
+CONFIG_PREEMPTION=y
+
+#
+# CPU/Task time and stats accounting
+#
+CONFIG_TICK_CPU_ACCOUNTING=y
+# CONFIG_VIRT_CPU_ACCOUNTING_GEN is not set
+# CONFIG_IRQ_TIME_ACCOUNTING is not set
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_BSD_PROCESS_ACCT_V3=y
+# CONFIG_TASKSTATS is not set
+# CONFIG_PSI is not set
+# end of CPU/Task time and stats accounting
+
+#
+# RCU Subsystem
+#
+CONFIG_TREE_RCU=y
+CONFIG_PREEMPT_RCU=y
+# CONFIG_RCU_EXPERT is not set
+CONFIG_SRCU=y
+CONFIG_TREE_SRCU=y
+CONFIG_TASKS_RCU_GENERIC=y
+CONFIG_TASKS_RCU=y
+CONFIG_TASKS_TRACE_RCU=y
+CONFIG_RCU_STALL_COMMON=y
+CONFIG_RCU_NEED_SEGCBLIST=y
+# end of RCU Subsystem
+
+# CONFIG_IKCONFIG is not set
+# CONFIG_IKHEADERS is not set
+CONFIG_LOG_BUF_SHIFT=18
+CONFIG_PRINTK_SAFE_LOG_BUF_SHIFT=13
+
+#
+# Scheduler features
+#
+# end of Scheduler features
+
+CONFIG_CGROUPS=y
+CONFIG_PAGE_COUNTER=y
+CONFIG_MEMCG=y
+CONFIG_MEMCG_KMEM=y
+CONFIG_CGROUP_SCHED=y
+CONFIG_FAIR_GROUP_SCHED=y
+CONFIG_CFS_BANDWIDTH=y
+CONFIG_RT_GROUP_SCHED=y
+CONFIG_CGROUP_PIDS=y
+# CONFIG_CGROUP_RDMA is not set
+CONFIG_CGROUP_FREEZER=y
+CONFIG_CGROUP_DEVICE=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_CGROUP_PERF=y
+CONFIG_CGROUP_BPF=y
+# CONFIG_CGROUP_MISC is not set
+# CONFIG_CGROUP_DEBUG is not set
+CONFIG_SOCK_CGROUP_DATA=y
+# CONFIG_NAMESPACES is not set
+CONFIG_CHECKPOINT_RESTORE=y
+CONFIG_SCHED_AUTOGROUP=y
+CONFIG_SYSFS_DEPRECATED=y
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
+CONFIG_RELAY=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE="~/work/initrd_pck32"
+CONFIG_INITRAMFS_ROOT_UID=0
+CONFIG_INITRAMFS_ROOT_GID=0
+CONFIG_RD_GZIP=y
+CONFIG_RD_BZIP2=y
+# CONFIG_RD_LZMA is not set
+# CONFIG_RD_XZ is not set
+# CONFIG_RD_LZO is not set
+# CONFIG_RD_LZ4 is not set
+# CONFIG_RD_ZSTD is not set
+CONFIG_INITRAMFS_COMPRESSION_GZIP=y
+# CONFIG_INITRAMFS_COMPRESSION_BZIP2 is not set
+# CONFIG_INITRAMFS_COMPRESSION_NONE is not set
+# CONFIG_BOOT_CONFIG is not set
+CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+CONFIG_SYSCTL_EXCEPTION_TRACE=y
+CONFIG_EXPERT=y
+CONFIG_MULTIUSER=y
+# CONFIG_SGETMASK_SYSCALL is not set
+CONFIG_SYSFS_SYSCALL=y
+CONFIG_FHANDLE=y
+CONFIG_POSIX_TIMERS=y
+CONFIG_PRINTK=y
+CONFIG_PRINTK_NMI=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_FUTEX_PI=y
+CONFIG_HAVE_FUTEX_CMPXCHG=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_IO_URING=y
+CONFIG_ADVISE_SYSCALLS=y
+CONFIG_MEMBARRIER=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+CONFIG_KALLSYMS_BASE_RELATIVE=y
+CONFIG_USERFAULTFD=y
+CONFIG_KCMP=y
+CONFIG_RSEQ=y
+# CONFIG_DEBUG_RSEQ is not set
+# CONFIG_EMBEDDED is not set
+CONFIG_HAVE_PERF_EVENTS=y
+CONFIG_PERF_USE_VMALLOC=y
+# CONFIG_PC104 is not set
+
+#
+# Kernel Performance Events And Counters
+#
+CONFIG_PERF_EVENTS=y
+# CONFIG_DEBUG_PERF_USE_VMALLOC is not set
+# end of Kernel Performance Events And Counters
+
+# CONFIG_VM_EVENT_COUNTERS is not set
+# CONFIG_SLUB_DEBUG is not set
+# CONFIG_COMPAT_BRK is not set
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+# CONFIG_SLOB is not set
+CONFIG_SLAB_MERGE_DEFAULT=y
+# CONFIG_SLAB_FREELIST_RANDOM is not set
+# CONFIG_SLAB_FREELIST_HARDENED is not set
+# CONFIG_SHUFFLE_PAGE_ALLOCATOR is not set
+# CONFIG_PROFILING is not set
+# end of General setup
+
+CONFIG_LOONGARCH=y
+
+#
+# Machine selection
+#
+# CONFIG_MACH_LOONGSON64 is not set
+CONFIG_MACH_LOONGSON32=y
+# CONFIG_LOONGSON_MACH3X is not set
+CONFIG_MACH_LOONGSON_32=y
+CONFIG_LOONGSON_UART_BASE=y
+CONFIG_LEFI_FIRMWARE_INTERFACE=y
+# end of Machine selection
+
+CONFIG_SYS_HAS_EARLY_PRINTK=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_SCHED_OMIT_FRAME_POINTER=y
+CONFIG_GENERIC_CSUM=y
+CONFIG_L1_CACHE_SHIFT=6
+
+#
+# CPU selection
+#
+CONFIG_CPU_LOONGSON32=y
+CONFIG_SYS_HAS_CPU_LOONGSON32=y
+# end of CPU selection
+
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+
+#
+# Kernel type
+#
+CONFIG_32BIT=y
+CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_16KB is not set
+# CONFIG_PAGE_SIZE_64KB is not set
+CONFIG_FORCE_MAX_ZONEORDER=12
+CONFIG_CPU_HAS_PREFETCH=y
+CONFIG_CPU_HAS_FPU=y
+CONFIG_ARCH_SELECT_MEMORY_MODEL=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_ARCH_SPARSEMEM_ENABLE=y
+# CONFIG_DMI is not set
+CONFIG_EFI=y
+# CONFIG_HZ_100 is not set
+CONFIG_HZ_250=y
+# CONFIG_HZ_300 is not set
+# CONFIG_HZ_1000 is not set
+CONFIG_HZ=250
+CONFIG_SCHED_HRTICK=y
+# CONFIG_SECCOMP is not set
+CONFIG_BUILTIN_DTB=y
+CONFIG_BUILTIN_DTB_NAME="loongson32_ls"
+# end of Kernel type
+
+CONFIG_ARCH_ENABLE_MEMORY_HOTPLUG=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_PGTABLE_LEVELS=2
+CONFIG_MMU=y
+CONFIG_ARCH_MMAP_RND_BITS_MIN=8
+CONFIG_ARCH_MMAP_RND_BITS_MAX=15
+CONFIG_ZONE_DMA32=y
+
+#
+# Bus options
+#
+# end of Bus options
+
+#
+# Power management options
+#
+CONFIG_ARCH_SUPPORTS_ACPI=y
+# CONFIG_ACPI is not set
+# end of Power management options
+
+#
+# Firmware Drivers
+#
+# CONFIG_FIRMWARE_MEMMAP is not set
+# CONFIG_GOOGLE_FIRMWARE is not set
+
+#
+# EFI (Extensible Firmware Interface) Support
+#
+CONFIG_EFI_ESRT=y
+CONFIG_EFI_RUNTIME_WRAPPERS=y
+# CONFIG_EFI_BOOTLOADER_CONTROL is not set
+# CONFIG_EFI_CAPSULE_LOADER is not set
+# CONFIG_EFI_TEST is not set
+# CONFIG_EFI_DISABLE_PCI_DMA is not set
+# end of EFI (Extensible Firmware Interface) Support
+
+CONFIG_EFI_EARLYCON=y
+
+#
+# Tegra firmware driver
+#
+# end of Tegra firmware driver
+# end of Firmware Drivers
+
+#
+# General architecture-dependent options
+#
+CONFIG_CRASH_CORE=y
+CONFIG_ARCH_USE_BUILTIN_BSWAP=y
+CONFIG_HAVE_IOREMAP_PROT=y
+CONFIG_HAVE_NMI=y
+CONFIG_HAVE_ARCH_TRACEHOOK=y
+CONFIG_HAVE_DMA_CONTIGUOUS=y
+CONFIG_GENERIC_SMP_IDLE_THREAD=y
+CONFIG_HAVE_ASM_MODVERSIONS=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_RSEQ=y
+CONFIG_HAVE_ARCH_SECCOMP=y
+CONFIG_HAVE_ARCH_SECCOMP_FILTER=y
+CONFIG_LTO_NONE=y
+CONFIG_HAVE_CONTEXT_TRACKING=y
+CONFIG_HAVE_VIRT_CPU_ACCOUNTING_GEN=y
+CONFIG_HAVE_IRQ_TIME_ACCOUNTING=y
+CONFIG_HAVE_MOD_ARCH_SPECIFIC=y
+CONFIG_HAVE_IRQ_EXIT_ON_IRQ_STACK=y
+CONFIG_ARCH_HAS_ELF_RANDOMIZE=y
+CONFIG_HAVE_ARCH_MMAP_RND_BITS=y
+CONFIG_HAVE_EXIT_THREAD=y
+CONFIG_ARCH_MMAP_RND_BITS=12
+CONFIG_COMPAT_32BIT_TIME=y
+CONFIG_HAVE_ARCH_COMPILER_H=y
+CONFIG_ARCH_USE_MEMREMAP_PROT=y
+
+#
+# GCOV-based kernel profiling
+#
+# end of GCOV-based kernel profiling
+# end of General architecture-dependent options
+
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+# CONFIG_MODULES is not set
+CONFIG_MODULES_TREE_LOOKUP=y
+# CONFIG_BLOCK is not set
+CONFIG_UNINLINE_SPIN_UNLOCK=y
+CONFIG_ARCH_SUPPORTS_ATOMIC_RMW=y
+CONFIG_ARCH_USE_QUEUED_SPINLOCKS=y
+CONFIG_ARCH_USE_QUEUED_RWLOCKS=y
+CONFIG_FREEZER=y
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+CONFIG_ARCH_BINFMT_ELF_STATE=y
+CONFIG_ELFCORE=y
+CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS=y
+CONFIG_BINFMT_SCRIPT=y
+CONFIG_BINFMT_MISC=y
+CONFIG_COREDUMP=y
+# end of Executable file formats
+
+#
+# Memory Management options
+#
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_SPARSEMEM_STATIC=y
+CONFIG_HAVE_FAST_GUP=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+CONFIG_COMPACTION=y
+# CONFIG_PAGE_REPORTING is not set
+CONFIG_MIGRATION=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+CONFIG_NEED_PER_CPU_KM=y
+# CONFIG_CLEANCACHE is not set
+# CONFIG_CMA is not set
+# CONFIG_ZPOOL is not set
+# CONFIG_ZSMALLOC is not set
+# CONFIG_IDLE_PAGE_TRACKING is not set
+# CONFIG_PERCPU_STATS is not set
+
+#
+# GUP_TEST needs to have DEBUG_FS enabled
+#
+# end of Memory Management options
+
+CONFIG_NET=y
+
+#
+# Networking options
+#
+# CONFIG_PACKET is not set
+CONFIG_UNIX=y
+CONFIG_UNIX_SCM=y
+# CONFIG_UNIX_DIAG is not set
+# CONFIG_TLS is not set
+# CONFIG_XFRM_USER is not set
+# CONFIG_NET_KEY is not set
+# CONFIG_XDP_SOCKETS is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+# CONFIG_IP_PNP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE_DEMUX is not set
+CONFIG_NET_IP_TUNNEL=y
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_NET_IPVTI is not set
+# CONFIG_NET_FOU is not set
+# CONFIG_NET_FOU_IP_TUNNELS is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+CONFIG_INET_TUNNEL=y
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_INET_UDP_DIAG is not set
+# CONFIG_INET_RAW_DIAG is not set
+# CONFIG_INET_DIAG_DESTROY is not set
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+CONFIG_IPV6=y
+# CONFIG_IPV6_ROUTER_PREF is not set
+# CONFIG_IPV6_OPTIMISTIC_DAD is not set
+# CONFIG_INET6_AH is not set
+# CONFIG_INET6_ESP is not set
+# CONFIG_INET6_IPCOMP is not set
+# CONFIG_IPV6_MIP6 is not set
+# CONFIG_IPV6_VTI is not set
+CONFIG_IPV6_SIT=y
+# CONFIG_IPV6_SIT_6RD is not set
+CONFIG_IPV6_NDISC_NODETYPE=y
+# CONFIG_IPV6_TUNNEL is not set
+# CONFIG_IPV6_MULTIPLE_TABLES is not set
+# CONFIG_IPV6_MROUTE is not set
+# CONFIG_IPV6_SEG6_LWTUNNEL is not set
+# CONFIG_IPV6_SEG6_HMAC is not set
+# CONFIG_IPV6_RPL_LWTUNNEL is not set
+# CONFIG_MPTCP is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_BPFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_L2TP is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_PHONET is not set
+# CONFIG_6LOWPAN is not set
+# CONFIG_IEEE802154 is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_DCB is not set
+# CONFIG_BATMAN_ADV is not set
+# CONFIG_OPENVSWITCH is not set
+# CONFIG_VSOCKETS is not set
+# CONFIG_NETLINK_DIAG is not set
+# CONFIG_MPLS is not set
+# CONFIG_NET_NSH is not set
+# CONFIG_HSR is not set
+# CONFIG_NET_SWITCHDEV is not set
+# CONFIG_NET_L3_MASTER_DEV is not set
+# CONFIG_QRTR is not set
+# CONFIG_NET_NCSI is not set
+# CONFIG_CGROUP_NET_PRIO is not set
+# CONFIG_CGROUP_NET_CLASSID is not set
+CONFIG_NET_RX_BUSY_POLL=y
+CONFIG_BQL=y
+# CONFIG_BPF_STREAM_PARSER is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# end of Network testing
+# end of Networking options
+
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+# CONFIG_AF_KCM is not set
+CONFIG_WIRELESS=y
+# CONFIG_CFG80211 is not set
+
+#
+# CFG80211 needs to be enabled for MAC80211
+#
+CONFIG_MAC80211_STA_HASH_MAX_SIZE=0
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+# CONFIG_CAIF is not set
+# CONFIG_CEPH_LIB is not set
+# CONFIG_NFC is not set
+# CONFIG_PSAMPLE is not set
+# CONFIG_NET_IFE is not set
+# CONFIG_LWTUNNEL is not set
+CONFIG_DST_CACHE=y
+CONFIG_GRO_CELLS=y
+CONFIG_NET_SELFTESTS=y
+CONFIG_NET_SOCK_MSG=y
+CONFIG_PAGE_POOL=y
+# CONFIG_FAILOVER is not set
+CONFIG_ETHTOOL_NETLINK=y
+
+#
+# Device Drivers
+#
+CONFIG_PCI_MSI_ARCH_FALLBACKS=y
+CONFIG_PCCARD=y
+CONFIG_PCMCIA=y
+CONFIG_PCMCIA_LOAD_CIS=y
+
+#
+# PC-card bridges
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER=y
+CONFIG_UEVENT_HELPER_PATH=""
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+
+#
+# Firmware loader
+#
+CONFIG_FW_LOADER=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_FW_LOADER_USER_HELPER is not set
+# CONFIG_FW_LOADER_COMPRESS is not set
+# end of Firmware loader
+
+CONFIG_ALLOW_DEV_COREDUMP=y
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_DEBUG_TEST_DRIVER_REMOVE is not set
+CONFIG_GENERIC_CPU_AUTOPROBE=y
+CONFIG_REGMAP=y
+CONFIG_REGMAP_MMIO=y
+CONFIG_DMA_SHARED_BUFFER=y
+# CONFIG_DMA_FENCE_TRACE is not set
+# end of Generic Driver Options
+
+#
+# Bus devices
+#
+# CONFIG_MHI_BUS is not set
+# end of Bus devices
+
+# CONFIG_CONNECTOR is not set
+# CONFIG_GNSS is not set
+CONFIG_MTD=y
+
+#
+# Partition parsers
+#
+# CONFIG_MTD_AR7_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+CONFIG_MTD_OF_PARTS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# end of Partition parsers
+
+#
+# User Modules And Translation Layers
+#
+# CONFIG_MTD_OOPS is not set
+CONFIG_MTD_PARTITIONED_MASTER=y
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+CONFIG_MTD_JEDECPROBE=y
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_MTD_CFI_AMDSTD=y
+CONFIG_MTD_CFI_STAA=y
+CONFIG_MTD_CFI_UTIL=y
+CONFIG_MTD_RAM=y
+CONFIG_MTD_ROM=y
+# CONFIG_MTD_ABSENT is not set
+# end of RAM/ROM/Flash chip drivers
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PHYSMAP is not set
+# CONFIG_MTD_PLATRAM is not set
+# end of Mapping drivers for chip access
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOCG3 is not set
+# end of Self-contained MTD device drivers
+
+#
+# NAND
+#
+CONFIG_MTD_NAND_CORE=y
+# CONFIG_MTD_ONENAND is not set
+CONFIG_MTD_RAW_NAND=y
+
+#
+# Raw/parallel NAND flash controllers
+#
+# CONFIG_MTD_NAND_DENALI_DT is not set
+# CONFIG_MTD_NAND_MXIC is not set
+# CONFIG_MTD_NAND_GPIO is not set
+# CONFIG_MTD_NAND_PLATFORM is not set
+# CONFIG_MTD_NAND_CADENCE is not set
+# CONFIG_MTD_NAND_ARASAN is not set
+# CONFIG_MTD_NAND_INTEL_LGM is not set
+
+#
+# Misc
+#
+# CONFIG_MTD_NAND_NANDSIM is not set
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+
+#
+# ECC engine support
+#
+CONFIG_MTD_NAND_ECC=y
+# CONFIG_MTD_NAND_ECC_SW_HAMMING is not set
+CONFIG_MTD_NAND_ECC_SW_BCH=y
+# end of ECC engine support
+# end of NAND
+
+#
+# LPDDR & LPDDR2 PCM memory drivers
+#
+# CONFIG_MTD_LPDDR is not set
+# end of LPDDR & LPDDR2 PCM memory drivers
+
+# CONFIG_MTD_UBI is not set
+# CONFIG_MTD_HYPERBUS is not set
+CONFIG_DTC=y
+CONFIG_OF=y
+# CONFIG_OF_UNITTEST is not set
+CONFIG_OF_FLATTREE=y
+CONFIG_OF_EARLY_FLATTREE=y
+CONFIG_OF_KOBJ=y
+CONFIG_OF_DYNAMIC=y
+CONFIG_OF_ADDRESS=y
+CONFIG_OF_IRQ=y
+CONFIG_OF_NET=y
+CONFIG_OF_RESERVED_MEM=y
+CONFIG_OF_RESOLVE=y
+CONFIG_OF_OVERLAY=y
+# CONFIG_PARPORT is not set
+
+#
+# NVME Support
+#
+# end of NVME Support
+
+#
+# Misc devices
+#
+# CONFIG_DUMMY_IRQ is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_SRAM is not set
+# CONFIG_XILINX_SDFEC is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_93CX6 is not set
+# end of EEPROM support
+
+#
+# Texas Instruments shared transport line discipline
+#
+# CONFIG_TI_ST is not set
+# end of Texas Instruments shared transport line discipline
+
+#
+# Altera FPGA firmware download module (requires I2C)
+#
+# CONFIG_ECHO is not set
+# CONFIG_PVPANIC is not set
+# end of Misc devices
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+# end of SCSI device support
+
+CONFIG_NETDEVICES=y
+CONFIG_MII=y
+CONFIG_NET_CORE=y
+# CONFIG_BONDING is not set
+# CONFIG_DUMMY is not set
+# CONFIG_WIREGUARD is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_NET_TEAM is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_IPVLAN is not set
+# CONFIG_VXLAN is not set
+# CONFIG_GENEVE is not set
+# CONFIG_BAREUDP is not set
+# CONFIG_GTP is not set
+# CONFIG_MACSEC is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_TUN is not set
+# CONFIG_TUN_VNET_CROSS_LE is not set
+# CONFIG_VETH is not set
+# CONFIG_NLMON is not set
+# CONFIG_ARCNET is not set
+CONFIG_ETHERNET=y
+CONFIG_NET_VENDOR_3COM=y
+# CONFIG_PCMCIA_3C574 is not set
+# CONFIG_PCMCIA_3C589 is not set
+CONFIG_NET_VENDOR_ALACRITECH=y
+# CONFIG_ALTERA_TSE is not set
+CONFIG_NET_VENDOR_AMAZON=y
+CONFIG_NET_VENDOR_AMD=y
+# CONFIG_PCMCIA_NMCLAN is not set
+CONFIG_NET_VENDOR_AQUANTIA=y
+CONFIG_NET_VENDOR_ARC=y
+CONFIG_NET_VENDOR_BROADCOM=y
+# CONFIG_B44 is not set
+# CONFIG_BCMGENET is not set
+# CONFIG_SYSTEMPORT is not set
+CONFIG_NET_VENDOR_CADENCE=y
+# CONFIG_MACB is not set
+CONFIG_NET_VENDOR_CAVIUM=y
+CONFIG_NET_VENDOR_CORTINA=y
+# CONFIG_GEMINI_ETHERNET is not set
+# CONFIG_DNET is not set
+CONFIG_NET_VENDOR_EZCHIP=y
+# CONFIG_EZCHIP_NPS_MANAGEMENT_ENET is not set
+CONFIG_NET_VENDOR_FUJITSU=y
+# CONFIG_PCMCIA_FMVJ18X is not set
+CONFIG_NET_VENDOR_GOOGLE=y
+CONFIG_NET_VENDOR_HUAWEI=y
+CONFIG_NET_VENDOR_I825XX=y
+CONFIG_NET_VENDOR_INTEL=y
+CONFIG_NET_VENDOR_MICROSOFT=y
+CONFIG_NET_VENDOR_MARVELL=y
+# CONFIG_MVMDIO is not set
+CONFIG_NET_VENDOR_MICREL=y
+# CONFIG_KS8851_MLL is not set
+CONFIG_NET_VENDOR_MICROCHIP=y
+CONFIG_NET_VENDOR_MICROSEMI=y
+CONFIG_NET_VENDOR_NATSEMI=y
+CONFIG_NET_VENDOR_NETRONOME=y
+CONFIG_NET_VENDOR_NI=y
+# CONFIG_NI_XGE_MANAGEMENT_ENET is not set
+CONFIG_NET_VENDOR_8390=y
+# CONFIG_PCMCIA_AXNET is not set
+# CONFIG_PCMCIA_PCNET is not set
+# CONFIG_ETHOC is not set
+CONFIG_NET_VENDOR_PENSANDO=y
+CONFIG_NET_VENDOR_QUALCOMM=y
+# CONFIG_QCOM_EMAC is not set
+# CONFIG_RMNET is not set
+CONFIG_NET_VENDOR_RENESAS=y
+CONFIG_NET_VENDOR_ROCKER=y
+CONFIG_NET_VENDOR_SAMSUNG=y
+# CONFIG_SXGBE_ETH is not set
+CONFIG_NET_VENDOR_SEEQ=y
+CONFIG_NET_VENDOR_SOLARFLARE=y
+CONFIG_NET_VENDOR_SMSC=y
+# CONFIG_PCMCIA_SMC91C92 is not set
+# CONFIG_SMSC911X is not set
+CONFIG_NET_VENDOR_SOCIONEXT=y
+CONFIG_NET_VENDOR_STMICRO=y
+CONFIG_STMMAC_ETH=y
+# CONFIG_STMMAC_SELFTESTS is not set
+CONFIG_STMMAC_PLATFORM=y
+# CONFIG_DWMAC_DWC_QOS_ETH is not set
+CONFIG_DWMAC_GENERIC=y
+# CONFIG_DWMAC_INTEL_PLAT is not set
+CONFIG_NET_VENDOR_SYNOPSYS=y
+# CONFIG_DWC_XLGMAC is not set
+CONFIG_NET_VENDOR_VIA=y
+# CONFIG_VIA_VELOCITY is not set
+CONFIG_NET_VENDOR_WIZNET=y
+# CONFIG_WIZNET_W5100 is not set
+# CONFIG_WIZNET_W5300 is not set
+CONFIG_NET_VENDOR_XILINX=y
+# CONFIG_XILINX_EMACLITE is not set
+# CONFIG_XILINX_AXI_EMAC is not set
+# CONFIG_XILINX_LL_TEMAC is not set
+CONFIG_NET_VENDOR_XIRCOM=y
+# CONFIG_PCMCIA_XIRC2PS is not set
+CONFIG_PHYLINK=y
+CONFIG_PHYLIB=y
+CONFIG_SWPHY=y
+CONFIG_FIXED_PHY=y
+
+#
+# MII PHY device drivers
+#
+# CONFIG_AMD_PHY is not set
+# CONFIG_ADIN_PHY is not set
+# CONFIG_AQUANTIA_PHY is not set
+# CONFIG_AX88796B_PHY is not set
+# CONFIG_BROADCOM_PHY is not set
+# CONFIG_BCM54140_PHY is not set
+# CONFIG_BCM7XXX_PHY is not set
+# CONFIG_BCM84881_PHY is not set
+# CONFIG_BCM87XX_PHY is not set
+# CONFIG_CICADA_PHY is not set
+# CONFIG_CORTINA_PHY is not set
+# CONFIG_DAVICOM_PHY is not set
+# CONFIG_ICPLUS_PHY is not set
+# CONFIG_LXT_PHY is not set
+# CONFIG_INTEL_XWAY_PHY is not set
+# CONFIG_LSI_ET1011C_PHY is not set
+# CONFIG_MARVELL_PHY is not set
+# CONFIG_MARVELL_10G_PHY is not set
+# CONFIG_MARVELL_88X2222_PHY is not set
+# CONFIG_MEDIATEK_GE_PHY is not set
+# CONFIG_MICREL_PHY is not set
+# CONFIG_MICROCHIP_PHY is not set
+# CONFIG_MICROCHIP_T1_PHY is not set
+# CONFIG_MICROSEMI_PHY is not set
+# CONFIG_MOTORCOMM_PHY is not set
+# CONFIG_NATIONAL_PHY is not set
+# CONFIG_NXP_C45_TJA11XX_PHY is not set
+# CONFIG_NXP_TJA11XX_PHY is not set
+# CONFIG_QSEMI_PHY is not set
+# CONFIG_REALTEK_PHY is not set
+# CONFIG_RENESAS_PHY is not set
+# CONFIG_ROCKCHIP_PHY is not set
+# CONFIG_SMSC_PHY is not set
+# CONFIG_STE10XP is not set
+# CONFIG_TERANETICS_PHY is not set
+# CONFIG_DP83822_PHY is not set
+# CONFIG_DP83TC811_PHY is not set
+# CONFIG_DP83848_PHY is not set
+# CONFIG_DP83867_PHY is not set
+# CONFIG_DP83869_PHY is not set
+# CONFIG_VITESSE_PHY is not set
+# CONFIG_XILINX_GMII2RGMII is not set
+CONFIG_MDIO_DEVICE=y
+CONFIG_MDIO_BUS=y
+CONFIG_FWNODE_MDIO=y
+CONFIG_OF_MDIO=y
+CONFIG_MDIO_DEVRES=y
+# CONFIG_MDIO_BITBANG is not set
+# CONFIG_MDIO_BCM_UNIMAC is not set
+# CONFIG_MDIO_HISI_FEMAC is not set
+# CONFIG_MDIO_MSCC_MIIM is not set
+# CONFIG_MDIO_IPQ4019 is not set
+# CONFIG_MDIO_IPQ8064 is not set
+
+#
+# MDIO Multiplexers
+#
+# CONFIG_MDIO_BUS_MUX_GPIO is not set
+# CONFIG_MDIO_BUS_MUX_MULTIPLEXER is not set
+# CONFIG_MDIO_BUS_MUX_MMIOREG is not set
+
+#
+# PCS device drivers
+#
+CONFIG_PCS_XPCS=y
+# end of PCS device drivers
+
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+
+#
+# Host-side USB support is needed for USB Network Adapter support
+#
+CONFIG_WLAN=y
+CONFIG_WLAN_VENDOR_ADMTEK=y
+CONFIG_WLAN_VENDOR_ATH=y
+# CONFIG_ATH_DEBUG is not set
+CONFIG_WLAN_VENDOR_ATMEL=y
+CONFIG_WLAN_VENDOR_BROADCOM=y
+CONFIG_WLAN_VENDOR_CISCO=y
+CONFIG_WLAN_VENDOR_INTEL=y
+CONFIG_WLAN_VENDOR_INTERSIL=y
+# CONFIG_HOSTAP is not set
+CONFIG_WLAN_VENDOR_MARVELL=y
+CONFIG_WLAN_VENDOR_MEDIATEK=y
+CONFIG_WLAN_VENDOR_MICROCHIP=y
+CONFIG_WLAN_VENDOR_RALINK=y
+CONFIG_WLAN_VENDOR_REALTEK=y
+CONFIG_WLAN_VENDOR_RSI=y
+CONFIG_WLAN_VENDOR_ST=y
+CONFIG_WLAN_VENDOR_TI=y
+CONFIG_WLAN_VENDOR_ZYDAS=y
+CONFIG_WLAN_VENDOR_QUANTENNA=y
+# CONFIG_PCMCIA_RAYCS is not set
+# CONFIG_WAN is not set
+
+#
+# Wireless WAN
+#
+# CONFIG_WWAN is not set
+# end of Wireless WAN
+
+# CONFIG_NET_FAILOVER is not set
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+CONFIG_INPUT_FF_MEMLESS=y
+# CONFIG_INPUT_SPARSEKMAP is not set
+# CONFIG_INPUT_MATRIXKMAP is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+CONFIG_KEYBOARD_ATKBD=y
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_GPIO is not set
+# CONFIG_KEYBOARD_GPIO_POLLED is not set
+# CONFIG_KEYBOARD_MATRIX is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_OPENCORES is not set
+# CONFIG_KEYBOARD_SAMSUNG is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_OMAP4 is not set
+CONFIG_KEYBOARD_XTKBD=y
+# CONFIG_KEYBOARD_BCM is not set
+CONFIG_INPUT_MOUSE=y
+CONFIG_MOUSE_PS2=y
+CONFIG_MOUSE_PS2_ALPS=y
+CONFIG_MOUSE_PS2_BYD=y
+CONFIG_MOUSE_PS2_LOGIPS2PP=y
+CONFIG_MOUSE_PS2_SYNAPTICS=y
+CONFIG_MOUSE_PS2_CYPRESS=y
+CONFIG_MOUSE_PS2_TRACKPOINT=y
+CONFIG_MOUSE_PS2_ELANTECH=y
+CONFIG_MOUSE_PS2_SENTELIC=y
+# CONFIG_MOUSE_PS2_TOUCHKIT is not set
+CONFIG_MOUSE_PS2_FOCALTECH=y
+CONFIG_MOUSE_SERIAL=y
+# CONFIG_MOUSE_VSXXXAA is not set
+# CONFIG_MOUSE_GPIO is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+CONFIG_INPUT_MISC=y
+# CONFIG_INPUT_AD714X is not set
+# CONFIG_INPUT_E3X0_BUTTON is not set
+# CONFIG_INPUT_GPIO_BEEPER is not set
+# CONFIG_INPUT_GPIO_DECODER is not set
+# CONFIG_INPUT_GPIO_VIBRA is not set
+# CONFIG_INPUT_UINPUT is not set
+# CONFIG_INPUT_GPIO_ROTARY_ENCODER is not set
+# CONFIG_INPUT_ADXL34X is not set
+# CONFIG_INPUT_CMA3000 is not set
+# CONFIG_RMI4_CORE is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_SERPORT=y
+CONFIG_SERIO_LIBPS2=y
+CONFIG_SERIO_RAW=y
+# CONFIG_SERIO_ALTERA_PS2 is not set
+# CONFIG_SERIO_PS2MULT is not set
+# CONFIG_SERIO_ARC_PS2 is not set
+# CONFIG_SERIO_APBPS2 is not set
+# CONFIG_SERIO_GPIO_PS2 is not set
+# CONFIG_USERIO is not set
+# CONFIG_GAMEPORT is not set
+# end of Hardware I/O ports
+# end of Input device support
+
+#
+# Character devices
+#
+CONFIG_TTY=y
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+CONFIG_VT_HW_CONSOLE_BINDING=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=16
+CONFIG_LDISC_AUTOLOAD=y
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_EARLYCON=y
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_DEPRECATED_OPTIONS=y
+CONFIG_SERIAL_8250_16550A_VARIANTS=y
+# CONFIG_SERIAL_8250_FINTEK is not set
+CONFIG_SERIAL_8250_CONSOLE=y
+# CONFIG_SERIAL_8250_CS is not set
+CONFIG_SERIAL_8250_NR_UARTS=16
+CONFIG_SERIAL_8250_RUNTIME_UARTS=16
+CONFIG_SERIAL_8250_EXTENDED=y
+CONFIG_SERIAL_8250_MANY_PORTS=y
+# CONFIG_SERIAL_8250_ASPEED_VUART is not set
+CONFIG_SERIAL_8250_SHARE_IRQ=y
+# CONFIG_SERIAL_8250_DETECT_IRQ is not set
+CONFIG_SERIAL_8250_RSA=y
+# CONFIG_SERIAL_8250_DW is not set
+# CONFIG_SERIAL_8250_RT288X is not set
+CONFIG_SERIAL_OF_PLATFORM=y
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_UARTLITE is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_SIFIVE is not set
+# CONFIG_SERIAL_SCCNXP is not set
+# CONFIG_SERIAL_BCM63XX is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_XILINX_PS_UART is not set
+# CONFIG_SERIAL_ARC is not set
+# CONFIG_SERIAL_FSL_LPUART is not set
+# CONFIG_SERIAL_FSL_LINFLEXUART is not set
+# CONFIG_SERIAL_CONEXANT_DIGICOLOR is not set
+# CONFIG_SERIAL_SPRD is not set
+# end of Serial drivers
+
+CONFIG_SERIAL_MCTRL_GPIO=y
+CONFIG_SERIAL_NONSTANDARD=y
+# CONFIG_N_HDLC is not set
+# CONFIG_N_GSM is not set
+# CONFIG_NULL_TTY is not set
+# CONFIG_SERIAL_DEV_BUS is not set
+# CONFIG_TTY_PRINTK is not set
+# CONFIG_VIRTIO_CONSOLE is not set
+CONFIG_IPMI_HANDLER=y
+CONFIG_IPMI_PLAT_DATA=y
+# CONFIG_IPMI_PANIC_EVENT is not set
+CONFIG_IPMI_DEVICE_INTERFACE=y
+CONFIG_IPMI_SI=y
+# CONFIG_IPMI_SSIF is not set
+# CONFIG_IPMI_WATCHDOG is not set
+# CONFIG_IPMI_POWEROFF is not set
+CONFIG_HW_RANDOM=y
+# CONFIG_HW_RANDOM_TIMERIOMEM is not set
+# CONFIG_HW_RANDOM_BA431 is not set
+# CONFIG_HW_RANDOM_CCTRNG is not set
+# CONFIG_HW_RANDOM_XIPHERA is not set
+
+#
+# PCMCIA character devices
+#
+# CONFIG_SYNCLINK_CS is not set
+# CONFIG_CARDMAN_4000 is not set
+# CONFIG_CARDMAN_4040 is not set
+# CONFIG_SCR24X is not set
+# CONFIG_IPWIRELESS is not set
+# end of PCMCIA character devices
+
+CONFIG_DEVMEM=y
+# CONFIG_TCG_TPM is not set
+# CONFIG_XILLYBUS is not set
+# end of Character devices
+
+# CONFIG_RANDOM_TRUST_BOOTLOADER is not set
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+# end of I2C support
+
+# CONFIG_I3C is not set
+# CONFIG_SPI is not set
+# CONFIG_SPMI is not set
+# CONFIG_HSI is not set
+CONFIG_PPS=y
+# CONFIG_PPS_DEBUG is not set
+
+#
+# PPS clients support
+#
+# CONFIG_PPS_CLIENT_KTIMER is not set
+# CONFIG_PPS_CLIENT_LDISC is not set
+# CONFIG_PPS_CLIENT_GPIO is not set
+
+#
+# PPS generators support
+#
+
+#
+# PTP clock support
+#
+# CONFIG_PTP_1588_CLOCK is not set
+
+#
+# Enable PHYLIB and NETWORK_PHY_TIMESTAMPING to see the additional clocks.
+#
+# end of PTP clock support
+
+# CONFIG_PINCTRL is not set
+CONFIG_GPIOLIB=y
+CONFIG_GPIOLIB_FASTPATH_LIMIT=512
+CONFIG_OF_GPIO=y
+# CONFIG_DEBUG_GPIO is not set
+CONFIG_GPIO_SYSFS=y
+CONFIG_GPIO_CDEV=y
+CONFIG_GPIO_CDEV_V1=y
+
+#
+# Memory mapped GPIO drivers
+#
+# CONFIG_GPIO_74XX_MMIO is not set
+# CONFIG_GPIO_ALTERA is not set
+# CONFIG_GPIO_CADENCE is not set
+# CONFIG_GPIO_DWAPB is not set
+# CONFIG_GPIO_FTGPIO010 is not set
+# CONFIG_GPIO_GENERIC_PLATFORM is not set
+# CONFIG_GPIO_GRGPIO is not set
+# CONFIG_GPIO_HLWD is not set
+# CONFIG_GPIO_LOGICVC is not set
+# CONFIG_GPIO_MB86S7X is not set
+# CONFIG_GPIO_SAMA5D2_PIOBU is not set
+# CONFIG_GPIO_SIFIVE is not set
+# CONFIG_GPIO_SYSCON is not set
+# CONFIG_GPIO_XILINX is not set
+# CONFIG_GPIO_LOONGSON1 is not set
+# CONFIG_GPIO_AMD_FCH is not set
+# end of Memory mapped GPIO drivers
+
+#
+# MFD GPIO expanders
+#
+# end of MFD GPIO expanders
+
+#
+# Virtual GPIO drivers
+#
+# CONFIG_GPIO_AGGREGATOR is not set
+# CONFIG_GPIO_MOCKUP is not set
+# end of Virtual GPIO drivers
+
+# CONFIG_W1 is not set
+# CONFIG_POWER_RESET is not set
+CONFIG_POWER_SUPPLY=y
+# CONFIG_POWER_SUPPLY_DEBUG is not set
+CONFIG_POWER_SUPPLY_HWMON=y
+# CONFIG_PDA_POWER is not set
+# CONFIG_TEST_POWER is not set
+# CONFIG_BATTERY_DS2780 is not set
+# CONFIG_BATTERY_DS2781 is not set
+# CONFIG_BATTERY_BQ27XXX is not set
+# CONFIG_CHARGER_MAX8903 is not set
+# CONFIG_CHARGER_GPIO is not set
+# CONFIG_CHARGER_LT3651 is not set
+# CONFIG_BATTERY_GOLDFISH is not set
+CONFIG_HWMON=y
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Native drivers
+#
+# CONFIG_SENSORS_AS370 is not set
+# CONFIG_SENSORS_AXI_FAN_CONTROL is not set
+# CONFIG_SENSORS_ASPEED is not set
+# CONFIG_SENSORS_CORSAIR_CPRO is not set
+# CONFIG_SENSORS_CORSAIR_PSU is not set
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_F71882FG is not set
+# CONFIG_SENSORS_GPIO_FAN is not set
+# CONFIG_SENSORS_IBMAEM is not set
+# CONFIG_SENSORS_IBMPEX is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_MAX197 is not set
+# CONFIG_SENSORS_MR75203 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_PC87427 is not set
+# CONFIG_SENSORS_NTC_THERMISTOR is not set
+# CONFIG_SENSORS_NCT6683 is not set
+# CONFIG_SENSORS_NCT6775 is not set
+# CONFIG_SENSORS_NPCM7XX is not set
+# CONFIG_SENSORS_SHT15 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_VT1211 is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+# CONFIG_THERMAL is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+# CONFIG_SSB is not set
+CONFIG_BCMA_POSSIBLE=y
+# CONFIG_BCMA is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_ATMEL_FLEXCOM is not set
+# CONFIG_MFD_ATMEL_HLCDC is not set
+# CONFIG_MFD_MADERA is not set
+# CONFIG_MFD_HI6421_PMIC is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_MFD_KEMPLD is not set
+# CONFIG_MFD_MT6397 is not set
+# CONFIG_MFD_SM501 is not set
+CONFIG_MFD_SYSCON=y
+# CONFIG_MFD_TI_AM335X_TSCADC is not set
+# CONFIG_MFD_TQMX86 is not set
+# end of Multifunction device drivers
+
+# CONFIG_REGULATOR is not set
+CONFIG_RC_CORE=y
+CONFIG_RC_MAP=y
+CONFIG_LIRC=y
+# CONFIG_BPF_LIRC_MODE2 is not set
+CONFIG_RC_DECODERS=y
+# CONFIG_IR_NEC_DECODER is not set
+# CONFIG_IR_RC5_DECODER is not set
+# CONFIG_IR_RC6_DECODER is not set
+# CONFIG_IR_JVC_DECODER is not set
+# CONFIG_IR_SONY_DECODER is not set
+# CONFIG_IR_SANYO_DECODER is not set
+# CONFIG_IR_SHARP_DECODER is not set
+CONFIG_IR_MCE_KBD_DECODER=y
+# CONFIG_IR_XMP_DECODER is not set
+# CONFIG_IR_IMON_DECODER is not set
+# CONFIG_IR_RCMM_DECODER is not set
+# CONFIG_RC_DEVICES is not set
+# CONFIG_MEDIA_CEC_SUPPORT is not set
+# CONFIG_MEDIA_SUPPORT is not set
+
+#
+# Graphics support
+#
+# CONFIG_DRM is not set
+
+#
+# ARM devices
+#
+# end of ARM devices
+
+#
+# Frame buffer Devices
+#
+CONFIG_FB_CMDLINE=y
+CONFIG_FB_NOTIFY=y
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+CONFIG_FB_MODE_HELPERS=y
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_EFI is not set
+# CONFIG_FB_OPENCORES is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_IBM_GXT4500 is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_SIMPLE is not set
+# end of Frame buffer Devices
+
+#
+# Backlight & LCD device support
+#
+# CONFIG_LCD_CLASS_DEVICE is not set
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+# CONFIG_BACKLIGHT_KTD253 is not set
+# CONFIG_BACKLIGHT_QCOM_WLED is not set
+# CONFIG_BACKLIGHT_GPIO is not set
+# end of Backlight & LCD device support
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_DUMMY_CONSOLE_COLUMNS=80
+CONFIG_DUMMY_CONSOLE_ROWS=25
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY=y
+CONFIG_FRAMEBUFFER_CONSOLE_ROTATION=y
+# CONFIG_FRAMEBUFFER_CONSOLE_DEFERRED_TAKEOVER is not set
+# end of Console display driver support
+
+CONFIG_LOGO=y
+CONFIG_LOGO_LINUX_MONO=y
+CONFIG_LOGO_LINUX_VGA16=y
+CONFIG_LOGO_LINUX_CLUT224=y
+# end of Graphics support
+
+# CONFIG_SOUND is not set
+
+#
+# HID support
+#
+CONFIG_HID=y
+# CONFIG_HID_BATTERY_STRENGTH is not set
+CONFIG_HIDRAW=y
+# CONFIG_UHID is not set
+CONFIG_HID_GENERIC=y
+
+#
+# Special HID drivers
+#
+CONFIG_HID_A4TECH=y
+# CONFIG_HID_ACRUX is not set
+# CONFIG_HID_APPLE is not set
+# CONFIG_HID_AUREAL is not set
+# CONFIG_HID_BELKIN is not set
+CONFIG_HID_CHERRY=y
+# CONFIG_HID_CHICONY is not set
+# CONFIG_HID_COUGAR is not set
+# CONFIG_HID_MACALLY is not set
+# CONFIG_HID_CMEDIA is not set
+# CONFIG_HID_CYPRESS is not set
+# CONFIG_HID_DRAGONRISE is not set
+# CONFIG_HID_EMS_FF is not set
+# CONFIG_HID_ELECOM is not set
+# CONFIG_HID_EZKEY is not set
+# CONFIG_HID_GEMBIRD is not set
+# CONFIG_HID_GFRM is not set
+# CONFIG_HID_GLORIOUS is not set
+# CONFIG_HID_VIVALDI is not set
+# CONFIG_HID_KEYTOUCH is not set
+# CONFIG_HID_KYE is not set
+# CONFIG_HID_WALTOP is not set
+# CONFIG_HID_VIEWSONIC is not set
+# CONFIG_HID_GYRATION is not set
+# CONFIG_HID_ICADE is not set
+# CONFIG_HID_ITE is not set
+# CONFIG_HID_JABRA is not set
+# CONFIG_HID_TWINHAN is not set
+# CONFIG_HID_KENSINGTON is not set
+# CONFIG_HID_LCPOWER is not set
+# CONFIG_HID_LENOVO is not set
+# CONFIG_HID_MAGICMOUSE is not set
+# CONFIG_HID_MALTRON is not set
+# CONFIG_HID_MAYFLASH is not set
+# CONFIG_HID_REDRAGON is not set
+CONFIG_HID_MICROSOFT=y
+# CONFIG_HID_MONTEREY is not set
+CONFIG_HID_MULTITOUCH=y
+# CONFIG_HID_NTI is not set
+# CONFIG_HID_ORTEK is not set
+# CONFIG_HID_PANTHERLORD is not set
+# CONFIG_HID_PETALYNX is not set
+# CONFIG_HID_PICOLCD is not set
+# CONFIG_HID_PLANTRONICS is not set
+# CONFIG_HID_PLAYSTATION is not set
+# CONFIG_HID_PRIMAX is not set
+# CONFIG_HID_SAITEK is not set
+# CONFIG_HID_SAMSUNG is not set
+# CONFIG_HID_SEMITEK is not set
+# CONFIG_HID_SPEEDLINK is not set
+# CONFIG_HID_STEAM is not set
+# CONFIG_HID_STEELSERIES is not set
+CONFIG_HID_SUNPLUS=y
+# CONFIG_HID_RMI is not set
+# CONFIG_HID_GREENASIA is not set
+# CONFIG_HID_SMARTJOYPLUS is not set
+# CONFIG_HID_TIVO is not set
+# CONFIG_HID_TOPSEED is not set
+# CONFIG_HID_UDRAW_PS3 is not set
+# CONFIG_HID_XINMO is not set
+# CONFIG_HID_ZEROPLUS is not set
+# CONFIG_HID_ZYDACRON is not set
+# CONFIG_HID_SENSOR_HUB is not set
+# CONFIG_HID_ALPS is not set
+# end of Special HID drivers
+# end of HID support
+
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+# CONFIG_USB_SUPPORT is not set
+# CONFIG_MMC is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_NEW_LEDS is not set
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_INFINIBAND is not set
+CONFIG_RTC_LIB=y
+# CONFIG_RTC_CLASS is not set
+# CONFIG_DMADEVICES is not set
+
+#
+# DMABUF options
+#
+CONFIG_SYNC_FILE=y
+# CONFIG_UDMABUF is not set
+# CONFIG_DMABUF_MOVE_NOTIFY is not set
+# CONFIG_DMABUF_DEBUG is not set
+# CONFIG_DMABUF_SELFTESTS is not set
+# CONFIG_DMABUF_HEAPS is not set
+# end of DMABUF options
+
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+# CONFIG_VFIO is not set
+# CONFIG_VIRT_DRIVERS is not set
+# CONFIG_VIRTIO_MENU is not set
+# CONFIG_VDPA is not set
+# CONFIG_VHOST_MENU is not set
+
+#
+# Microsoft Hyper-V guest support
+#
+# end of Microsoft Hyper-V guest support
+
+# CONFIG_GREYBUS is not set
+# CONFIG_COMEDI is not set
+# CONFIG_STAGING is not set
+# CONFIG_GOLDFISH is not set
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_CLK_PREPARE=y
+CONFIG_COMMON_CLK=y
+
+#
+# Clock driver for ARM Reference designs
+#
+# CONFIG_ICST is not set
+# CONFIG_CLK_SP810 is not set
+# end of Clock driver for ARM Reference designs
+
+# CONFIG_COMMON_CLK_AXI_CLKGEN is not set
+# CONFIG_COMMON_CLK_FIXED_MMIO is not set
+# CONFIG_XILINX_VCU is not set
+# CONFIG_HWSPINLOCK is not set
+
+#
+# Clock Source drivers
+#
+# CONFIG_MICROCHIP_PIT64B is not set
+# end of Clock Source drivers
+
+# CONFIG_MAILBOX is not set
+# CONFIG_IOMMU_SUPPORT is not set
+
+#
+# Remoteproc drivers
+#
+# CONFIG_REMOTEPROC is not set
+# end of Remoteproc drivers
+
+#
+# Rpmsg drivers
+#
+# CONFIG_RPMSG_VIRTIO is not set
+# end of Rpmsg drivers
+
+# CONFIG_SOUNDWIRE is not set
+
+#
+# SOC (System On Chip) specific Drivers
+#
+
+#
+# Amlogic SoC drivers
+#
+# end of Amlogic SoC drivers
+
+#
+# Broadcom SoC drivers
+#
+# end of Broadcom SoC drivers
+
+#
+# NXP/Freescale QorIQ SoC drivers
+#
+# end of NXP/Freescale QorIQ SoC drivers
+
+#
+# i.MX SoC drivers
+#
+# end of i.MX SoC drivers
+
+#
+# Enable LiteX SoC Builder specific drivers
+#
+# CONFIG_LITEX_SOC_CONTROLLER is not set
+# end of Enable LiteX SoC Builder specific drivers
+
+#
+# Qualcomm SoC drivers
+#
+# end of Qualcomm SoC drivers
+
+# CONFIG_SOC_TI is not set
+
+#
+# Xilinx SoC drivers
+#
+# end of Xilinx SoC drivers
+# end of SOC (System On Chip) specific Drivers
+
+# CONFIG_PM_DEVFREQ is not set
+# CONFIG_EXTCON is not set
+# CONFIG_MEMORY is not set
+# CONFIG_IIO is not set
+# CONFIG_PWM is not set
+
+#
+# IRQ chip support
+#
+CONFIG_IRQCHIP=y
+# CONFIG_AL_FIC is not set
+CONFIG_LS1X_IRQ=y
+CONFIG_IRQ_LOONGARCH_CPU=y
+# end of IRQ chip support
+
+# CONFIG_IPACK_BUS is not set
+CONFIG_RESET_CONTROLLER=y
+# CONFIG_RESET_MCHP_SPARX5 is not set
+# CONFIG_RESET_TI_SYSCON is not set
+
+#
+# PHY Subsystem
+#
+CONFIG_GENERIC_PHY=y
+# CONFIG_PHY_CAN_TRANSCEIVER is not set
+# CONFIG_BCM_KONA_USB2_PHY is not set
+# CONFIG_PHY_CADENCE_TORRENT is not set
+# CONFIG_PHY_CADENCE_DPHY is not set
+# CONFIG_PHY_CADENCE_SIERRA is not set
+# CONFIG_PHY_CADENCE_SALVO is not set
+# CONFIG_PHY_FSL_IMX8MQ_USB is not set
+# CONFIG_PHY_MIXEL_MIPI_DPHY is not set
+# CONFIG_PHY_PXA_28NM_HSIC is not set
+# CONFIG_PHY_PXA_28NM_USB2 is not set
+# CONFIG_PHY_OCELOT_SERDES is not set
+# end of PHY Subsystem
+
+# CONFIG_POWERCAP is not set
+# CONFIG_MCB is not set
+
+#
+# Performance monitor support
+#
+# end of Performance monitor support
+
+# CONFIG_RAS is not set
+
+#
+# Android
+#
+# CONFIG_ANDROID is not set
+# end of Android
+
+# CONFIG_DAX is not set
+CONFIG_NVMEM=y
+CONFIG_NVMEM_SYSFS=y
+# CONFIG_NVMEM_RMEM is not set
+
+#
+# HW tracing support
+#
+# CONFIG_STM is not set
+# CONFIG_INTEL_TH is not set
+# end of HW tracing support
+
+# CONFIG_FPGA is not set
+# CONFIG_FSI is not set
+# CONFIG_SIOX is not set
+# CONFIG_SLIMBUS is not set
+# CONFIG_INTERCONNECT is not set
+# CONFIG_COUNTER is not set
+# CONFIG_MOST is not set
+# end of Device Drivers
+
+#
+# File systems
+#
+# CONFIG_VALIDATE_FS_PARSER is not set
+CONFIG_FS_POSIX_ACL=y
+CONFIG_EXPORTFS=y
+# CONFIG_EXPORTFS_BLOCK_OPS is not set
+# CONFIG_FILE_LOCKING is not set
+# CONFIG_FS_ENCRYPTION is not set
+# CONFIG_FS_VERITY is not set
+# CONFIG_DNOTIFY is not set
+# CONFIG_INOTIFY_USER is not set
+# CONFIG_FANOTIFY is not set
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_FUSE_FS is not set
+# CONFIG_OVERLAY_FS is not set
+
+#
+# Caches
+#
+CONFIG_NETFS_SUPPORT=y
+# CONFIG_NETFS_STATS is not set
+CONFIG_FSCACHE=y
+# CONFIG_FSCACHE_STATS is not set
+# CONFIG_FSCACHE_HISTOGRAM is not set
+# CONFIG_FSCACHE_DEBUG is not set
+# CONFIG_FSCACHE_OBJECT_LIST is not set
+# end of Caches
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_PROC_CHILDREN=y
+CONFIG_KERNFS=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_TMPFS_XATTR=y
+CONFIG_ARCH_SUPPORTS_HUGETLBFS=y
+# CONFIG_HUGETLBFS is not set
+CONFIG_MEMFD_CREATE=y
+CONFIG_CONFIGFS_FS=y
+CONFIG_EFIVAR_FS=y
+# end of Pseudo filesystems
+
+# CONFIG_MISC_FILESYSTEMS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+# CONFIG_CEPH_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+# CONFIG_NLS_CODEPAGE_437 is not set
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+CONFIG_NLS_CODEPAGE_936=y
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ASCII=y
+# CONFIG_NLS_ISO8859_1 is not set
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_MAC_ROMAN is not set
+# CONFIG_NLS_MAC_CELTIC is not set
+# CONFIG_NLS_MAC_CENTEURO is not set
+# CONFIG_NLS_MAC_CROATIAN is not set
+# CONFIG_NLS_MAC_CYRILLIC is not set
+# CONFIG_NLS_MAC_GAELIC is not set
+# CONFIG_NLS_MAC_GREEK is not set
+# CONFIG_NLS_MAC_ICELAND is not set
+# CONFIG_NLS_MAC_INUIT is not set
+# CONFIG_NLS_MAC_ROMANIAN is not set
+# CONFIG_NLS_MAC_TURKISH is not set
+CONFIG_NLS_UTF8=y
+# CONFIG_DLM is not set
+# CONFIG_UNICODE is not set
+CONFIG_IO_WQ=y
+# end of File systems
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+CONFIG_HAVE_HARDENED_USERCOPY_ALLOCATOR=y
+# CONFIG_HARDENED_USERCOPY is not set
+# CONFIG_STATIC_USERMODEHELPER is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_LSM="landlock,lockdown,yama,loadpin,safesetid,integrity,bpf"
+
+#
+# Kernel hardening options
+#
+
+#
+# Memory initialization
+#
+CONFIG_INIT_STACK_NONE=y
+# CONFIG_INIT_ON_ALLOC_DEFAULT_ON is not set
+# CONFIG_INIT_ON_FREE_DEFAULT_ON is not set
+# end of Memory initialization
+# end of Kernel hardening options
+# end of Security options
+
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+# CONFIG_CRYPTO_MANAGER is not set
+# CONFIG_CRYPTO_USER is not set
+CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Public-key cryptography
+#
+# CONFIG_CRYPTO_RSA is not set
+# CONFIG_CRYPTO_DH is not set
+# CONFIG_CRYPTO_ECDH is not set
+# CONFIG_CRYPTO_ECDSA is not set
+# CONFIG_CRYPTO_ECRDSA is not set
+# CONFIG_CRYPTO_SM2 is not set
+# CONFIG_CRYPTO_CURVE25519 is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_CHACHA20POLY1305 is not set
+# CONFIG_CRYPTO_AEGIS128 is not set
+# CONFIG_CRYPTO_SEQIV is not set
+# CONFIG_CRYPTO_ECHAINIV is not set
+
+#
+# Block modes
+#
+# CONFIG_CRYPTO_CBC is not set
+# CONFIG_CRYPTO_CFB is not set
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+# CONFIG_CRYPTO_ECB is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_OFB is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+# CONFIG_CRYPTO_KEYWRAP is not set
+# CONFIG_CRYPTO_ADIANTUM is not set
+# CONFIG_CRYPTO_ESSIV is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_CMAC is not set
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_CRC32 is not set
+# CONFIG_CRYPTO_XXHASH is not set
+# CONFIG_CRYPTO_BLAKE2B is not set
+# CONFIG_CRYPTO_BLAKE2S is not set
+# CONFIG_CRYPTO_CRCT10DIF is not set
+# CONFIG_CRYPTO_GHASH is not set
+# CONFIG_CRYPTO_POLY1305 is not set
+# CONFIG_CRYPTO_MD4 is not set
+# CONFIG_CRYPTO_MD5 is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_SHA3 is not set
+# CONFIG_CRYPTO_SM3 is not set
+# CONFIG_CRYPTO_STREEBOG is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+# CONFIG_CRYPTO_AES is not set
+# CONFIG_CRYPTO_AES_TI is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_CHACHA20 is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_SM4 is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_LZO is not set
+# CONFIG_CRYPTO_842 is not set
+# CONFIG_CRYPTO_LZ4 is not set
+# CONFIG_CRYPTO_LZ4HC is not set
+# CONFIG_CRYPTO_ZSTD is not set
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+# CONFIG_CRYPTO_DRBG_MENU is not set
+# CONFIG_CRYPTO_JITTERENTROPY is not set
+# CONFIG_CRYPTO_USER_API_HASH is not set
+# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
+# CONFIG_CRYPTO_USER_API_RNG is not set
+# CONFIG_CRYPTO_USER_API_AEAD is not set
+
+#
+# Crypto library routines
+#
+# CONFIG_CRYPTO_LIB_BLAKE2S is not set
+# CONFIG_CRYPTO_LIB_CHACHA is not set
+# CONFIG_CRYPTO_LIB_CURVE25519 is not set
+CONFIG_CRYPTO_LIB_POLY1305_RSIZE=1
+# CONFIG_CRYPTO_LIB_POLY1305 is not set
+# CONFIG_CRYPTO_LIB_CHACHA20POLY1305 is not set
+CONFIG_CRYPTO_HW=y
+# CONFIG_CRYPTO_DEV_SAFEXCEL is not set
+# CONFIG_CRYPTO_DEV_CCREE is not set
+# CONFIG_CRYPTO_DEV_AMLOGIC_GXL is not set
+
+#
+# Certificates for signature checking
+#
+# end of Certificates for signature checking
+
+CONFIG_BINARY_PRINTF=y
+
+#
+# Library routines
+#
+# CONFIG_PACKING is not set
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_STRNCPY_FROM_USER=y
+CONFIG_GENERIC_STRNLEN_USER=y
+CONFIG_GENERIC_NET_UTILS=y
+# CONFIG_CORDIC is not set
+# CONFIG_PRIME_NUMBERS is not set
+CONFIG_RATIONAL=y
+CONFIG_GENERIC_PCI_IOMAP=y
+CONFIG_GENERIC_IOMAP=y
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC32_SELFTEST is not set
+CONFIG_CRC32_SLICEBY8=y
+# CONFIG_CRC32_SLICEBY4 is not set
+# CONFIG_CRC32_SARWATE is not set
+# CONFIG_CRC32_BIT is not set
+# CONFIG_CRC64 is not set
+# CONFIG_CRC4 is not set
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+# CONFIG_CRC8 is not set
+# CONFIG_RANDOM32_SELFTEST is not set
+CONFIG_ZLIB_INFLATE=y
+# CONFIG_XZ_DEC is not set
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_DECOMPRESS_BZIP2=y
+CONFIG_BCH=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT_MAP=y
+CONFIG_HAS_DMA=y
+CONFIG_DMA_DECLARE_COHERENT=y
+# CONFIG_DMA_API_DEBUG is not set
+CONFIG_DQL=y
+CONFIG_NLATTR=y
+CONFIG_GENERIC_ATOMIC64=y
+# CONFIG_IRQ_POLL is not set
+CONFIG_LIBFDT=y
+CONFIG_UCS2_STRING=y
+CONFIG_HAVE_GENERIC_VDSO=y
+CONFIG_GENERIC_GETTIMEOFDAY=y
+CONFIG_FONT_SUPPORT=y
+# CONFIG_FONTS is not set
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+# CONFIG_STRING_SELFTEST is not set
+# end of Library routines
+
+CONFIG_GENERIC_LIB_ASHLDI3=y
+CONFIG_GENERIC_LIB_ASHRDI3=y
+CONFIG_GENERIC_LIB_LSHRDI3=y
+CONFIG_GENERIC_LIB_CMPDI2=y
+CONFIG_GENERIC_LIB_UCMPDI2=y
+
+#
+# Kernel hacking
+#
+
+#
+# printk and dmesg options
+#
+CONFIG_PRINTK_TIME=y
+# CONFIG_PRINTK_CALLER is not set
+# CONFIG_STACKTRACE_BUILD_ID is not set
+CONFIG_CONSOLE_LOGLEVEL_DEFAULT=7
+CONFIG_CONSOLE_LOGLEVEL_QUIET=4
+CONFIG_MESSAGE_LOGLEVEL_DEFAULT=4
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_DYNAMIC_DEBUG is not set
+# CONFIG_DYNAMIC_DEBUG_CORE is not set
+CONFIG_SYMBOLIC_ERRNAME=y
+# end of printk and dmesg options
+
+#
+# Compile-time checks and compiler options
+#
+# CONFIG_DEBUG_INFO is not set
+CONFIG_FRAME_WARN=2048
+CONFIG_STRIP_ASM_SYMS=y
+# CONFIG_READABLE_ASM is not set
+# CONFIG_HEADERS_INSTALL is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+CONFIG_SECTION_MISMATCH_WARN_ONLY=y
+# CONFIG_DEBUG_FORCE_FUNCTION_ALIGN_64B is not set
+# CONFIG_VMLINUX_MAP is not set
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+# end of Compile-time checks and compiler options
+
+#
+# Generic Kernel Debugging Instruments
+#
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_MAGIC_SYSRQ_DEFAULT_ENABLE=0x1
+CONFIG_MAGIC_SYSRQ_SERIAL=y
+CONFIG_MAGIC_SYSRQ_SERIAL_SEQUENCE=""
+# CONFIG_DEBUG_FS is not set
+# CONFIG_UBSAN is not set
+# end of Generic Kernel Debugging Instruments
+
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_MISC is not set
+
+#
+# Memory Debugging
+#
+# CONFIG_PAGE_EXTENSION is not set
+# CONFIG_DEBUG_PAGEALLOC is not set
+# CONFIG_PAGE_POISONING is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_SLUB_STATS is not set
+CONFIG_HAVE_DEBUG_KMEMLEAK=y
+# CONFIG_DEBUG_KMEMLEAK is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_SCHED_STACK_END_CHECK is not set
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+CONFIG_HAVE_DEBUG_STACKOVERFLOW=y
+# CONFIG_DEBUG_STACKOVERFLOW is not set
+CONFIG_CC_HAS_KASAN_GENERIC=y
+CONFIG_CC_HAS_WORKING_NOSANITIZE_ADDRESS=y
+# end of Memory Debugging
+
+# CONFIG_DEBUG_SHIRQ is not set
+
+#
+# Debug Oops, Lockups and Hangs
+#
+# CONFIG_PANIC_ON_OOPS is not set
+CONFIG_PANIC_ON_OOPS_VALUE=0
+CONFIG_PANIC_TIMEOUT=0
+# CONFIG_SOFTLOCKUP_DETECTOR is not set
+# CONFIG_DETECT_HUNG_TASK is not set
+# CONFIG_WQ_WATCHDOG is not set
+# end of Debug Oops, Lockups and Hangs
+
+#
+# Scheduler Debugging
+#
+# CONFIG_SCHED_DEBUG is not set
+# CONFIG_SCHEDSTATS is not set
+# end of Scheduler Debugging
+
+# CONFIG_DEBUG_TIMEKEEPING is not set
+
+#
+# Lock Debugging (spinlocks, mutexes, etc...)
+#
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_RWSEMS is not set
+# CONFIG_DEBUG_ATOMIC_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_LOCK_TORTURE_TEST is not set
+# CONFIG_WW_MUTEX_SELFTEST is not set
+# CONFIG_SCF_TORTURE_TEST is not set
+# end of Lock Debugging (spinlocks, mutexes, etc...)
+
+# CONFIG_DEBUG_IRQFLAGS is not set
+# CONFIG_WARN_ALL_UNSEEDED_RANDOM is not set
+# CONFIG_DEBUG_KOBJECT is not set
+
+#
+# Debug kernel data structures
+#
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_DEBUG_PLIST is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_BUG_ON_DATA_CORRUPTION is not set
+# end of Debug kernel data structures
+
+# CONFIG_DEBUG_CREDENTIALS is not set
+
+#
+# RCU Debugging
+#
+# CONFIG_RCU_SCALE_TEST is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_RCU_REF_SCALE_TEST is not set
+CONFIG_RCU_CPU_STALL_TIMEOUT=21
+CONFIG_RCU_TRACE=y
+# CONFIG_RCU_EQS_DEBUG is not set
+# end of RCU Debugging
+
+# CONFIG_DEBUG_WQ_FORCE_RR_CPU is not set
+CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
+CONFIG_TRACE_CLOCK=y
+# CONFIG_SAMPLES is not set
+
+#
+# loongarch Debugging
+#
+CONFIG_EARLY_PRINTK=y
+# end of loongarch Debugging
+
+#
+# Kernel Testing and Coverage
+#
+# CONFIG_KUNIT is not set
+# CONFIG_NOTIFIER_ERROR_INJECTION is not set
+# CONFIG_FAULT_INJECTION is not set
+CONFIG_CC_HAS_SANCOV_TRACE_PC=y
+CONFIG_RUNTIME_TESTING_MENU=y
+# CONFIG_TEST_MIN_HEAP is not set
+# CONFIG_TEST_SORT is not set
+# CONFIG_TEST_DIV64 is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_RBTREE_TEST is not set
+# CONFIG_REED_SOLOMON_TEST is not set
+# CONFIG_INTERVAL_TREE_TEST is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_TEST_HEXDUMP is not set
+# CONFIG_TEST_STRING_HELPERS is not set
+# CONFIG_TEST_STRSCPY is not set
+# CONFIG_TEST_KSTRTOX is not set
+# CONFIG_TEST_PRINTF is not set
+# CONFIG_TEST_SCANF is not set
+# CONFIG_TEST_BITMAP is not set
+# CONFIG_TEST_UUID is not set
+# CONFIG_TEST_XARRAY is not set
+# CONFIG_TEST_OVERFLOW is not set
+# CONFIG_TEST_RHASHTABLE is not set
+# CONFIG_TEST_HASH is not set
+# CONFIG_TEST_IDA is not set
+# CONFIG_FIND_BIT_BENCHMARK is not set
+# CONFIG_TEST_FIRMWARE is not set
+# CONFIG_TEST_SYSCTL is not set
+# CONFIG_TEST_UDELAY is not set
+# CONFIG_TEST_MEMCAT_P is not set
+# CONFIG_TEST_STACKINIT is not set
+# CONFIG_TEST_MEMINIT is not set
+# CONFIG_TEST_FREE_PAGES is not set
+# end of Kernel Testing and Coverage
+# end of Kernel hacking
diff --git a/drivers/of/Kconfig b/drivers/of/Kconfig
index 3dfeae8912df..311b022fcdf7 100644
--- a/drivers/of/Kconfig
+++ b/drivers/of/Kconfig
@@ -4,6 +4,7 @@ config DTC
 
 menuconfig OF
 	bool "Device Tree and Open Firmware support"
+	select OF_EARLY_FLATTREE
 	help
 	  This option enables the device tree infrastructure.
 	  It is automatically selected by platforms that need it or can
diff --git a/drivers/tty/serial/8250/8250_core.c b/drivers/tty/serial/8250/8250_core.c
index 1ce193daea7f..ccc73dae2cd3 100644
--- a/drivers/tty/serial/8250/8250_core.c
+++ b/drivers/tty/serial/8250/8250_core.c
@@ -715,7 +715,7 @@ int __init early_serial_setup(struct uart_port *port)
 	p->membase      = port->membase;
 	p->irq          = port->irq;
 	p->irqflags     = port->irqflags;
-	p->uartclk      = port->uartclk;
+	p->uartclk      = 33000000;
 	p->fifosize     = port->fifosize;
 	p->regshift     = port->regshift;
 	p->iotype       = port->iotype;
diff --git a/la_build.sh b/la_build.sh
new file mode 100755
index 000000000000..7378468c6957
--- /dev/null
+++ b/la_build.sh
@@ -0,0 +1,10 @@
+#!/bin/bash
+
+export CROSS_COMPILE=~/install-32-glibc-loongarch-novec-reduce-linux-5-14/bin/loongarch32-linux-gnu-
+export ARCH=loongarch
+OUT=la_build
+
+echo "----------------output ${OUT}----------------"
+
+make menuconfig O=${OUT}
+make vmlinux -j  O=${OUT} 2>&1 | tee -a build_error.log
-- 
2.37.2

