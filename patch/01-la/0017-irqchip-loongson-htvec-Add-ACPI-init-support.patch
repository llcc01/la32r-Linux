From 64e295773fcba3cc5d4d801946b16bf288f26dfd Mon Sep 17 00:00:00 2001
From: Huacai Chen <chenhuacai@loongson.cn>
Date: Thu, 31 Dec 2020 15:13:33 +0800
Subject: [PATCH 17/48] irqchip/loongson-htvec: Add ACPI init support

We are preparing to add new Loongson (based on LoongArch, not MIPS)
support. LoongArch use ACPI other than DT as its boot protocol, so
add ACPI init support.

Signed-off-by: Huacai Chen <chenhuacai@loongson.cn>
---
 drivers/irqchip/irq-loongson-htvec.c | 70 +++++++++++++++++++++++++++-
 1 file changed, 69 insertions(+), 1 deletion(-)

diff --git a/drivers/irqchip/irq-loongson-htvec.c b/drivers/irqchip/irq-loongson-htvec.c
index 60a335d7e64e..baa41ee94ad3 100644
--- a/drivers/irqchip/irq-loongson-htvec.c
+++ b/drivers/irqchip/irq-loongson-htvec.c
@@ -20,7 +20,6 @@
 /* Registers */
 #define HTVEC_EN_OFF		0x20
 #define HTVEC_MAX_PARENT_IRQ	8
-
 #define VEC_COUNT_PER_REG	32
 #define VEC_REG_IDX(irq_id)	((irq_id) / VEC_COUNT_PER_REG)
 #define VEC_REG_BIT(irq_id)	((irq_id) % VEC_COUNT_PER_REG)
@@ -30,8 +29,11 @@ struct htvec {
 	void __iomem		*base;
 	struct irq_domain	*htvec_domain;
 	raw_spinlock_t		htvec_lock;
+	struct fwnode_handle	*domain_handle;
 };
 
+struct htvec *htvec_priv;
+
 static void htvec_irq_dispatch(struct irq_desc *desc)
 {
 	int i;
@@ -155,6 +157,8 @@ static void htvec_reset(struct htvec *priv)
 	}
 }
 
+#ifdef CONFIG_OF
+
 static int htvec_of_init(struct device_node *node,
 				struct device_node *parent)
 {
@@ -202,6 +206,8 @@ static int htvec_of_init(struct device_node *node,
 		irq_set_chained_handler_and_data(parent_irq[i],
 						 htvec_irq_dispatch, priv);
 
+	htvec_priv = priv;
+
 	return 0;
 
 irq_dispose:
@@ -216,3 +222,65 @@ static int htvec_of_init(struct device_node *node,
 }
 
 IRQCHIP_DECLARE(htvec, "loongson,htvec-1.0", htvec_of_init);
+
+#endif
+
+#ifdef CONFIG_ACPI
+
+struct fwnode_handle *htvec_acpi_init(struct fwnode_handle *parent,
+					struct acpi_madt_ht_pic *acpi_htvec)
+{
+	int i, parent_irq[8];
+	struct htvec *priv;
+	struct irq_fwspec fwspec;
+
+	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return NULL;
+
+	priv->num_parents = HTVEC_MAX_PARENT_IRQ;
+	priv->base = ioremap(acpi_htvec->address, acpi_htvec->size);
+
+	/* Interrupt may come from any of the 8 interrupt lines */
+	for (i = 0; i < priv->num_parents; i++)
+		parent_irq[i] = acpi_htvec->cascade[i];
+
+	priv->domain_handle = irq_domain_alloc_fwnode(priv->base);
+	if (!priv->domain_handle) {
+		pr_err("Unable to allocate domain handle\n");
+		goto iounmap_base;
+	}
+
+	/* Setup IRQ domain */
+	priv->htvec_domain = irq_domain_create_linear(priv->domain_handle,
+					(VEC_COUNT_PER_REG * priv->num_parents),
+					&htvec_domain_ops, priv);
+	if (!priv->htvec_domain) {
+		pr_err("loongson-htvec: cannot add IRQ domain\n");
+		goto iounmap_base;
+	}
+
+	htvec_reset(priv);
+
+	for (i = 0; i < priv->num_parents; i++) {
+		fwspec.fwnode = parent;
+		fwspec.param[0] = parent_irq[i];
+		fwspec.param_count = 1;
+		parent_irq[i] = irq_create_fwspec_mapping(&fwspec);
+		irq_set_chained_handler_and_data(parent_irq[i],
+						 htvec_irq_dispatch, priv);
+	}
+
+	htvec_priv = priv;
+
+	return htvec_priv->domain_handle;
+
+iounmap_base:
+	iounmap(priv->base);
+	priv->domain_handle = NULL;
+	kfree(priv);
+
+	return NULL;
+}
+
+#endif
-- 
2.37.2

